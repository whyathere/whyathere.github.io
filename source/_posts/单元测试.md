---
title: Junit
date: 2018-05-21 19:37:39
tags: 单元测试
categories: 单元测试
---

### 单元测试

#### 什么是单元测试？

- 单元测试是**开发人员**编写的一小段代码，用于检验被测代码的一个有明确功能的小模块是否正确
  - 通常是用来判断某个类和函数的行为
  - 白盒测试：开发人员已经很清楚的知道代码的内部实现。黑盒测试：不知道内部的实现是什么，只知道对外提供的接口，软件像黑盒一样，对外暴露了一些接口，要验证是否与自己所想的一样。
  - **开发人员**是最大的收益者

#### 测试用例

```java
    @Test
    public  void testString(){
        int a=25;
        Assert.assertEquals(25,a);
    }
```

绿色表示通过。

只要按照规律来写代码，框架能够找到我们的测试用例，如上所示。然后，执行这些测试用例，通过Assert来检查实际值和期待值是否一致。如果不一致就是bug。

 ![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E6%88%90%E7%99%BE%E4%B8%8A%E5%8D%83%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%A5%E6%80%8E%E4%B9%88%E7%BB%84%E7%BB%87.jpg?raw=true)

作为一个套件来执行，套件下有各种V*Tests。

#### JUnit常用的几种断言

Assert.assertEquals(expected,actual);   两个数值变量等是否一致

Assert.assertTrue(condition);   是否为true

Assert.assertNotNull(object);  是否为null

Assert.assertArrayEquals(expecteds,actuals);   数组是否相等



#### 如何对Exception进行测试



![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E5%A6%82%E4%BD%95%E5%AF%B9Exception%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95.jpg?raw=true)

#### 两个特殊的方法

![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95.jpg?raw=true)

有多少个testCase就有多少个setUp()和tearDown()

#### 两个更特殊的方法

![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E4%B8%A4%E4%B8%AA%E6%9B%B4%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95.jpg?raw=true)

### 单元测试的优点

- 验证行为
  - 保证代码的正确性
  - 回归测试：即使到项目后期，我们仍然有勇气去增加新功能，修改程序结果，而不用担心破坏重要功能
  - 给重构带来保证
- 设计行为
  - **测试驱动**迫使我们从调用者的角度去观察和思考问题，迫使我们把代码设计成可测试的，松耦合的。
- 文档行为
  - 单元测试是一种无价的文档，精确的描述了代码的行为，是如何使用函数和类的最佳文档

#### 单元测试是个团队行为

- 互相帮助 ，互相扶持，共同前进
  - **你运行别人的测试用例：验证你的代码修改**
  - **别人运行你的测试用例：验证别人的代码修改**

#### 单元测试的原则

- **测试代码和被测试是同等重要的，需要被同时维护**
  - **测试代码不是附属品**
  - **不但要重构代码，也要重构单元测试！**
- **单元测试一定是隔离的**
  - **一个测试用例的运行结果不能影响其他测试用例**
  - **测试用例不能相互依赖，应该能够以任何次序执行**
- **单元测试一定是可以重复执行的**
  - **不能依赖环境变化**
- **保持单元测试的简单性和可读性**
- **尽量对接口进行测试**
- **单元测试应该可以迅速执行**(不可能等待几十分钟，应该是秒级的)
  - **给程序员提供及时的反馈**
  - **使用Mock对象对数据库，网络的依赖进行解耦**
- **自动化单元测试**
  - **集成到build过程中去**

#### 使用Mock对象

- **真实的对象不易构造**
  - **例如httpservlet必须在servlet容器中才能创建出来**
- **真实的对象非常复杂**
  - **如jdbc中的Connection，ResultSet**
- **真实的对象的行为具有不确定性，难于控制他们的输出或者返回结果**
- **真实的对象的有些行为难于触发，例如硬盘已满，网络连接断开**
- **真实的对象可能还不存在，例如依赖的另外一个模块还没开发完毕**



![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/Mock%20Object%E7%9A%84%E4%BE%8B%E5%AD%90.jpg?raw=true)

![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E4%BD%BF%E7%94%A8Mock%E5%AF%B9%E8%B1%A1.jpg?raw=true)

录制和回放。

### 对遗留代码进行测试

- 遗留代码不可避免
  - **虽然TDD是很有效的编程方法，但是我们的工作很少从第一行代码开始。**
- **遗留代码不是坏代码**
  - **它是可以工作的软件/组件，但是**
  - **在设计和开发时没有考虑“可测试性”**
- **遗留代码难于测试**
  - **长久失修，导致业务逻辑难于理解**
  - **依赖的资源太多，导致测试无从下手**
  - **不敢修改，害怕牵一发而动全身**

如果代码去访问数据库和访问网络如何测试。

#### 处理遗留代码的策略

- **重构代码，提高可测试性**
- **使用Mock Object接触依赖**
- **测试分解**
  - **先写粗粒度的测试代码，然后编写细粒度的代码**
  - **Package->Class->method**

#### 处理遗留代码的步骤

- **确定要测试的类和函数**
- **解除依赖**(最重要，解除依赖的时候可能破坏掉代码，但是必须要做，所以尽可能的不要破坏老的功能)
- **编写测试用例**
- **重构代码**



**重构的例子‘**

![](https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Junit/%E9%87%8D%E6%9E%84%E7%9A%84%E4%BE%8B%E5%AD%90.jpg?raw=true)

#### 好的单元测试

- 简单
  - 防止多度的Steup，否则不知道是单元测用例的错误，还是业务逻辑的错误
- 隔离
- 可重复
  - 防止在一台机器上可以运行，在另外一台机器上失败
  - 防止今天成功，明天失败
- 运行快
  - 防止长时间的运行
- 代码覆盖面广
  - 防止测试通过，但是没测到什么代码


---
title: 深入理解计算机原理
date: 2018-09-10 18:27:21
tags: 计算机原理
---

## 第三章

### 程序编码

#### 机器级代码

​	计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。其中两种尤为重要。第一种是由指令集体系结构或指令集架构，来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

​	它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

​	第二种抽象是，机器级程序使用的内存地址是虚拟的地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

​	在编译过程中，编译器会将C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。

​	计算机系统底层硬件只识别机器语言，而处理器就是用来执行一系列指令，每条指令执行某个简单的操作。比如两个数相加，汇编指令ADD会被编码为一个或多个字节组成的二进制格式。

​	这里 **一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构(Instruction-Set Architecture ,ISA)**

​	而不同的处理器家族，比如Intel IA32、IBM/Freescale PowerPC和AMD处理器家族，都有不同的ISA。不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言是一样的。不同的处理器，其指令集体系结构也不一样，也就是说一个程序编译在一种机器上运行，就不能在另外一种机器上运行。如何处理这种兼容性问题呢？ **ISA在编译器编写者和处理器设计人之间提供了一个抽象概念层，编译器编写者只需要知道允许那些指令，以及它们是如何编写的；而处理器设计者必须建造出这些指令的处理器。**



- 程序计数器(通常称为"PC"，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。

机器代码只是简单地将内存看出一个很大的、按字节寻址的数组。C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。**即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数**

​	程序内存包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用 **虚拟地址来寻址**。在任意给定时刻，只有有限的一部分虚拟地址被认为是合法的。例如，x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是2的48次方或64TB范围内的一个字节。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。



反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。

### 数据格式

​	由于是从16位体系结构扩展成32位的，Intel 用术语 “字(word)”表示16位数据类型。因此32位数为"双字(double words)"，称64位数为"四字(quad words)"。

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
| :----: | :-----------: | :----------: | :--------: |
|  char  |     字节      |      b       |     1      |
| short  |      字       |      w       |     2      |
|  int   |      字       |      l       |     4      |
|  long  |     四字      |      q       |     8      |
| char*  |     四字      |      q       |     8      |
| float  |    单精度     |      s       |     4      |
| double |    双精度     |      l       |     8      |

​			C语言数据类型在x86-64中的大小。在64位机器中，指针长8字节

​	浮点数主要有两种形式：单精度(4字节)值，对应于C语言数据类型float；双精度对应double。	

​	如上表所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如：数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。注意，汇编代码也会使用后缀'1'来表示4字节整数和8字节双精度浮点数。因为浮点数使用的是一组完全不同的指令和寄存器。

### 访问信息

​	一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的 **通用目的的寄存器**。这些寄存器用来**存储整数数据和指针。**



![](http://pcq0v117m.bkt.clouddn.com/2018-11-16-093431.png)

#### 操作数指示符

​	大多数指令有一个或多个 **操作数(operand)**，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式。如下图。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。

​	第一种类型是 **立即数(immediate)**，用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是'$'后面跟一个用标准C表示法表示的整数，比如,$-577或$0x1F。不同的指令允许的立即数数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。

​	第二种类型是 **寄存器(register)**，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节分别对应于8位、16位、32位或64位。符号ra来表示任意寄存器a，用引用R[ra]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符做索引。

​	第三类操作数是 **内存引用**，它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为将内存看成一个很大的字节数组。



![image-20181116173554467](http://pcq0v117m.bkt.clouddn.com/2018-11-16-093554.png)

#### 数据传送指令

​	最频繁使用的指令是将数据从一个位置复制到另一个位置。

|      指令       | 效果 |      描述       |
| :-------------: | :--: | :-------------: |
|  MOV       S,D  | D←S  |      传送       |
|      movb       |      |    传送字节     |
|      movw       |      |  传送字(2字节)  |
|      movl       |      | 传送双字(4字节) |
|      movq       |      | 传送四字(8字节) |
| movabsq     I,R | R←I  | 传送绝对的四字  |



​	源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个 **位置**，要么是一个寄存器要么是一个内存地址。x86-64限制， **传送指令的两个操作数不能都指向内存位置。**因为这样需要将需要两条指令：第一条指令将源值加载到寄存器中，第二条将寄存器值写入到目的位置。

#### 压入和弹出栈数据

在x86-64中，程序栈存放在内存中某个区域。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。

将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令 pushq %rbp的行为等价于下面两条指令：

​	subq $8,%rsp

​	movq %rbp,(%rsp)

它们之前的区别是在机器代码中pushq指令编码为1个字节，而上面那两条指令一共需要8个字节。

如下图前两栏给出的是，当%rsp为0x108,%rax 为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后将0x123存放到内存地址0x100处。

![image-20181116173231518](http://pcq0v117m.bkt.clouddn.com/2018-11-16-093235.png)

弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8.因此，指令popq %rax等价于下面两条指令：		

​	movq (%rsp),%rax

​	add $8,%rsp

​	上图的第三栏说明的是在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读处值 0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值将增加回到0x108。如图中所示，值0x123仍然会保持在内存位置0x100中，知道被覆盖(例如被另外一条入栈操作覆盖)。无论如何，%rsp指向的地址总是栈顶。

​	因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令movq 8(%rsp),%rdx会将第二个四字从栈中复制到寄存器%rdx.

## 第八章：异常控制流

从处理器通电开始，知道断电，程序计数器假设了一个值的序列

​		a0,a1,a2……,an-1

每个ak是某个相应的指令Ik的地址。每次从ak到ak+1的过渡叫  `控制转移`(control transfer)。这样的控制转义序列叫做处理器的 `控制流`(flow of control 或control flow)。

最简单的控制流是一个“平滑的”序列，每个Ik和Ik+1在内存中都是相邻的。不相邻的就是平滑流的突变，通常是由诸如跳转、调用和返回这样的程序指令造成的。这样使得程序能够对程序变量表示的内部程序状态中的变化做出反应。

系统也应该要对系统状态的变化做出反应，例如网络信号的到达，必须放到内存中，需要处理器进行反应。现代的操作系统通过 `是控制流发生突变来对这些情况做出反应`。一般而言，我们称这些突变为 **异常控制流(Exceptional Control Flow ,ECF)**

应用和操作系统的交互都是围绕着ECF开始的。一个计算机操作系统中所有层次上有各种各样的ECF，从异常开始，异常位于硬件和操作系统交界的部分。

### 异常

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现;是控制流中的一种突变，用来响应处理器状态中的某些变化。


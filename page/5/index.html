<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bill">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Bill">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bill">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Bill</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/BOS-第七天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/BOS-第七天/" itemprop="url">BOS-第七天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T16:30:00+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="业务受理"><a href="#业务受理" class="headerlink" title="业务受理"></a>业务受理</h3><h4 id="取派业务业务分析说明"><a href="#取派业务业务分析说明" class="headerlink" title="取派业务业务分析说明"></a>取派业务业务分析说明</h4><p>当用户打电话来的时候，录入用户信息的时候，录入完之后。业务通知单就要生成，录入系统之后发生了什么呢？<br>这种物业通知单应该隶属于哪一个取派员，将这个通知单自动分配给取派员。<br>那么这里就是根据用户的地址自动分配给取派员，要自动分解是属于哪一个区域的取派员。</p>
<p>业务通知单自动分拣 说明  如下图</p>
<ol>
<li>系统自动根据委托发件人的详细地址CRM中的地址库进行完全匹配，获取对应的分拣<br> 编码：bos根据用户地址<br> webservice—-&gt;CRM<br> CRM提供根据地址查询客户信息的服务<br> findCustomerByAddress—&gt;Customer–&gt;decidezoneID–&gt;DecideZone–&gt;Staff<br> 业务通知单  给予  指定 取派员!<br> 总结：根据地址找到定区，以分配取派员</li>
<li>管理分区 匹配方法<br> 地址有误、客户找不到的时候第一个方法就不适用了<br> 通过分区中的属性，解析出详细地址，省市区。<br> 如果关键字相同就通过辅助关键字匹配。<br>例子：用户输入的取件地址<br> 规则：根据省市区查找区域，查询Region。通过级联查询找到这个区域的所有分区(subarea)<br> –&gt;循环筛选关键字–&gt;通过分区去找定区–&gt;Staff</li>
</ol>
<p>今天主要要实现的是自动分拣（自动分单）<br>两种方法的目的是一致的，最终都是分拣到取派员。</p>
<pre><code>有两种情况： 1.已经录入过客户，输入手机号以后会回显客户的其他信息。
           2.客户直接打电话过来，没有注册就需要通过bos添加到CRM里面
</code></pre><h4 id="通知单和工单设计说明"><a href="#通知单和工单设计说明" class="headerlink" title="通知单和工单设计说明"></a>通知单和工单设计说明</h4><pre><code>如果自动分拣成功，就有取派员的编号。
如果没有的话就是一个空值。自动分单也分类型：自动 人工  可以根据类型来查询
受理人：操作员    

业务通知单和工单：
业务通知单的：描述客户订单具体信息
工单：描述取派员任务
业务通知单一旦生成   对应一个工单（描述取派员任务）
工单的生成时机：自动分拣成功，系统自动生成工单；如果业务通知单自动分拣，人工--&gt;工单生成时机是在人工调度的时候生成。
</code></pre><h4 id="省市区三级联动"><a href="#省市区三级联动" class="headerlink" title="省市区三级联动"></a>省市区三级联动</h4><p>用户选择省 发送ajax请求  获取对应的市<br><img src="http://whyathere.github.io/images/bos/day07/取件省市区三级联动.jpg" alt=""><br>页面加载完成，立刻发送ajax请求，访问省信息<br>            //加载省<br>            $.post(“${pageContext.request.contextPath}/bc/regionAction_ajaxListProvinces”, function (data) {<br>                $(data).each(function () {<br>                    $(“#province”).append(“<option value="" + this + "">“ + this + “</option>“);<br>                });<br>            });<br>            //用户统计省  发送ajax  获取到对应的市<br>            $(“#province”).change(function () {<br>                $.post(‘${pageContext.request.contextPath}/bc/regionAction_ajaxListCitys’, {“province”: this.value}, function (data) {<br>                    //List<string><br>                    $(data).each(function () {<br>                        $(‘#city’).append(“<option value="" + this + "">“ + this + “</option>“);<br>                    });<br>                });<br>            });<br>Action<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    //省</span><br><span class="line">    @Action(value = <span class="string">"regionAction_ajaxListProvinces"</span>, results = &#123;@Result(name = <span class="string">"ajaxListProvinces"</span>, <span class="built_in">type</span> = <span class="string">"json"</span>)&#125;)</span><br><span class="line">    public String <span class="function"><span class="title">ajaxListProvinces</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; regions = serviceFacade.getRegionService().ajaxListProvinces();</span><br><span class="line">            push(regions);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"ajaxListProvinces"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">//当  省改变时，自动查询市</span><br><span class="line">    //City</span><br><span class="line">    @Action(value = <span class="string">"regionAction_ajaxListCitys"</span>, results = &#123;@Result(name = <span class="string">"ajaxListCitys"</span>, <span class="built_in">type</span> = <span class="string">"json"</span>)&#125;)</span><br><span class="line">    public String <span class="function"><span class="title">ajaxListCitys</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; citys = serviceFacade.getRegionService().ajaxListCitys(model.getProvince());</span><br><span class="line">            push(citys);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"ajaxListCitys"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></string></p>
<p>但是这个时候多切换几次省市，就会发现问题。如下图：<br><img src="http://whyathere.github.io/images/bos/day07/省市区三级联动异常.jpg" alt=""><br>切换省以后，后面的市会将上次查找的也叠加进来。</p>
<p>优化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//加载省</span><br><span class="line">$.post(<span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/regionAction_ajaxListProvinces"</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">    $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        $(<span class="string">"#province"</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//用户统计省  发送ajax  获取到对应的市</span><br><span class="line">$(<span class="string">"#province"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    $(<span class="string">"#city"</span>)[0].length=1;</span><br><span class="line">    $.post(<span class="string">'$&#123;pageContext.request.contextPath&#125;/bc/regionAction_ajaxListCitys'</span>, &#123;<span class="string">"province"</span>: this.value&#125;, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">        //List&lt;String&gt;</span><br><span class="line">        $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            $(<span class="string">'#city'</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//用户选择市  发送ajax  获取到对应的区</span><br><span class="line">$(<span class="string">"#city"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    $(<span class="string">"#district"</span>)[0].length=1;</span><br><span class="line">    $.post(<span class="string">'$&#123;pageContext.request.contextPath&#125;/bc/regionAction_ajaxListDistricts'</span>, &#123;<span class="string">"city"</span>: this.value&#125;, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">        //List&lt;String&gt;</span><br><span class="line">        $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            $(<span class="string">'#district'</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是这个时候又出问题了。在上次点击了省和市之后，然后再取消省和市的选择。单点击区会出现下面的情况：<br><img src="http://whyathere.github.io/images/bos/day07/省市区三级联动异常2.jpg" alt=""><br>这就很尴尬了，所以还是需要优化。在JS页面中，在city的联动中添加代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用户统计省  发送ajax  获取到对应的市</span><br><span class="line">         $(<span class="string">"#province"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">             $(<span class="string">"#city"</span>)[0].length=1;</span><br><span class="line">             $(<span class="string">"#district"</span>)[0].length=1;</span><br></pre></td></tr></table></figure></p>
<p>搞定！！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/Eclipse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/Eclipse/" itemprop="url">Eclipse</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T18:23:46+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发工具/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Eclipse-ini文件"><a href="#Eclipse-ini文件" class="headerlink" title="Eclipse.ini文件"></a>Eclipse.ini文件</h3><p>该文档中提及的以下警告信息需要重点注意。</p>
<ul>
<li>-vmargs 之后的所有行都被作为参数传递给JVM；Eclipse的所有参数和选项必须在 -vmargs之前指定(正如在命令行上使用参数一样)。</li>
</ul>
<p>这就是为什么要在文件开始处插入 -vm 选项的原因。</p>
<ul>
<li>在命令行中使用 -vmargs将覆盖所有在 .ini文件中的 -vmargs设置，除非在.ini文件中或命令行中指定了 –auncher.appendVmargs。</li>
</ul>
<p><strong>设置 -vm选项</strong></p>
<p>设置 -vm 选项用于确定Eclipse使用那个JVM实现。你可能会注意到我们已经选定了JVM作为一个库(<em>.dll /</em>.so)，这在启动时能提供更好的性能，还支持程序作为Eclipse可执行文件运行而并不是作为Java可执行文件。</p>
<p>如果没有设置-vm 选项时，Eclipse 使用那个JVM，请注意Eclipse不查询JAVA_HOME 环境变量(Eclipse wiki)。相反，Eclipse执行解析path环境变量的Java命令。</p>
<p><strong>自定义JVM参数</strong></p>
<p>推荐的JVM参数列表来自于Piotr Gabryanczyk 在Java内存管理模型方面的研究成果。最初用于JetBRAINS Intellij设置，这种配置对Eclipse环境也有用的。在一下场合中有帮助；</p>
<ul>
<li>防止垃圾回收器中断程序的运行超过10ms(-XX:MaxGCPauseMillis=10)</li>
<li>降低垃圾回收器启动的级别到30%的所占用内存(-XX:MaxHeapFreeRatio=70)</li>
<li>强制垃圾回收器作为一个并行线程运行，降低对应用程序的干扰(-XX:+UseConcMarkSweepGC)</li>
<li>为垃圾回收器选择增量模式，可以在GC工作中生成中断让应用程序明确地停止冻结(-XX:+CMSIncrementalPacing)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Spring-MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Spring-MVC/" itemprop="url">Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SpringMVC的注解"><a href="#SpringMVC的注解" class="headerlink" title="SpringMVC的注解"></a>SpringMVC的注解</h3><ol>
<li>@ModelAttribute</li>
</ol>
<p>大致有两种使用方式，一种是直接标记在方法上，一种是标记在方法的参数中，两种标记方法产生的效果也各不相同。</p>
<ul>
<li>注解放在方法上面</li>
</ul>
<p>当同一个controller中有任意一个方法被@ModelAttribute注解标记，页面请求只要进入这个控制器，不管请求那个方法，均会先执行被@ModelAttribute标记的方法，所以我们可以用@ModelAttribute注解的方法做一些初始化操作。当同一个controller中有多个方法被@ModelAttribute注解标记，所有被@ModelAttribute标记的方法均会被执行，按先后顺序执行，然后再进入请求的方法。</p>
<p>​    </p>
<p>下面方法做一些变形，变形为带有参数的返回，这样也是实际开发中经常会操作的 </p>
<p>首先创建一个pojo对象，对象包含name，sex两个属性。并对JSP及控制器代码做一些修改</p>
<p>页面首先使用EL表达式接收返回参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span> + request.getServerName() + <span class="string">":"</span> + request.getServerPort() + path + <span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>, function () &#123;</span><br><span class="line"></span><br><span class="line">                window.location.href = <span class="string">"&lt;%=basePath%&gt;model/modelTest.do"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.name &#125;"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>@ModelAtterbute方法无返回值情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="keyword">null</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问ModelTest.jsp页面并点击测试</p>
<p> <img src="https://img-blog.csdn.net/20170225235700722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从执行结果看出，当访问请求时，会首先访问init方法，然后再对modelTest方法进行访问，并且是同一个请求，因为model模型数据的作用域与request相同，所以可以用此标记直接标记在方法上对实际要访问的方法进行一些初始化操作</p>
<ul>
<li>@ModelAttribute标记方法有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入init方法"</span>);</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"model/befor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"befor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">befor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入befor方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里稍微做了点变形，可以看到在被@ModelAttribute方法中设值了返回路径为befor方法，但是在在代码运行的过程中并不会跳转befor方法，而是在代码执行完成return之前直接跳转了实际请求的方法。不执行return</p>
<p> 进入init方法<br>进入modelTest方法</p>
<ul>
<li><p>当@RequestMapping标记和@ModelAttribute同时标记在一个方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试页面发现进入控制器后返回，页面报404，这是因为当两个注解标记到同一个方法上时，逻辑视图名并不是返回值，而是返回请求的路径，根据model/modelTest.do生成逻辑视图。在这里我们修改下代码，把controller上的@RequestMapping标记去掉，并修改下页面的请求路径，让生成的视图路径和访问的页面路径相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(function()&#123;</span><br><span class="line">           $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">  </span><br><span class="line">               window.location.href=<span class="string">"&lt;%=basePath%&gt;modelTest.do"</span>;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo &#125;"</span>&gt;</span><br><span class="line">  </span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>点击测试页面，会发现当两个注解同时注解到一个方法上时，方法的返回值会变成model模型的返回值，key是标记的名</p>
<h4 id="ModelAttribute标记在参数前"><a href="#ModelAttribute标记在参数前" class="headerlink" title="@ModelAttribute标记在参数前"></a>@ModelAttribute标记在参数前</h4><p>从from表单或url地址中取值，这里就以url地址为例，为了避免url地址中文乱码问题，这里调用了encodeURL函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line"></span><br><span class="line">                window.location.href=<span class="string">"&lt;%=basePath%&gt;model/modelTest.do?userName="</span>+encodeURI(<span class="string">'小明'</span>)+<span class="string">"&amp;sex="</span>+encodeURI(<span class="string">'男'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.userName &#125;"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pojo.setUserName(<span class="keyword">new</span> String(pojo.getUserName().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">            pojo.setSex(<span class="keyword">new</span> String(pojo.getSex().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击页面测试，页面文本框会显示URL地址传递过来的参数，因为SpringMVC会自动匹匹配页面传递过来的参数的name属性和后台控制器中的方法中的参数名，如果参数名相同，会自动匹配，如果控制器中方法是封装的bean,会自动匹配bean中的属性，其实这种取值方式不需要用@ModelAttribute注解，只要满足匹配要求，也能拿得到值</p>
<p> <img src="https://img-blog.csdn.net/20170226011711946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从model对象中取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PojoTest <span class="title">init</span><span class="params">( PojoTest pojo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setSex(<span class="string">"男"</span>);</span><br><span class="line">        <span class="keyword">return</span> pojo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setUserName(<span class="string">"小明"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试发现，modelTest拿到inint方法中的pojo对象，合并两次set的参数后返回页面</p>
</li>
</ul>
<p>   <img src="https://img-blog.csdn.net/20170226023308348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Java多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Java多线程/" itemprop="url">Java 多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-多线程/" itemprop="url" rel="index">
                    <span itemprop="name">Java 多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>注意事项：</strong></p>
<ul>
<li>线程不安全就意味着线程的调度顺序会影响最终结果</li>
<li>线程安全的优先级高于性能</li>
<li>当多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。</li>
</ul>
<p><strong>总结涉及到多线程的内容：</strong></p>
<ul>
<li>扎好马步：线程的状态</li>
<li>内功心法：每个对象都有的方法（机制）</li>
<li>太祖长拳：基本线程类</li>
<li>九阴真经：高级多线程控制类</li>
</ul>
<p>线程的状态</p>
<p><img src="https://user-images.githubusercontent.com/24977343/65651829-3b5e2600-e042-11e9-9cd3-b3c98492a75b.png" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/24977343/65651887-634d8980-e042-11e9-94d0-7170924c22e0.png" alt=""></p>
<ul>
<li>Runnable :可运行</li>
<li>Running：运行中</li>
<li>Blocked ： 阻塞</li>
<li>Dead ： 结束</li>
</ul>
<p>实现多线程的三种方式：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runable接口</li>
<li>实现Callable接口</li>
</ul>
<h3 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h3><h4 id="进程、线程与任务"><a href="#进程、线程与任务" class="headerlink" title="进程、线程与任务"></a>进程、线程与任务</h4><ul>
<li><p>进程是程序向操作系统申请资源(如内存空间和文件句柄)的基本单位，是程序运行的实例。线程(Thread)是进程中可独立执行的最小单位。运行一个Java程序的实质是启动一个Java虚拟机进程，也就是说一个运行的Java程序的实质是启动一个Java虚拟机进程。</p>
</li>
<li><p>可以运行一个以上线程的程序称为多线程程序(multithreaded)</p>
</li>
<li><p>多进程和多线程的本质区别：每个进程拥有自己的一整套变量，而线程则共享数据。有风险，但是线程通信比进程更有效、容易、更轻量级；创建、撤销一个线程比启动新进程的开销要小得多。</p>
</li>
<li><p>进程和程序：好比播放中的电影和相应的视频文件；前者从动态的角度刻画事物而后者从静态的角度刻画事物。运行一个Java程序的实质就是启动了一个Java虚拟机进程，也就是一个运行的Java程序就是一个Java虚拟机进程。</p>
</li>
<li><p>一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。进程与线程之间的关系，好比一个营业中的饭店与其正在工作的员工之间的关系。</p>
</li>
<li><p>线程所要完成的计算就被称为任务，特定的线程总是在执行着特定的任务。这些任务也正是相应线程存在的理由。</p>
</li>
</ul>
<h4 id="多线程编程简介"><a href="#多线程编程简介" class="headerlink" title="多线程编程简介"></a>多线程编程简介</h4><h5 id="什么是多线程编程"><a href="#什么是多线程编程" class="headerlink" title="什么是多线程编程"></a>什么是多线程编程</h5><p>​        函数式编程(Functional Programming)中的函数是基本抽象单位，面向对象编程中的类(Class)是基本抽象单位。类似地，多线程编程就是以线程为基本抽象单位的一种编程范式(Paradigm)。多线程编程自身又有需要解决的问题。Java平台中一个线程就是一个对象。</p>
<h5 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h5><ul>
<li>提高CPU使用效率</li>
<li>防止阻塞</li>
<li>任务分解</li>
</ul>
<h4 id="JAVA线程API简介"><a href="#JAVA线程API简介" class="headerlink" title="JAVA线程API简介"></a>JAVA线程API简介</h4><p>​    Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。</p>
<h5 id="线程的创建、启动与运行"><a href="#线程的创建、启动与运行" class="headerlink" title="线程的创建、启动与运行"></a>线程的创建、启动与运行</h5><p>​        在Java平台中创建一个线程就是创建一个Thread类(或其子类)的实例。</p>
<p>​        每个线程都有其要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或者通过该方法进行调用，因此run方法相当于线程任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。</p>
<p>​        运行一个线程实际上就是让<code>Java虚拟机</code>执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为此，我们首先要启动线程。Thread类的start方法的作用是启动相应的线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时运行是由线程调度器(Scheduler)决定的。因此，start方法调用结束并不意味着相应线程已经开始运行，这个线程可能稍后才被运行，甚至可能永远不会被运行。</p>
<p>​        Thread类的两个常用构造器是：Thread()和Thread(Runnable target)。相应地，Java语言中创建线程有两种方式。</p>
<ol>
<li>定义Thread类的子类，在该类中覆盖run方法并在该方法中实现线程任务处理逻辑；</li>
<li>创建一个java.lang.Runnable接口的实力，并在该实例的run方法中实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建(new)一个Thread类的实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"2.Welcome I'm %s.%n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread welcomeThread = <span class="keyword">new</span> WelcomeThread();</span><br><span class="line">        welcomeThread.start();</span><br><span class="line">        System.out.printf(<span class="string">"1.Welcome I'm %s.%n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"2.Welcome I'm %s.%n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      	<span class="comment">//创建线程，直接new一个实例作为构造参数</span></span><br><span class="line">        Thread welcomeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WelcomeThread());</span><br><span class="line">        welcomeThread.start();</span><br><span class="line">        System.out.printf(<span class="string">"1.Welcome I'm %s.%n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h5><p><strong>线程两种创建方式的区别</strong></p>
<p>​        从面相编程的角度看：第一种创建方式(创建Thread类的子类)是一种基于继承(Inheritance)的技术，第2种创建方式(以Runnable接口实例为构造器参数直接通过new创建Thread实例)是一种基于组合(Composition)的技术。由于组合技术相对继承来说，其类和类之间的耦合性(Coupline)更低，因此它也更加灵活。一般我们认为组合是优先选用的技术。</p>
<p>​        从对象共享的角度来看；第2种创建方式意味着多个线程实例可以共享同一个Runnable实例。在某下情况下这可能导致程序的运行结果出乎我们的意料。</p>
<p>​        从对象创建成本的角度看：Java中的线程实例是一个[特殊]的Runnable实例，因为在创建它的时候Java虚拟机会为其分配调用栈空间、内核线程等资源。因此，创建一个线程实例比起创建一个普通的Runnable实例来说，其成本要相对高昂一点。所以，如果创建Runnable实例再将其作为方法参数传递给其他对象使用(JDK标准库中有不少API都使用了Runnable接口)而不必利用它来创建相应的线程(即第2种线程创建方式)即可满足我们的计算需要，那么就不要创建线程实例。</p>
<h5 id="1-3-3线程属性"><a href="#1-3-3线程属性" class="headerlink" title="1.3.3线程属性"></a>1.3.3线程属性</h5><p>​        线程的属性包括线程的编号(ID)、名称(Name)、线程类别(Daemon)和优先级(Priority)。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">属性类型及用途</th>
<th style="text-align:center">只读属性</th>
<th style="text-align:left">重要注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编号(ID)</td>
<td style="text-align:center">类型:long 。用于标识不同的线程。不同的线程拥有不同的编号。</td>
<td style="text-align:center">是</td>
<td style="text-align:left">某个编号的线程运行结束后，该编号可能会被后续创建的线程使用。</td>
</tr>
<tr>
<td style="text-align:center">名称(Name)</td>
<td style="text-align:center">类型：String。面向人(而非机器)的一个属性，用于区分不同的线程。默认值：Thread-线程编号</td>
<td style="text-align:center">否</td>
<td style="text-align:left">Java并不禁止我们将不同的线程名称属性设置为相同的值。</td>
</tr>
<tr>
<td style="text-align:center">线程类型(Daemon)</td>
<td style="text-align:center">类型:boolean 。true：守护线程。false:用户线程。默认值与相应线程的父线程的该属性的值相同</td>
<td style="text-align:center">否</td>
<td style="text-align:left">该属性必须在线程启动前设置，即start方法调用前。否则IllegalThradStateException。负责一些关键任务处理的线程不适宜设置为守护线程。</td>
</tr>
<tr>
<td style="text-align:center">优先级（Priority）</td>
<td style="text-align:center">类型:int。该属性本质是给线程调度器的提示，用于表示应用程序系统那个线程能够优先得以运行。Java定义了1-10.默认为5(普通)。具体线程的优先级默认与父线程的相同</td>
<td style="text-align:center">否</td>
<td style="text-align:left">一般使用默认优先级即可。不恰当地设置该属性值可能导致严重的问题(线程饥饿)</td>
</tr>
</tbody>
</table>
<p>​        通过名称属性，我们可以为每个线程设置一个便于区分不同线程的名称。虽然Java虚拟机并不要求每个线程的名称都不同，但是设置该属性有助于程序调试和问题定位。因此，我们建议为每个线程都设置一个简短而又能够体现其作用或其实现的功能的名称。</p>
<p>​        线程的属性除了编号外，其他属性都是可读写的属性，即Thread类提供了相应的get方法和set方法用于读取或者设置相应的属性。</p>
<p>​        Java线程的优先级属性本质上只是一个给线程调度器的提示信息，以便于线程调度器决定优先调度哪些线程运行。它并不能保证线程按照其优先级高低的顺序运行。一般情况默认即可。    </p>
<p>​        按照线程是否会阻止Java虚拟机正常停止，我们可以将Java中的线程分为守护线程(Deemon Thread)和用户线程(User Thread,也称非守护线程)。用户线程会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束(即Thread.run()调用未结束)的情况下才能正常停止。而守护线程则不会影响Java虚拟机的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务。例如用于监视其他线程的运行情况。</p>
<p>​        如果kill 命令强制终止一个Java虚拟机进程，那么即使是用户线程也无法阻止Java虚拟机的停止。</p>
<h5 id="1-3-4Thread类的常用方法"><a href="#1-3-4Thread类的常用方法" class="headerlink" title="1.3.4Thread类的常用方法"></a>1.3.4Thread类的常用方法</h5><p>​        </p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static Thread currentThread()</td>
<td style="text-align:center">返回当前线程，即当前代码的执行线程(对象)</td>
<td style="text-align:left">同一段代码对Thread.currentThread()对调用，其返回值可能对应着不同的线程(对象)</td>
</tr>
<tr>
<td style="text-align:center">void run()</td>
<td style="text-align:center">用于实现线程的任务处理逻辑</td>
<td style="text-align:left">该方法是由Java虚拟机直接调用的，一般情况下应用程序不应该调用该方法</td>
</tr>
<tr>
<td style="text-align:center">void start()</td>
<td style="text-align:center">启动相应线程</td>
<td style="text-align:left">该方法的返回并不代表相应线程已经被启动。一个Thread实例的start方法只能够被调用一次，否则会抛出异常</td>
</tr>
<tr>
<td style="text-align:center">void join()</td>
<td style="text-align:center">等待相应线程运行结束</td>
<td style="text-align:left">若线程A调用线程B的join方法，那么线程A的运行会被暂停，直到线程B运行结束</td>
</tr>
<tr>
<td style="text-align:center">static void yield()</td>
<td style="text-align:center">使用当前线程主动放弃其对处理器的占用，这可能导致当前线程被暂停</td>
<td style="text-align:left">这个方法是不可靠的。该方法被调用时当前线程可能仍然继续运行(视系统的运行情况而定)</td>
</tr>
<tr>
<td style="text-align:center">static void sleep(long millis)</td>
<td style="text-align:center">使当前线程休眠(暂停运行)指定的时间</td>
</tr>
</tbody>
</table>
<p>​            join方法的作用相当于执行该方法的线程和线程调度器说:我得先暂停一下，等到另外一个线程运行结束后我才能干活。</p>
<p>​            yield静态方法：告诉线程调度器：我现在不急，如果别人需要处理器资源的话先给他用吧当然，如果没有其他人要用，我也不介意继续占用。</p>
<p>​            sleep:我想睡一会儿，过段时间再叫醒我干活。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>线程调度器是操作系统的一个部分。</li>
<li>由操作系统内核直接进行管理和调度的线程，它与具体的操作系统平台有关。</li>
</ul>
<h4 id="线程的层次关系"><a href="#线程的层次关系" class="headerlink" title="线程的层次关系"></a>线程的层次关系</h4><p>​        一个线程是否是一个守护线程默认取决于其父线程。</p>
<p>​        Java平台中没有API用于获取一个线程的父线程，或者获取一个线程的所有子线程。并且，父线程和子线程之间的生命周期也没有必然的联系。比如父线程运行结束后，子线程可以继续运行，子线程运行结束也不妨碍其父线程继续运行。</p>
<p>​        </p>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>使用线程给其他任务提供机会</p>
<p>Java标准库类java.lang.Thread就是Java平台对线程的实现。</p>
<h4 id="线程的层次关系-1"><a href="#线程的层次关系-1" class="headerlink" title="线程的层次关系"></a>线程的层次关系</h4><ul>
<li>一个线程是否是一个守护线程默认取决于其父线程；默认父线程是守护线程，则子线程也是守护线程。父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon方法，将相应的线程设置为守护线程(或者用户线程)。</li>
<li>程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。</li>
<li>如果没有设置一个线程的优先级，那么这个线程优先级默认与父线程的优先级值相等。</li>
<li>Java平台中并没有API用于获取一个线程的父线程或者一个线程的所有子线程。</li>
<li>父线程与子线程的生命周期没有必然联系。</li>
</ul>
<h4 id="线程的生命周期状态"><a href="#线程的生命周期状态" class="headerlink" title="线程的生命周期状态"></a>线程的生命周期状态</h4><p>​    一个线程从</p>
<p><img src="https://user-images.githubusercontent.com/24977343/67002732-1b84c400-f10f-11e9-8606-f1dd7c05ad72.png" alt=""></p>
<p>​        Java的线程状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。其返回值类型Thread.State是一个枚举类型(Enum)。Thread.State所定义的线程状态包括：</p>
<p>​            NEW:一个创建而未启动的线程处于该状态。<code>Thread state for a thread which has not yet started.</code></p>
<p>​            RUNNABLE：该状态可以被看成一个复合状态。它包含两个字状态：READY和RUNNING。前者表示处于该状态的线程可以被线程调度器(Scheduler)进行调度而使之处于RUNNING状态。后者表示处于该状态的线程正在运行，即线程对象的run方法所对应的指令正在由处理器执行。执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。处于READY子状态的线程也被称为活跃线程。</p>
<p>​            BLOCKED：一个线程发起一个阻塞式I/O(Blocking I/O)操作后，或者申请一个由其他线程持有的独占资源(比如锁)时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源。当阻塞式I/O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。</p>
<p>​            WAITING：一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。能够使其执行线程变更为WAITING状态的方法包括：Object.wait()、Thread.join()和LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()/notifyAll()和LockSupport.unpark(Object)。</p>
<p>​            TIMED_WAITING:该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。</p>
<p>​            TERMINATED：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。</p>
<p>​            一个线程在其生命周期中，只可能有一次处于NEW状态和TERMINATED状态。</p>
<h5 id="多线程的风险"><a href="#多线程的风险" class="headerlink" title="多线程的风险"></a>多线程的风险</h5><ul>
<li>线程安全问题(Thread Safe)问题。多个线程共享数据的时候，如果没有采取相应的并发访问控制措施，那么就可能产生数据一致性的问题，如读取脏数据(过期的数据)、丢失更新(某些线程所做的更新被其他线程所做的更新覆盖)等。</li>
<li>线程活性(Thread Liveness)问题。死锁、一直等待、无法获取时间片资源。</li>
<li>上下文切换(Context Switch)：处理器从执行一个线程转向执行另外一个线程的时候操作系统所需要做的一个动作被称为上下文切换。增加了系统的消耗。</li>
<li>可靠性：</li>
</ul>
<h3 id="多线程编程的目标与挑战"><a href="#多线程编程的目标与挑战" class="headerlink" title="多线程编程的目标与挑战"></a>多线程编程的目标与挑战</h3><h4 id="串行、并发与并行"><a href="#串行、并发与并行" class="headerlink" title="串行、并发与并行"></a>串行、并发与并行</h4><p>三个任务：</p>
<ul>
<li>A：实际执行5分钟，等待完成10分钟</li>
<li>B：实际执行2分钟，等待完成8分钟</li>
<li>C：实际执行10分钟，无等待时间</li>
</ul>
<p>串行：一个任务接一个任务的来完成(一个人完成)。15+10+10=35分钟。一个处理器就可以完成</p>
<p>并发：在任务的等待时间来执行其他任务(一个人完成)；5+2+10=17分钟。一个处理器就可以完成</p>
<p>并行：同时执行三个任务(三个人完成)；15分钟(以耗时时间最长的任务为准)。需要多个处理器</p>
<p>​    多线程编程的实质就是将任务的处理方式由串行改为并发，称为可并发化。但是有的任务处理方式必须是串行的，例如Java中的读取文件就是串行。</p>
<h4 id="竟态"><a href="#竟态" class="headerlink" title="竟态"></a>竟态</h4><p>​        多线程编程中经常遇到的问题就是同样的输入，程序的输出有时候是正确的而有时候确是 错误的。这种一个计算结果的正确性与时间有关的现象称为<code>竟态</code>(Race Condition);</p>
<p>​        <code>synchronized</code>关键字会使其修饰的方法在任一时刻只能够被一个线程执行，这使得该方法涉及的共享变量在任一时刻只能够有一个线程访问(读、写)，从而避免了这个方法的交错执行而导致的干扰，这样就消除了竟态。</p>
<h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>​        如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是线程安全(Thread-safe)的，相应地问们称这个类具有线程安全性(Thread Safety)。反之，如果一个类在单线程环境下运作正常而在多线程环境下则无法正常运作，那么这个类就是非线程安全的。因此，如果一个类如果能够导致竟态，那么它就是非线程安全的；而一个类如果是线程安全的，那么它就不会导致竟态。        </p>
<p>​        使用一个类的时候我们必须先弄清楚这个类是否是线程安全的。因为这关系到我们如何正确使用这些类。这好比微波炉加热食物前我们必须先弄清所用的容器是否适宜进行微波加热。Java标准库种的一些类如ArrayList、HashMap和SimpleDateFormat，都是非线程安全的，在多线程环境下直接使用它们可能导致一些非预期的结果，甚至是一些灾难性的结果。</p>
<p>​        把一个类做成线程安全的往往是有额外代价的。</p>
<p>​        一个类如果不是线程安全的，我们就说它在多线程环境下直接使用存在线程安全问题。线程安全问题概括来说表现为3个方面:原子性、可见性和有序性。</p>
<p>​        Java标准库中的一些类都是非线程安全的。如：ArrayList、HashMap和SimpleDateFormat。</p>
<p>​        把一个类做成线程安全的往往是需要额外的代价的。</p>
<p>​        </p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>​        </p>
<p>​        </p>
<ul>
<li>不可分割</li>
</ul>
<p>​        原子(Atomic)的字面意思是不可分割的(Indivisible)。    对于涉及共享变量访问的操作，若操作从执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有原子性。</p>
<p>​        所谓<code>不可分割</code>，其中一个含义是指访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会<code>看到</code>该操作执行了部分中间效果。</p>
<p>​        访问同一组共享变量(一个方法中的)的原子操作是不能够<strong>被交错的</strong>，这就排除了一个线程执行一个操作期间另外一个线程读取或者更新该操作所访问的共享变量而导致的干扰(读脏数据)和冲突(丢失更新)的可能性。</p>
<p>​        例子:        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHostInfo</span><span class="params">(String ip,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">      <span class="comment">//以下操作不是原子操作</span></span><br><span class="line">    hostInfo.setIp(ip);<span class="comment">//语句1</span></span><br><span class="line">    hostInfo.setPort(port);<span class="comment">//语句2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​     A线程执行了语句1,还未执行语句2，B线程读取了hostInfo。</p>
<ul>
<li>原子操作是针对共享变量的操作而言的。也就是说，仅涉及局部变量访问的操作无所谓是否是原子的，或者干脆把这一类操作都看出原子操作。</li>
<li>原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多线程环境下有意义。单线程无所谓是否具有原子性。</li>
</ul>
<p><strong>提示</strong></p>
<p>​        原子操作是多线程环境下的一个概念，它是针对<code>访问共享变量的操作</code>而言的。原子操作不可分割包含以下两层含义。</p>
<ul>
<li><p>访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会 <strong>看到</strong>该操作执行了部分的中间效果。</p>
</li>
<li><p>访问同一组共享变量的原子操作是不能够被交错的。</p>
<p>​    总的来说，Java中有两种方式来实现原子性。一种是使用锁(Lock)。锁具有排他性，即它能保证一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的CAS(Compare-and-Swap)指令，CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别是一个是软件层实现一个是硬件层(处理器和内存)，它可以被看作是硬件锁。</p>
<p>​        在Java语言中，long/double除外，仅包含byte、boolean、short、char、float、和int的变量和引用型变量的写操作都是原子的。这点由Java语言规范规定，由Java虚拟机具体实现。</p>
<p>​        long/double型变量会占用64位(8字节)的存储空间，而32位的java虚拟机对这种变量的写操作可能会被分解为两个步骤来实施，比如先写低32位再写高32位。那么多个线程试图共享一个这样的变量就可能出现一个线程在写高32位的时候，另外一个线程正在写低32位的情形。</p>
<p>​        volatile关键仅能够保障变量写操作的原子性，它并不能保障其他操作(比如 read-modify-write操作和check-then-act操作)的原子性。</p>
</li>
</ul>
<p>原子操作+原子操作 !=原子操作</p>
<p>例如：</p>
<p>​        共享型变量 int a、b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="comment">//语句1</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<p>​    线程A执行完语句1之后再执行语句2之前的这一刻，另外一个线程B可以读取变量a和变量b的值。那么B读到的变量a和b的值分别为1和0，也就是说它读到了A所执行操作的中间结果，这有悖于原子操作不可分割的特性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>​        在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新到结果，甚至永远也无法读取到这个更新的结果。这就是线程安全问题的另外一个表现形式:可见性(Visibility)。</p>
<ul>
<li>可见性：一个线程更新了变量，其他线程是否能读取到更新后的值。</li>
</ul>
<p>​        如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么我们就称这个线程对共享变量的更新对其他线程可见，否则我们就称这个线程对该共享变量的更新对其他线程不可见。可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。多线程在可见性方面存在的问题意味着某些线程读取到了旧数据(Stale Data)，而这可能导致程序出现我们所不期望的结果。</p>
<p>​        另一方面，可见性问题与计算机的存储系统有关。程序中的变量可能会被分配到寄存器(Register)而不是主内存中进行存储。每个处理器都有其寄存器，而一个处理器无法读取另外一个处理器上的寄存器的内容。因此，如果两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就有可能产生(一个共享变量在两个处理器的寄存器上)。另外，即便某个共享变量被分配到主内存中进行存储到的，也不能保证该变量的可见性。这是因为处理器对主内存的访问并不是直接访问，而是通过其高速缓存(Cache)子系统进行的。一个处理器线程上运行的线程对变量的更新可能只是更新到该处理器的写缓冲器(Store Buffer)中，还没有到达该处理器的高速缓存中，更不用说主内存中了。而一个处理器的写缓冲器中的内容无法被另外一个处理器读取，因此运行在另外一个处理器上的线程无法看到这个线程对某个共享变量的更新。即便一个处理器上运行的线程对共享变量的更新结果被写入该处理器的高速缓存，由于该处理器将这个变量更新的结果通知给其他处理器的时候，其他处理器可能仅仅将这个更新通知的内容存入无效化队列(Invalidate Queue)中，而没有直接根据更新通知的内容更新其高速缓存的相应内容，这就导致了其他处理器上运行的其他线程后续再读取相应共享变量时，从相应处理器的高速缓存中读取到的变量值时一个过时的值。</p>
<p>​        <img src="https://user-images.githubusercontent.com/24977343/70794482-a8c75a80-1dd8-11ea-9589-8467d61db37b.png" alt=""></p>
<p>​        CPU-&gt;寄存器-&gt;写缓冲器-&gt;高速缓存-&gt;(可能是无效化队列：没有直接更新通知的内容到高速缓存的相应内容)-&gt;主内存</p>
<p>​        处理器并不是直接与主内存(RAM)打交道而执行内存的读、写操作，而是通过寄存器(Register)、高速缓存(Cache)、写缓冲器(Store Buffer，也称Write Buffer)和无效化队列(Invalidate Queue)等部件执行内存的读、写操作的。从这个角度看，这些部件相当于主内存的副本。        </p>
<p>​        虽然一个处理器的高速缓存中的内容不能被另外一个处理器直接读取，但是一个处理器可以通过<strong>缓存一致性协议</strong>(Cache Coherence Protocol)来读取其他处理器的高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中。</p>
<p>​        缓存同步：一个处理器从其自身处理器缓存以外的其他存储部件中读取数据并将其反映(更新)到该处理器的高速缓存的过程。相应地，我们称这些存储部件的内容上可同步的，这些存储部件包括处理器的高速缓存、主内存。缓存同步使得一个处理器(上运行的线程)可以读取到另外一个处理器(上运行的线程)对共享变量所做的更新，即保障了可见性。因此，为了保障可见性，我们必须使一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存或者主内存中(而不是始终停留在其写缓冲器中)，这个过程被称为<strong>冲刷处理器缓存</strong>。并且，一个处理器在读取共享变量的时候，如果其他处理器在此之前已经更新了该变量，那么该处理器必须从其他处理器的高速缓存或者主内存中对相应的变量进行缓存同步。这个过程被称为<strong>刷新处理器缓存</strong>。因此，可见性的保障上通过使更新共享变量的处理器执行冲刷缓存的动作，并使读取共享变量的处理器执行刷处理器缓存的动作来实现的。</p>
<ul>
<li>冲刷处理器缓存：    对共享变量有做的更新的处理器，将变量最终写入该处理器的高速缓存或者主内存中。(其他处理器)</li>
<li>刷新处理器缓存：    对其他处理器的高速缓存或者主内存中相应的变量进行缓存同步。(当前处理器)</li>
<li>缓存同步：  一个处理器从自身处理器缓存以外的其他存储部件中读取数据并更新到该处理器的高速缓存中的过程。(当前处理器)</li>
</ul>
<p>​        那么在Java平台中如何保证可见性呢？其中一个是在变量前增加 volatile关键字即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> toCancel = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>​        这里volatile关键字所起的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另外一个作用就是读取一个volatile关键字修饰的变量会<strong>使相应的处理器执行刷新处理器缓存</strong>的动作，写一个volatile关键字修饰的变量会使相应的处理器执行<strong>冲刷处理器缓存</strong>的动作，从而保障了可见性。</p>
<ul>
<li>volatile ： 即会让相应的处理器执行<strong>冲刷处理器缓存</strong>也会让读取的处理器<strong>刷新处理器缓存</strong>。从而保障了可见性。</li>
<li>可见性得以保障并不意味着一个线程能够看到另外一个线程更新的所有变量的值。</li>
</ul>
<p>如果一个线程在某个时刻更新了多个共享变量的值，那么此后其他线程再来读取这个变量时，这些线程读到的变量的值有些可能是新值，有些可能是旧值。</p>
<p>​        不过随着处理器的越来越强，在可见性方面做的足够强大，所以可见性问题往往不是必然出现的。</p>
<p>​        <strong>约定</strong></p>
<p>​        对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量相对新值。如果读取这个共享变量的线程在读取并使用该变量的时候其他线程无法更新该变量的值，那么该线程读取到的相对新值就被称为该变量的最新值。</p>
<ul>
<li>相对新值：一个线程更新了该变量的值后，其他线程能够读取到这个更新后的值。</li>
<li>最新值：线程读取并使用该变量的时候其他线程无法更新该变量的值。</li>
</ul>
<p>​        <strong>单处理器系统是否存在可见性问题</strong></p>
<p>​        单处理器系统中实现的多线程也可能出现可见性问题。因为多线程的并发实际上是通过时间片(Time Slice)分配实现的。此时，虽然多个线程数运行在同一个处理器上的，但是由于发生上下文切换(Context Switch)的时候，一个线程对寄存器(Register)变量的修改会被作为该线程的上下文保存起来，这导致了另一个线程无法<code>看到</code>该线程对这个变量的修改。</p>
<p>​        <strong>可见性与原子性的联系与区别</strong></p>
<p>​        原子性描述的是一个线程对共享变量的更新，从另外一个线程的角度来看，它要么完成了，要么尚未发生，而不是进行中的一种状态。原子性可以保证一个线程所读取到的共享变量的值要么是该变量的初始值要么是该变量的相对新值，而不是更新过程中的一个相当于<code>半成品</code>的值。</p>
<p>​        <img src="https://user-images.githubusercontent.com/24977343/71229038-23373380-231f-11ea-99a0-46d2aeec3ea3.png" alt=""></p>
<p>入上图，由于执行顺序是无法保障的。所以Processor 0、Processor 1、Processor 2这3个线程按照表所示的线程交错顺序执行。</p>
<p>​        原子性可以保证在t3时刻Processor 2上的线程读取到的共享变量a的值要么为0，要么为1或者2，但是它并不能保证该值会是1或者2.因此t3时刻Processor 2上的线程读取到的a值可能是0、1、2，也可能是其他的看起来在代码中从来不存在的一个值！</p>
<p>​        可见性描述的是一个线程对共享变量的更新对另外一个线程而言是否可见(或者说什么情况下可见)的问题。保障可见性意味着一个线程可以读取到相应共享变量的相对新值。例如，上述例子中保障可见性可以保证t3时刻Processor2上的线程读取到的共享变量a的值为2(相对新值，这里恰好也是最新值)。</p>
<p>​        因此，从保障线程安全的角度来看，光保障原子性可能是不够的，有时候还要同时保障可见性。可见性和原子性同时得以保障才能够确保一个线程能够[正确]地看到(即看到的不是<code>半成品</code>)其他线程对共享变量所做的更新。</p>
<p>​    <strong>Java语言规范保证，父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的</strong></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>​        有序性(Ordering)指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另外一个处理器上运行的其他线程看来是乱序的(Outer of order)。所谓乱序，是指内存访问操作的顺序看起来像是发生了变化。先了解重排序的概念。在这里假定每个线程都是运行在各自的处理器上，不考虑一个处理器基于时间片(Time Slice)分时而实现的多线程。</p>
<p>​        </p>
<h5 id="重排序概念"><a href="#重排序概念" class="headerlink" title="重排序概念"></a>重排序概念</h5><p>​        顺序结构是结构化编程中的一种基本结构，它表示我们希望某个操作必须先与另一个操作得以执行。另外，两个操作即便是可以用任意一种顺序执行，但是反映在代码上这两个操作也总是先后关系。但是在多核处理器的环境下，这种操作执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序；处理器可能不是完全依照程序的目标代码所指定的顺序执行指令；另外，一个处理器上执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。这种现象叫作重排序(Reordering)。</p>
<p>​        重排序上对内存访问有关对操作(读和写)所做的一种优化，它可以在不影响但线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它可能导致线程安全问题。与可见性问题类似，重排序也不是必然出现的。</p>
<p>​        重排序的潜在来源有许多，包括编译器(在Java平台中这基本上指JIT编译器)、处理器和存储子系统(包括写缓冲器Store Buffer、高速缓存Cache)。</p>
<p>​                与内存操作顺序有关的术语。</p>
<ul>
<li><p>源代码顺序(Source Code)：源代码中所指定的内存访问操作顺序。</p>
</li>
<li><p>程序顺序(Program Order)：在给定处理器上运行的目标代码(Object Code)所指定的内存访问操作顺序。</p>
</li>
<li><p>执行顺序(Execution Order)：内存访问操作在给定处理器上实际执行顺序。</p>
</li>
<li><p>感知顺序(Perceived Order)：给定处理器所感知到(看到)都该处理器及其他处理器的内存访问操作发生的顺序。</p>
<p>​    </p>
<p>在此基础上，我们将重排序划分为指令重排序和存储子系统重排序两种。</p>
<p><img src="https://user-images.githubusercontent.com/24977343/71351800-9656d900-25af-11ea-82a8-99b65083d694.png" alt="image"></p>
<h5 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h5><p>​        在源代码顺序与程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序(Instruction Reorder)。指令重排序说一种动作，它确确实实地对指令的顺序做了调整，其重排序的对象是指令。</p>
<p><strong>提示</strong></p>
<p>​        Java平台包含两种编译器：静态编译器(javac)和动态编译器(JIT编译器)。前者的作用是将Java源代码(.java文本文件)编译为字节码(.class二进制文件)，它是在代码编译阶段介入的。后者的作用是将字节码动态编译为Java虚拟机宿主机的本地代码(机器码)，它是在Java程序运行过程中介入的。后者的作用是将字节码动态编译为Java虚拟机宿主机的本地代码(机器码),它是在Java程序运行过程中介入的。</p>
<p>​        在其他编译型语言(如C++)中，编译器是可能导致指令重排序的：编译器出于性能的考虑，在其认为不影响程序(单线程车给你打序)正确性的情况下可能会对源代码顺序进行调整，从而造成程序顺序与相应的源代码顺序不一致。在Java平台中，静态编译器(javac)基本上不会执行指令重排序，而JIT编译器可能执行指令重排序。</p>
</li>
</ul>
<p>  <strong>静态编译器基本上不会执行指令重排序吗，而JIT编译器则可能执行指令重排序</strong></p>
<ul>
<li>重排序可能导致线程安全问题。这并不表示重排序本身是错误的，而是说我们的程序本身有问题：我们的程序没有使用或者没有正确的使用线程同步机制。</li>
<li>重排序不是必然出现的：200000次才出现7次。</li>
</ul>
<p>  ​        处理器也可能执行指令重排序，这使得执行顺序不一致。处理器对指令进行重排序也被称为处理器乱序执行(Out-of-order Execution)。现代处理器为了提高指令执行效率，往往不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到那条指令就绪就先执行那条指令，这就是处理器的乱序执行。在乱序执行的处理器中，指令是一条一条按照程序顺序被处理器读取的(亦即’顺序读取’)，然后这些指令中哪条就绪了哪条就会先被执行，而不是完全按照程序顺序执行(亦即<code>乱序执行</code>)。这些指令执行的结果(要进行写寄存器或者写内存的操作)会被先存入重排序缓冲器(ROB,Reordr Buffer)，而不是直接写入寄存器或者主内存。重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交(Commit，即写入)到寄存器或者内存中去(亦即<code>顺序提交</code>)。在乱序执行的情况下，尽管指令的执行顺序可能没有完全按照程序顺序，但是由于指令的执行结果的提交(即反映到寄存器和内存中)仍然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响。</p>
<h5 id="存储子系统重排序"><a href="#存储子系统重排序" class="headerlink" title="存储子系统重排序"></a>存储子系统重排序</h5><p>  ​        主内存(RAM)相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存(Cache)访问主内存的。在此基础上，现代处理器还引入了写缓冲器(Store Buffer，也称Write Buffer)以提高写高速缓存操作(以实现写主内存)的效率。有的处理器(如Intel 的x86处理器)对所有的写主内存的操作都是通过写缓冲器进行的。这里，我们将写缓冲器和高速缓存统称为存储子系统，它其实是处理器的子系统。</p>
<p>  ​        即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化。这种现象就是存储子系统重排序，也被称为内存重排序(Memory Ordering)。</p>
<p>  ​        指令重排序的重排序对象是指令，它实实在在地对指令的顺序进行调整，而存储子系统重排序是一种现象而不是一种动作，它并没有真正对指令执行顺序进行调整，而只是造成了一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是内存操作的结果。习惯上为了便于讨论，即我们也会用[内存操作X被重排序到内存操作Y之后]这样的表述称呼内存重排序。</p>
<p>  ​        从处理器的角度来说，读内存操作的实质是从指定的RAM地址加载数据(通过高速缓存加载)到寄存器，因此读内存操作通常被称为Load，写内存操作的实质是将数据(可能作为操作数直接存储在指令中，也可能存储在寄存器中)存储到指定地址表示的RAM存储单元中，因此写内存操作通常被称为Store。所以，内存重排序实际上只有以下4种可能，如表2-4所示。</p>
<p>  ​    <img src="https://user-images.githubusercontent.com/24977343/71402566-31ab8500-2668-11ea-9020-41f0d3e2850a.png" alt="image"></p>
<p>  <img src="https://user-images.githubusercontent.com/24977343/71402586-412ace00-2668-11ea-9848-613a8bbfeaf2.png" alt="image"></p>
<h5 id="貌似串行语义"><a href="#貌似串行语义" class="headerlink" title="貌似串行语义"></a>貌似串行语义</h5><p>​        重排序并非随意地对指令、内存操作的结果进行杂乱无章的排序或者顺序调整，而是遵循一定的规则。编译器(主要是JIT编译器)、处理器(包括其存储子系统)都会遵守这些规则，从而给单线程程序创造一种假象—指令是按照源代码顺序执行的。这种假象就被称为貌似串行语义。貌似串行语义只是从单线程程序的角度保证重排序后的运行结果不影响程序的正确性，它并不保证多线程环境下程序的正确性。</p>
<h5 id="保证内存访问的顺序性"><a href="#保证内存访问的顺序性" class="headerlink" title="保证内存访问的顺序性"></a>保证内存访问的顺序性</h5><p>​        我们知道硬件和软件的因素都可能导致程序的感知顺序与源代码顺序不一致，而这种不一致可能导致线程安全问题。那么，如何避免重排序导致的线程安全问题呢？这个问题实质上就是如何保证感知顺序与源代码顺序一致，即有序性。</p>
<p>​        貌似串行语义只是保障重排序不影响单线程程序的正确性。从这个角度出发，有序性的保障可以理解为通过某些措施使得貌似串行语义扩展到多线程程序，即重排序要么不发生，要么即使发生了也不会影响多线程程序的正确性。因此，有序性的保障也可以理解为从逻辑上部分禁止重排序。当然，这并不意义着从物理上禁止重排序而使得处理器完全依照源代码顺序执行指令，因为那样性能太低！</p>
<ul>
<li><p>禁止重排序：指逻辑上的部分禁止重排序</p>
<p>从底层的角度来说，<strong>禁止重排序是通过调用处理器提供相应的指令(内存屏障)来实现的</strong>。当然，Java作为一个跨平台的语言，它会替我们与这类指令打交道，而我们只需要使用语言本身提供的机制即可。前面为们介绍的volatile关键字、synchronized关键字都能够实现有序性。</p>
</li>
</ul>
<p><strong>可见性与有序性的联系与区别</strong></p>
<p>​        可见性说有序性的基础。可见性描述的是一个线程对共享变量的更新对于另外一个线程是否可见，或者说什么情况下可见的问题。有序性描述的是，一个处理器上运行的线程对共享变量所做的更新，在其他处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。因此，可见性是有序性的基础。另一方面，二者又是相互区分的。</p>
<p>​        有序性影响可见性。由于重排序的作用，一个线程对共享变量的更新对与另外一个线程而言可能变得不可见。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>​        上下文切换(Context Switch)在某种程度上可以被看作多个线程共享同一个处理器的产物，它是多线程编程中的一个重要概念。</p>
<h5 id="上下文切换及其产生原因"><a href="#上下文切换及其产生原因" class="headerlink" title="上下文切换及其产生原因"></a>上下文切换及其产生原因</h5><p>​        一个线程被暂停，即被剥夺处理器的使用权，另外一个线程被选中开始或者继续运行的过程就叫做线程上下文切换。</p>
<p>​        一个线程被剥夺处理器的使用权而被暂停运行就被称为切出(Switch Out)；一个线程被操作系统选中占用处理器开始或者继续其运行就被称为切入(Switch In)。</p>
<p>​        我们看着是连续运行的线程，实际上上以断断续续运行的方式使其任务进展的。这种方式意味着在切出和切入的时候操作系统需要保存和恢复相应线程的进度信息，即切入和切出那一刻相应线程所执行的任务进行到什么程度了(如计算的中间结果以及执行到了哪条指令)。这个进度信息就被称为上下文(Context)。<strong>它一般包括通用寄存器(General Purpose Register)的内容和程序计数器(Program Counter)的内容</strong>。在切出时，操作系统需要<strong>将上下文保存到内存中</strong>，以便被切出的线程稍后占用处理器继续其运行时能够在此基础上进展。在切入时，<strong>操作系统需要从内存中加载(恢复)被选中线程的上下文</strong>，以在之前运行的基础上继续进展。</p>
<p>​        当一个线程的生命周期状态由RUNNABLE转换为非RUNNABLE时，我们称这个线程被暂停。线程的暂停就时相应线程被切出的过程，这里操作系统会保存相应线程的上下文，以便该线程稍后再次进入RUNNABLE状态时能够在之前执行进度的基础上扩展。当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文，以便其在此基础上进展。</p>
<h5 id="上下文切换的分类及具体诱因"><a href="#上下文切换的分类及具体诱因" class="headerlink" title="上下文切换的分类及具体诱因"></a>上下文切换的分类及具体诱因</h5><p>​        按照导致上下文切换的因素划分，我们可以将上下文切换分为自发性上下文切换(Voluntary Context Switch)和非自发性上下文切换(Involuntary Context Switch)。</p>
<p>​        自发性上下文切换指线程由于其自身因素导致的切出。从Java平台的角度来看，一个线程在其运行过程中执行下列任意一个方法都会引起自发性上下文切换。</p>
<ul>
<li><p>Thread.sleep(long milllis)</p>
</li>
<li><p>Object.wait()/wait(long timeout)/wait(long timeout, int nanos)</p>
</li>
<li><p>Thread.yield()</p>
</li>
<li><p>Thread.join()/Thread.join(long timeout)</p>
</li>
<li><p>LockSupport.park()</p>
<p>​    另外，线程发起了I/O操作(如读取文件)或者等待其他线程持有的锁也会导致自发性上下文切换。</p>
<p>​    非自发性上下文切换指线程由于线程调度器的原因被迫切出。导致非自发性上下文切换的常见因素包括被切出线程的时间片用完或者有一个比被切出线程优先级更高的线程需要被运行。从Java平台的角度来看，Java虚拟机的垃圾回收(Garbage Collect)动作也可能导致非自发性上下文切换。这是因为垃圾回收器在执行垃圾回收的过程中可能需要暂停所有应用线程(Stop-the-world)才能完成其工作，比如在主要回收(Major Collection)过程中，垃圾回收器在对Java虚拟机堆内存区域进行整理(Compact)的时候需要先停止所有应用线程。</p>
<h5 id="上下文切换的开销和测量"><a href="#上下文切换的开销和测量" class="headerlink" title="上下文切换的开销和测量"></a>上下文切换的开销和测量</h5><p>​        上下文切换的开销包括直接开销和间接开销。</p>
<ol>
<li>直接开销<ul>
<li>操作系统保存和恢复上下文所需的开销，这里主要是处理器时间开销</li>
<li>线程调度器进行线程调度的开销(比如，按照一定的规则决定哪个线程会占用处理器运行)</li>
</ul>
</li>
<li>间接开销<ul>
<li>处理器高速缓存重新加载的开销。一个被切出的线程可能稍后在另外一个处理器上</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​        </p>
<p>上下文切换就是看那个线程获取到了时间片。上一个线程的一些信息保存到内存</p>
<p>​    </p>
<h3 id="Java线程同步机制"><a href="#Java线程同步机制" class="headerlink" title="Java线程同步机制"></a>Java线程同步机制</h3><p>Java线程同步机制是Java多线程编程的基础与核心内容。</p>
<h4 id="线程同步机制简介"><a href="#线程同步机制简介" class="headerlink" title="线程同步机制简介"></a>线程同步机制简介</h4><p>​        导致线程安全问题的因素更多的是侧重其根源，包括硬件(如写缓冲器)和软件(编译器)。但是从应用程序的角度来看，线程安全问题的产生是由于多线程应用程序缺乏某种东西—-线程同步机制。</p>
<p>​        线程同步机制是一套用于协调线程间的数据访问(Data acess)及活动(Activity)的机制，该机制用于保障线程安全以及实现这些线程的共同目标。如果把线程必做公路上行驶的汽车，那么线程同步机制就好比是任何车辆都需要遵循的交通规则。遵守才能够安全地到达目的地。</p>
<p>​        从广义上讲，Java平台提供的线程同步机制包括锁、volatile关键字、final关键字、static关键字以及一些相关API，如Object.wait()/Object.notify()等。本章介绍的是Java平台中用于协调线程间共享数据访问的相关关键字和API。</p>
<h4 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h4><p>​        锁的思路：将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问，该线程结束后其他线程才能对其进行访问。</p>
<p>​        锁可以理解为对共享数据进行保护的许可证。对于同一个许可证所保护的共享数据而言，任何线程访问这些共享数据前必须先持有该许可证。</p>
<h4 id="锁的特性："><a href="#锁的特性：" class="headerlink" title="锁的特性："></a><strong>锁的特性</strong>：</h4><ul>
<li>一个线程只有在持有许可证的情况下才能够对这些共享数据进行访问</li>
<li>一个许可证一次只能够被一个线程持有</li>
<li>许可证的持有线程在其结束对这些共享数据的访问后必须让出(释放)其持有的许可证，以便其他线程能够对这些共享数据进行访问。</li>
<li>锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区(Critical Section)。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。</li>
</ul>
<h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a><strong>约定</strong></h4><p>​        如果有多个线程访问同一个锁锁保护的共享数据，那么我们就称这些线程同步在这个锁上，或者称为们对这些线程锁锁进行的共享数据访问进行加锁；相应地，这些线程所执行的临界区就被称为这个锁所引导的临界区。</p>
<p>​    <code>锁具有排他性</code>(Exclusive)，即一个锁一次只能被一个线程持有。因此，这种锁被称为排他锁或者互斥锁(Mutex)。这种锁的实现方式代表了锁的基本原理。读写锁—排他锁的一种相对改进。</p>
<p>​        按照Java虚拟机对锁的实现方式划分，Java平台中的锁包含内部锁(Intrinsic Lock)和显式锁(Explicit Lock)。内部锁是通过synchronized关键字实现的。</p>
<p>​                <img src="https://user-images.githubusercontent.com/24977343/68444179-08967880-0211-11ea-8d6d-62c534d51139.png" alt=""></p>
<h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>​        一个锁实例可以保护一个或者多个共享数据。一个锁实例所保护的共享数据的数量大小就被称为该锁的粒度(Granularity)。一个锁实例保护的共享数据的数量大，就称该锁的粒度粗，否则就称该锁的粒度细。锁的粒度的粗细是相对的。</p>
<h5 id="锁的开销及可能导致的问题"><a href="#锁的开销及可能导致的问题" class="headerlink" title="锁的开销及可能导致的问题"></a>锁的开销及可能导致的问题</h5><p>​    锁的开销包括锁的申请和释放所产生的开销，以及锁可能导致的上下文切换的开销。这些开销主要是处理器时间。</p>
<p>​    锁可能导致上下文切换。多个线程争用排他性资源可能导致上下文切换。一旦锁被争用就可能导致上下文切换，而没有被争用的锁则可能不会导致上下文切换，</p>
<p>​        锁的不正确使用也会导致如下一些活性故障：</p>
<ul>
<li>锁泄漏(Lock Leak)。指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。</li>
<li>死锁、锁死等活性故障。</li>
</ul>
<h4 id="内部锁：synchronized关键字"><a href="#内部锁：synchronized关键字" class="headerlink" title="内部锁：synchronized关键字"></a>内部锁：synchronized关键字</h4><p>​        Java平台中的任何一个对象都有唯一一个与之关联的锁。这种锁被称为监视器(Monitor)或者<code>内部锁</code>(Intrinsic Lock)。内部锁是一种排他锁，它能够保障原子性、可见性和有序性。</p>
<p>​        synchronized关键字修饰的方法就被称为<code>同步方法</code>(Synchronized Method)。</p>
<p>​        synchronized关键字修饰的代码块被称为同步块。引导的代码块就是临界区。        </p>
<p>​        synchronized会保证修饰的方法里面一次只能被一个方法执行，变成串行，整体并发中的局部串行。        </p>
<p>​        synchronized修饰的代码块被称为同步块。</p>
<p>​        synchronized也被称为内部锁。</p>
<p>​                synchronized(锁句柄){</p>
<p>​            //在此代码块中访问共享数据</p>
<p>​                }</p>
<p>​        synchronized关键字所引导的代码块就是临界区。<code>锁句柄</code>是一个对象的引用(或者能够返回对象的表达式)。习惯上我称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的引导锁。相应地，我们称呼相应地同步块为该锁引导的同步块。</p>
<p>​        同步实例方法相当于以”this”为引导锁的同步块。</p>
<p>​        作为锁句柄的变量通常采用final修饰。这是因为句柄锁变量的值一旦改变，会导致执行同一个同步块的多个线程实际上使用不同的锁，从而导致竞态。有鉴于此，通常使用private修饰作为锁句柄的变量。</p>
<p>​        作为锁句柄的变量通常采用private final修饰。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>​        同步静态方法相当于以当前类对象(Java中的类本身也是一个对象)为引导锁的同步块。</p>
<p>​        线程在执行临界区代码的时候必须持有该临界区的引导锁。一个线程执行到同步代码块(同步方法也可看作同步块)时必须先申请该同步块的引导锁，只有申请成功(获得)该锁的线程才能够执行相应的临界区。一个线程执行完临界区代码后引导该临界区的锁就会被自动释放。在这个过程中，<strong>线程对内部锁的申请与释放的动作由java虚拟机负责代为实施，这也正是synchronized实现的锁被称为内部锁的原因。</strong></p>
<p>​        内部锁并不会导致锁泄漏。这是因为Java编译器(javac)在将同步块代码编译为字节码的时候，对临界区中可能抛出的而程序没代码中又未捕获的异常进行了特殊(代为)处理，这使得临界区即使抛出异常也不会妨碍内部锁的释放。</p>
<p>​        synchronized可以修饰几种类型：</p>
<ul>
<li>类：作用对象是这个类的所有对象</li>
<li>方法：作用对象是调用这个方法的对象</li>
<li>静态方法：作用对象是这个类的所有对象</li>
<li>代码块：作用的对象是调用这个代码的对象</li>
</ul>
<h4 id="内部锁的调度"><a href="#内部锁的调度" class="headerlink" title="内部锁的调度"></a>内部锁的调度</h4><p>​        <img src="https://user-images.githubusercontent.com/24977343/68633983-d8abe580-052e-11ea-9a25-581cada0201f.png" alt=""></p>
<p>Java虚拟机会为每个内部锁分配一个入口集(Entry Set)，用于记录等待获得相应内部锁的线程。多个线程申请一个锁的时候，只有一个能申请成功。申请失败的会被暂停(生命周期状态变为BLOCKED)并被存入相应锁的入口集中等待再次申请锁的机会。入口集中的线程就被称为相应内部锁的等待线程。<strong>由于Java虚拟机仅支持非公平调度</strong>，被唤醒的等待线程占用处理器运行时间可能还有其他新的活跃线程处于(RUNNABLE状态，且未进入过入口集)。</p>
<p>​    Java选择线程是随机的，与Java虚拟机具体实现有关。可能是最长、最短或者随机的。</p>
<p>​    synchronized是非公平锁。</p>
<p>​    <strong>总结</strong></p>
<p>缺点：</p>
<ul>
<li>synchronized是内部锁，线程对内部锁的申请与释放的动作由java虚拟机负责代为实施。而Java虚拟机仅支持非公平调度。所以有可能有的线程永远得不到调用。</li>
<li>​                </li>
</ul>
<h4 id="显式锁：LOCK接口"><a href="#显式锁：LOCK接口" class="headerlink" title="显式锁：LOCK接口"></a>显式锁：LOCK接口</h4><p>​        显示锁是JDK开始引入的排他锁。作为一种线程同步机制，其作用与内部锁相同。它提供了一些内部锁锁不具备的特性，但并不是内部锁的替代品。</p>
<h4 id="CAS与原子变量"><a href="#CAS与原子变量" class="headerlink" title="CAS与原子变量"></a>CAS与原子变量</h4><p>​        volatile无法保障(count++)这种自增操作的原子性。像自增这种比较简单的操作原子性我们有更好的选择–CAS。CAS能够将read-modify-write和check-and-act之类的操作转换为原子操作。</p>
<p>​        count++实际上是一个read-modify-write操作，它可以由CAS转换为一种一般性的if-then-act的操作，并由处理器保障该操作的原子性。                    </p>
<p>​        CAS就像一个代理人，多个线程共享一个V变量。客户想修改这个变量的时候会让代理人代为修改。同时提供给代理人V、目前看到的V的值A以及要期望的的值B。CAS是一个原子的if-then-act的操作，如果变量V的当前值与客户提供的A的值相等，就说明没有其他线程修改过V的值。那么最早申请的客户就会抢先将变量V的值更新为B，而其他客户(线程)的更新请求失败。这种更新机制是以CAS操作是一个原子操作为基础的，这一点直接由处理器来保障。</p>
<ul>
<li>CAS只保障了共享变量更新这个操作的原子性，它并不保障可见性。因此，上述代码中我们仍然采用volatile修饰共享变量count.        </li>
</ul>
<h5 id="原子操作工具：原子变量类"><a href="#原子操作工具：原子变量类" class="headerlink" title="原子操作工具：原子变量类"></a>原子操作工具：原子变量类</h5><h4 id="对象的发布与逸出"><a href="#对象的发布与逸出" class="headerlink" title="对象的发布与逸出"></a>对象的发布与逸出</h4><p>线程安全问题产生的前提条件是多个线程共享变量。即使是private变量，它也可能被多个线程共享。</p>
<p>多个线程共享变量还有其他途径，它们被统称为对象发布(Publish)。<code>对象发布</code>是指能够被其他作用域之外的线程访问。</p>
<h5 id="对象的初始化安全：重访final与static"><a href="#对象的初始化安全：重访final与static" class="headerlink" title="对象的初始化安全：重访final与static"></a>对象的初始化安全：重访final与static</h5><p>​        Java中类的初始化</p>
<p>​        一个类被Java虚拟机加载之后，该类的所有静态变量的值都仍然是其默认值(引用型变量都默认值为null，boolean变量的默认值为false)，直到有个线程初次访问了该类的任意一个静态变量才使这个类被初始化—-类的静态初始化块(“static{}”)被执行，类的所有静态变量被赋予初始值。</p>
<p>​        static关键字在多线程环境下有其特殊的涵义，它能够保障一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值(而不是默认值)。但是这种可见性保障仅限于线程初次读取该变量。如果这个静态变量在相应类初始化完毕之后被其他线程更新过，那么一个线程要读取该变量的相对新值仍然需要借助锁、volatile关键字等同步机制。</p>
<p>​        static关键字仅仅保障读取线程能够读取到相应字段的初始值，而不是相对新值。</p>
<p>​        我们知道由于重排序的作用，一个线程读取到一个对象引用时，改对象可能尚未完成初始化，即这些线程可能读取到该对象字段的默认值而不是初始值(通过构造器或者初始化语句指定的值)。在多线程环境下final关键字有其特殊的作用：</p>
<p>​        final关键字则确保了其他线程读取这些字段的时候所读取到的值都是相应字段的初始值(而不是默认值)，包括引用型final字段;</p>
<p>​    例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">构造方法</span><br><span class="line">&#123;</span><br><span class="line">  x=<span class="number">1</span>;</span><br><span class="line">  y=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么两个线程读取的时候 ，x一定为<span class="number">1</span>；但是y可能是<span class="number">2</span>也可能是<span class="number">0</span>(默认值)；</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objRef.x = <span class="number">1</span>;      (<span class="number">2</span>)<span class="keyword">final</span></span><br><span class="line">objRef.y=<span class="number">2</span>;      	 (<span class="number">3</span>)	</span><br><span class="line">instance=objRef;	 (<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>​    操作3(非final字段初始化)可能被JIT编译器、处理器重排序到子操作4(对象发布)之后。但是2不会。原因如下：</p>
<p>​        Java虚拟机会将子操作2限定在子操作4前完成。这里所谓的限定是指JIT编译器不会将构造器中对final字段的赋值操作重排到子操作，并且还会禁止处理器做这种操作。Java语言规范还会保障其他线程看到包含该字段的对象时，这个字段所引用的对象必然是初始化完毕的。</p>
<p>​    final关键字只能保障有序性。        </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​        Java线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同。因此，我们需要根据实际情况选择一个功能适合且开销较小的同步机制。</p>
<p>​        <img src="https://user-images.githubusercontent.com/24977343/69113013-bb41c300-0abc-11ea-915a-ced872397059.png" alt=""></p>
<h3 id="线程间协作"><a href="#线程间协作" class="headerlink" title="线程间协作"></a>线程间协作</h3><p>​        面向对象的时间中类不是孤立的，一个类往往需要借助其他类才能完成一个计算。同样，多线程时间中线程并不是孤立的，一个线程往往需要其他线程的协作才能够完成其待执行的任务。</p>
<h5 id="等待与通知-wait-notify"><a href="#等待与通知-wait-notify" class="headerlink" title="等待与通知:wait/notify"></a>等待与通知:wait/notify</h5><p>​        在单线程编程中，程序要执行的操作(目标动作)如果需要满足一定的条件(保护条件)才能执行，那么我们可以将该操作放在一个if语句体中，这使得目标动作只有在保护条件得以满足的时候才能被执行。在多线程编程中处理这种情形我们有另外一个选择—保护条件未满足可能只是暂时的，稍后其他线程可能更新了保护条件涉及的共享变量而使得其成立，因此我们可以将当前线程暂停，直到其所需的保护条件得已成立时再将其唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子操作</span></span><br><span class="line">atomic&#123;</span><br><span class="line">    <span class="keyword">while</span> (保护条件不成立)&#123;</span><br><span class="line">        暂停当前线程；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行目标动作</span></span><br><span class="line">    doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        显然上述操作必须具有原子性。这里，一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就称为<code>等待</code>(Wait)。一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒这些暂停的线程的过程就被称为通知(Notify);</p>
<h5 id="wait-notify的作用与用法"><a href="#wait-notify的作用与用法" class="headerlink" title="wait/notify的作用与用法"></a>wait/notify的作用与用法</h5><p>​        在java平台中，Object.wait()/Object.wait(long)以及Object        </p>
<p>​        Java虚拟机会为每个对象维护一个入口集(Entry Set)用于存储申请该对象内部锁的线程。此外，Java虚拟机还会为每个对象维护一个被称为等待集(Wait Set)的队列，该队列用于存储该对象上的等待线程。</p>
<h3 id="实际小案例"><a href="#实际小案例" class="headerlink" title="实际小案例"></a>实际小案例</h3><h4 id="两个线程，一个线程只有字母，一个线程只有数字，交替输出"><a href="#两个线程，一个线程只有字母，一个线程只有数字，交替输出" class="headerlink" title="两个线程，一个线程只有字母，一个线程只有数字，交替输出"></a>两个线程，一个线程只有字母，一个线程只有数字，交替输出</h4><h5 id="使用LockSupport"><a href="#使用LockSupport" class="headerlink" title="使用LockSupport"></a>使用LockSupport</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>,t2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] aI = <span class="string">"1234567"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">"ABCDEFG"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aI)&#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                LockSupport.unpark(t2); <span class="comment">//t2继续运行</span></span><br><span class="line">                LockSupport.park(); <span class="comment">//当前线程暂停</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aC)&#123;</span><br><span class="line">                LockSupport.park(); <span class="comment">//t2阻塞</span></span><br><span class="line">                System.out.print(c);</span><br><span class="line">                LockSupport.unpark(t1);<span class="comment">// t1唤醒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LockSupport.unpark(“线程1”);  此时LockSupport.park()就不再生效了，无法阻塞当前线程。因为unpark在前。</p>
<p>此时需要数组相等</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyToRun1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> ReadyToRun &#123;T1, T2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> ReadyToRun r = ReadyToRun.T1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] aI = <span class="string">"1234567"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">"ABCDEFG"</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r !=ReadyToRun.T1)&#123;&#125;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                r = ReadyToRun.T2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r !=ReadyToRun.T2)&#123;&#125;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                r = ReadyToRun.T1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自旋锁：是这个线程不放弃CPU，没有wait进入等待队列，现在仍然占用CPU。</p>
<p>自旋锁一般应用在代码速度特别快，执行时间特别短的情况。</p>
<p>好处：不经过操作系统。内核态和用户态，正常申请一把锁的时候，要从用户态向内核态申请锁，大多数情况下在用户态自旋不经过内核态，效率相对高一些。</p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><ul>
<li>继承Thread类创建线程对象</li>
<li>实现Runnable接口类创建线程对象</li>
</ul>
<p><strong>注意：</strong></p>
<p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个jvm，每一个jvm实际上就是在操作系统中启动一个进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Java 基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Java 基础/" itemprop="url">Java 基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java 基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>在实例化类的时候指明泛型的具体类型</strong></p>
<p><strong><code>类型的参数化，可以把类型像方法的参数那样传递。</code></strong></p>
<p>优点：<strong><code>泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。如果我们在对一个对象赋值不符合其泛型的规范，就会编译报错</code></strong></p>
<p>1、代码重用：我们可以编写一个方法/类/接口，并用于我们想要的任何类型。</p>
<p>2、类型安全：泛型使错误显示在编译时而不是在运行时</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Simple Java program to demonstrate that NOT using </span></span><br><span class="line"><span class="comment">// generics can cause run time exceptions </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creatinga an ArrayList without any type specified </span></span><br><span class="line">        ArrayList al = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">        al.add(<span class="number">10</span>); <span class="comment">// Compiler allows this </span></span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Causes Runtime Exception </span></span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只有在运行时才会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p><strong>类型转换异常</strong></p>
<p><strong>泛型如何解决这个问题？</strong></p>
<p>在定义ArrayList时，我们可以指定此列表只能使用String对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creating a an ArrayList with String specified </span></span><br><span class="line">        ArrayList &lt;String&gt; al = <span class="keyword">new</span> ArrayList&lt;String&gt; (); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Now Compiler doesn't allow this </span></span><br><span class="line">        al.add(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、不需要单独类型转换：如果我们不使用泛型，那么，在上面的例子中，每次我们从ArrayList检索数据时，我们必须对它进行强制类型转换，而且还要自己检查是否是String类型，否则就会报错，因为从List中取出元素时，其类型会默认为Object。在每次检索操作中进行类型转换都是一个令人头痛的问 如果我们已经知道我们的列表只包含字符串数据，那么我们不需要每次都对它进行类型转换。</p>
<p>4、实现通用算法：通过使用泛型，我们可以实现适用于不同类型对象的算法，同时它们也是类型安全的。</p>
<p>5、有界泛型</p>
<p><strong><em>在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Animal&gt;<span class="comment">//限定T是Animal的子类</span></span><br><span class="line"></span><br><span class="line">&lt;T <span class="keyword">super</span> Dog &gt;<span class="comment">//限定T是Dog的超类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killAll</span><span class="params">(ArrayList&lt;T extends Animal&gt; animals)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>多个限定时我们可以使用&amp;来进行分割，这时关键词只能使用extends。与多重继承类似，这里只可以有一个类，其他都是接口。</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Object&amp;Comparable&amp;Serializable&gt;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p><strong>在调用方法的时候指明泛型的具体类型</strong></p>
<p><code>定义泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958544-ba9ac600-87d5-11e9-9473-ea75ecb5077f.png" alt=""></p>
<p><code>调用泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958730-25e49800-87d6-11e9-9619-7774468f4e20.png" alt=""></p>
<p>​       <strong>说明一下，定义泛型方法时，必须在返回值前边加一个<t>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。</t></strong></p>
<p>​       Class<t>的作用就是指明泛型的具体类型，而Class<t>类型的变量c，可以用来创建泛型类的对象。</t></t></p>
<p>​       为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>​       泛型方法要求的参数是Class<t>类型，而Class.forName()方法的返回值也是Class<t>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<t>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<user>类型的对象，因此调用泛型方法时，变量c的类型就是Class<user>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</user></user></t></t></t></p>
<p>​       当然，泛型方法不是仅仅可以有一个参数Class<t>，可以根据需要添加其他参数。</t></p>
<p>​       为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h2 id="Java数据结构应用"><a href="#Java数据结构应用" class="headerlink" title="Java数据结构应用"></a>Java数据结构应用</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList()方法"></a>subList()方法</h4><p>截取list的一段，但是如果对这一段做了修改，那么原来的list也会发生相应的变化。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>定义：</strong>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p><strong>简单定义：</strong>有一个或多个抽象方法的类，必须声明为抽象类。不能创建实例</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="为啥用抽象类"><a href="#为啥用抽象类" class="headerlink" title="为啥用抽象类"></a>为啥用抽象类</h3><ol>
<li>父类中的方法确实没有必要写(通用方法)，当然可以用类的覆盖，但是没有必要</li>
<li>各个子类中的这个方法肯定会不同</li>
<li>抽象方法有提示作用</li>
<li>发现共性，向上抽取。方法功能声明相同，但是方法功能主体不同。</li>
</ol>
<p>总结：</p>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法(用static修饰的方法)不能声明为抽象方法</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li>
<li>具体派生类必须覆盖基类的抽象方法</li>
<li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/LeetCode/" itemprop="url">LeetCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>## </p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>206    反向链表</li>
</ul>
<p>141，21，19，876</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>20,155,232,844,224,682,496</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/FastDfs分布式文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/FastDfs分布式文件系统/" itemprop="url">FastDFS 分布式文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T10:40:45+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="FastDfs简介"><a href="#FastDfs简介" class="headerlink" title="FastDfs简介"></a>FastDfs简介</h3><ol>
<li>FastDfs是一个轻量级的开源分布式文件系统</li>
<li>FastDfs主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>
<li>FastDfs实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>
<li>支持存储服务器在线扩容</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>
<li><p>FastDFS特别适合大中型网站使用，用来存储资源文件(如：图片、文档、音频、视频等等)</p>
<p>  FastDFS是一个开源的轻量级分布式文件系统，她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。  </p>
</li>
</ol>
<p>FastDFS服务端有两个角色：<strong>跟踪器(tracker)</strong>和<strong>存储节点(storage)</strong>。跟踪器主要做调度工作，在访问上起负载均衡 的作用。</p>
<h4 id="Tracker"><a href="#Tracker" class="headerlink" title="Tracker"></a>Tracker</h4><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%BC%95%E5%85%A5Tracker.jpg?raw=true" alt=""></p>
<p>Group之间是相互独立的，Group内是相互备份的；Tracker之间也是相互独立的。</p>
<ul>
<li><p>Group之间 相互独立</p>
</li>
<li><p>同一Group内的Storage Server 之间需要互相备份</p>
<p>文件存放到一个Storage以后，需要备份到别的服务器</p>
</li>
<li><p>Tracker之间是不交互的</p>
<ul>
<li>每个storage server都需要向所有Tracker去主动报告信息</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ol>
<li>group内的server内容都是一致的</li>
<li>一个负责跟踪一个负责存储</li>
<li>group会向每个tracker都汇报，tracker存储的信息很少</li>
</ol>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg?raw=true" alt=""></p>
<h4 id="选定Tracker-Server"><a href="#选定Tracker-Server" class="headerlink" title="选定Tracker Server"></a>选定Tracker Server</h4><ul>
<li>Tracker Server不止一个，客户端选择哪一个做上传文件？</li>
</ul>
<p>Client是如何知道上传到那个Tracker Server</p>
<p>Client可以维护一个Tracker列表</p>
<ul>
<li>Tracker如何选择Group？(三种策略)<ul>
<li>round robin(轮询)</li>
<li>load balance(选择最大剩余空间的组上传文件)</li>
<li>specify group(指定group上传)</li>
</ul>
</li>
</ul>
<h4 id="选定Storage-Server"><a href="#选定Storage-Server" class="headerlink" title="选定Storage Server"></a>选定Storage Server</h4><ul>
<li>一个组内有多个Storage Server ，选择哪一个？<ul>
<li><ol>
<li>Round robin，所有server轮询使用(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>根据IP地址进行排序选择第一个服务器(IP地址最小者)</li>
</ol>
</li>
<li><ol start="3">
<li>根据优先级进行排序(上传优先级由storage server来设置，参数为upload_priority)</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%20%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" alt=""></p>
<h4 id="选择storage-path"><a href="#选择storage-path" class="headerlink" title="选择storage path"></a>选择storage path</h4><ul>
<li>如何选择storage path(虚拟磁盘目录M00，M01路径)<ul>
<li><ol>
<li>round robin ，轮询(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>load balance，选择使用剩余空间最大的存储路径</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>目录和文件</p>
<ul>
<li>选定存放目录？<ul>
<li>storage会生成一个file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg)，采用Base64编码，file_id包含字段包括：storage server_ip(文件的源服务器)、文件创建时间、文件大小、文件CRC32校验码和随机数、；(这个时候文件名已经和最早的文件名是两回事儿了)</li>
<li>每个存储目录下有两个256*256个子目录，storage 会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为文件名存储到该子目录下</li>
</ul>
</li>
</ul>
<p>Group1/M00/00/OC/wKjGgVgbV2-ABdo-AAAAHw.jpg   </p>
<p>tracker可以通过上面的东西迅速的找到文件</p>
<p><strong>要点：</strong></p>
<ul>
<li>server之间不分主从，每个目录可以不止放一个文件</li>
<li>存储服务器启动的时候就会把两个256*256个目录一次创建出来</li>
<li>file_id必须由client来保存。</li>
</ul>
<p>怎么确定存放在那个目录</p>
<p>storage会按照文件的file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg   )做两次hash算法，路由到其中一个子目录中。</p>
<h4 id="Storage-Server之间的文件同步"><a href="#Storage-Server之间的文件同步" class="headerlink" title="Storage Server之间的文件同步"></a>Storage Server之间的文件同步</h4><ul>
<li>同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；</li>
<li>文件同步只在组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器；</li>
<li>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</li>
<li>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一套storage server将已有的所有数据(包括源头数据和备份数据)同步给新增服务器</li>
</ul>
<p>client是FastDFS提供的客户端</p>
<p>FastDFS有覆盖方法，可以修改某个已经上传的文件，甚至是追加操作。</p>
<p>例子：</p>
<p>A，B，C三个服务器在同一个组中</p>
<ul>
<li>9:30用户向服务器A上传了一个文件X(文件创建时间9:30)</li>
<li>9:31用户向服务器B上传了一个文件Y(文件创建时间9:31)</li>
<li>9:32用户向服务器A上传了一个文件Z(文件创建时间9:32)</li>
</ul>
<p>A向B，C同步文件X，并且向Tracker Server汇报</p>
<ul>
<li>我向B同步了X(文件创建时间9:30)</li>
<li>我向C同步了X(文件创建时间9:30)</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A52.jpg?raw=true" alt=""></p>
<p>通过文件名都可以取到创建时间和源服务器地址</p>
<p>这个时候下载文件Y，tracker会去那个服务器上面寻找呢?</p>
<p>这个时候可以直接从B中下载，如果这个时候B宕机了，只有和A或C中找，查tracker中的表时，B–&gt;A在9：31前的都同步了，就去A中找。如果A也宕机了，就去C中找，看这个时间前的是否同步。</p>
<p>tracker不需要保存左侧的信息，根据文件名就可以了。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A53.jpg?raw=true" alt=""></p>
<p>这个时候假设用户想下载文件Z，就去源服务器下载，如果源服务器宕机，就去其他服务器下载。根据时间判断是否在这个时间前的同步了，如果同步了就下载，如果没有就下载。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A54.jpg?raw=true" alt=""></p>
<p>当试图下载文件的时候，根据文件名拿到创建时间和服务器，根据时间来判断是否可以下载。</p>
<p>FastDFS文件同步方式</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F.jpg?raw=true" alt=""></p>
<p>最后最早同步时间，</p>
<p>对于服务器A来讲，服务器B向他同步的时间是9:31,服务器C是9:33.计算最后的时间，那么根据上图。</p>
<p>对服务器A，它的最早同步时间是9:31</p>
<p>对服务器B，它的最早同步时间是9:32</p>
<p><strong>取最小值，然后直接和最小值进行比对。</strong></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%9C%80%E5%90%8E%E6%9C%80%E6%97%A9%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4.jpg?raw=true" alt=""></p>
<p>X可以从三个服务器下载</p>
<p>Y可以从A和B服务器下载，C不行。</p>
<p>Z可以从源服务器A下载，或者服务器B下载,C不行</p>
<p>W只能从服务器C这个源服务器下载，虽然根据时间判断C已经将9:33前的同步到了A和B这两个服务器，但是根据规则，它不能去A和B下载。</p>
<p>虽然简单，但是会牺牲一下。</p>
<p>选择一个可供下载的Storage Server策略</p>
<ul>
<li>该文件上传到源Storage server(文件直接上传到该服务器上的)</li>
<li>文件创建时间戳&lt;Storage server被同步到的文件时间戳，这意味着当前文件已经被同步过来了；</li>
<li>文件创建时间戳=Storage server被同步到的文件时间戳，且(当前时间-文件创建时间戳)&gt;一个文件同步完成需要的最大时间(如5分钟);</li>
<li>(当前时间-文件创建时间戳)&gt;文件同步延迟阈值，比如我们把阈值设置为1天，表示文件同步在一天内肯定可以完成</li>
</ul>
<p>当走到第四个的时候可能已经出问题了。</p>
<p>tracker定位一个组中的server</p>
<h3 id="FastDFS的使用"><a href="#FastDFS的使用" class="headerlink" title="FastDFS的使用"></a>FastDFS的使用</h3><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8.jpg?raw=true" alt=""></p>
<p>这里的FastDFSAPI可以当做client</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8Cnagix%E9%9B%86%E6%88%90.jpg?raw=true" alt=""></p>
<p>上图这种就是</p>
<p>如果上传的话还是走Nginx，到应用服务器</p>
<p>如果下载的时候，直接通过Nginx，直接到FastDFS，模块和Nginx集成。绕过应用服务器</p>
<p>要点：</p>
<ul>
<li>Tracker server内部没有数据库，要么是内存要么是纯文件，文件格式自己定义</li>
</ul>
<h3 id="防止盗链"><a href="#防止盗链" class="headerlink" title="防止盗链"></a>防止盗链</h3><ul>
<li>辛苦上传的文件不想被人盗取</li>
<li>给URL增加token<ul>
<li>Token只有自己的网站才能生成</li>
<li>Token会过期</li>
</ul>
</li>
</ul>
<p>refer</p>
<h4 id="防止盗链的配置"><a href="#防止盗链的配置" class="headerlink" title="防止盗链的配置"></a>防止盗链的配置</h4><p>是否做token检查，缺省为false</p>
<p>http.anti_steal.check_token=true</p>
<p>即生成token的有效时长 秒</p>
<p>http.anti_steal.token_ttl=900</p>
<p>生成token的密钥，尽量设置得长一些</p>
<p>http.anti_steal.secret<em>key=@#%*&amp;$)87)</em>+$%!~</p>
<p>Token = md5(文件名，密钥，时间戳)</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E9%98%B2%E6%AD%A2%E7%9B%97%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE.jpg?raw=true" alt=""></p>
<p>将文件名、密钥和时间戳的组合通过md5加密传给token</p>
<p>token是在服务器端生成</p>
<p>客户端下载文件的时候，除了传fileid以外还需要token</p>
<p>客户端发送的是fileid，服务器端返回的是一个token</p>
<h4 id="合并存储"><a href="#合并存储" class="headerlink" title="合并存储"></a>合并存储</h4><ul>
<li>海量小文件的缺点<ul>
<li>元数据管理低效，磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上</li>
<li>数据存储分散</li>
<li>磁盘的大量随机访问降低效率</li>
</ul>
</li>
<li>FastDFS提供的合并存储功能<ul>
<li>默认大文件64M</li>
<li>每个文件空间称为slot(256bytes&lt;=slot&lt;=16MB)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%B2%A1%E6%9C%89%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6ID.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6.jpg?raw=true" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>FastDFS是穷人的解决方案</li>
<li>FastDFS把简洁和高效做到了极致，非常节约资源，中小网站完全用的起</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-集成Hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-集成Hibernate3/" itemprop="url">Spring--集成Hibernate3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T17:26:07+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E9%95%BF%E9%A2%88%E9%B9%BF.jpg?raw=true" alt=""></p>
<h3 id="集成Hibernate3"><a href="#集成Hibernate3" class="headerlink" title="集成Hibernate3"></a>集成Hibernate3</h3><p>​       Hibernate是全自动的ORM框架，能自动为对象生成相应SQL并透明的持久化对象到数据库。</p>
<p> <strong>Spring2.5+版本支持Hibernate 3.1+版本，不支持低版本，Spring3.0.5版本提供对Hibernate 3.6.0 Final版本支持。</strong></p>
<h4 id="如何集成"><a href="#如何集成" class="headerlink" title="如何集成"></a>如何集成</h4><p>Spring通过使用如下Bean进行集成Hibernate：</p>
<ul>
<li>LocalSessionFactoryBean ：用于支持XML映射定义读取：</li>
<li>configLocation和configLocations：用于定义Hibernate配置文件位置，一般使用classpath:hibernate.cfg.xml形式指定；</li>
<li>mappingLocations：用于指定Hibernate映射文件位置，如chapter8/hbm/user.hbm.xml;</li>
<li>hibernateProperties：用于定义Hibernate属性，即Hibernate配置文件中的属性；</li>
<li>dataSource：定义数据源；</li>
<li>hibernateProperties、dataSource用于消除Hibernate配置文件，因此如果使用configLocations指定配置文件，就不要设置这两个属性了，否则会产生重复配置。推荐使用dataSource来指定数据源，而使用hibernateProperties指定Hibernate属性。</li>
<li>AnnotationSessionFactoryBean：用于支持注解风格映射定义读取，该类继承LocalSessionFactoryBean并额外提供自动查找注解风格配置模型的能力；</li>
<li>AnnotatedClasses：设置注解了模型类，通过注解指定映射元数据。</li>
<li>packagesToScan：通过扫码指定的包获取注解模型类，而不是手工指定，如”com.zero.**.model”将扫码com.zero包及子包下的model包下所有注解模型类。</li>
</ul>
<p>接下来学习一下Spring如何继承Hibernate吧；</p>
<p><strong>1、准备jar包：</strong></p>
<p>首先准备Spring对ORM框架支持的jar包：</p>
<p>org.springframework.orm-3.0.5.RELEASE.jar      //提供对ORM框架集成</p>
<p>下载hibernate-distribution-3.6.0.Final包，获取如下Hibernate需要的jar包：</p>
<p>hibernate3.jar        //核心包</p>
<p>lib\required\antlr-2.7.6.jar        //HQL解析时使用的包</p>
<p>lib\required\javassist-3.9.0.GA.jar        //字节码类库，类似与cglib</p>
<p>lib\required\commons-collections-3.1.jar  //对集合类型支持包，前边测试时已经提供过了，无需再拷贝该包了</p>
<p>lib\required\dom4j-1.6.1.jar            //xml解析包，用于解析配置使用</p>
<p>lib\required\jta-1.1.jar                 //JTA事务支持包</p>
<p>lib\jpa\hibernate-jpa-2.0-api-1.0.0.Final.jar //用于支持JPA</p>
<p> 下载slf4j-1.6.1.zip（<a href="http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple" target="_blank" rel="noopener">http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple</a> Logging Facade for Java），用于对各种日志框架提供给一致的日志访问接口，从而能随时替换日志框架（如log4j、java.util.logging）：</p>
<p>将这些jar包添加到类路径中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-JDBC/" itemprop="url">Spring-JDBC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T15:02:23+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E8%A9%B9%E5%A7%86%E6%96%AF.jpg?raw=true" alt=""></p>
<p>抄自开涛博客   <a href="http://jinnianshilongnian.iteye.com/blog/1423896" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1423896</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h4><p>​       传统应用程序开发中，进行JDBC编程是相当痛苦的，如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cn.javass.spring.chapter7. TraditionalJdbcTest  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">    PreparedStatement pstmt = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      conn = getConnection();              <span class="comment">//1.获取JDBC连接  </span></span><br><span class="line">                                       <span class="comment">//2.声明SQL  </span></span><br><span class="line">      String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;  </span><br><span class="line">      pstmt = conn.prepareStatement(sql);    <span class="comment">//3.预编译SQL  </span></span><br><span class="line">      ResultSet rs = pstmt.executeQuery();   <span class="comment">//4.执行SQL  </span></span><br><span class="line">      process(rs);                       <span class="comment">//5.处理结果集  </span></span><br><span class="line">      closeResultSet(rs);                 <span class="comment">//5.释放结果集  </span></span><br><span class="line">      closeStatement(pstmt);              <span class="comment">//6.释放Statement  </span></span><br><span class="line">      conn.commit();                    <span class="comment">//8.提交事务  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">      <span class="comment">//9.处理异常并回滚事务  </span></span><br><span class="line">      conn.rollback();  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      <span class="comment">//10.释放JDBC连接，防止JDBC连接不关闭造成的内存泄漏  </span></span><br><span class="line">      closeConnection(conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       以上代码片段具有冗长、重复、容易忘记某一步骤从而导致出错、显示控制事务、显示处理受检查异常等等。</p>
<p>​        有朋友可能重构出自己的一套JDBC模板，从而能简化日常开发，但自己开发的JDBC模板不够通用，而且对于每一套JDBC模板实现都差不多，从而导致开发人员必须掌握每一套模板。</p>
<p>​        Spring JDBC提供了一套JDBC抽象框架，用于简化JDBC开发，而且如果各个公司都使用该抽象框架，开发人员首先减少了学习成本，直接上手开发，如图7-1所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JDBC.JPG?raw=true" alt=""></p>
<p>图7-1 Spring JDBC与传统JDBC编程对比</p>
<h4 id="Spring对JDBC的支持"><a href="#Spring对JDBC的支持" class="headerlink" title="Spring对JDBC的支持"></a>Spring对JDBC的支持</h4><p>​       Spring通过抽象JDBC访问并提供一致的API来简化JDBC编程的工作量。我们只需要<strong>声明SQL、调用合适的Spring JDBC框架API、处理结果集</strong>即可。事务由Spring管理，并将JDBC受查异常转换为Spring一致的非受查异常，从而简化开发。</p>
<p>​        Spring主要提供<strong>JDBC模板方式、关系数据库对象化方式和SimpleJdbc</strong>方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p>
<ul>
<li><strong>JDBC模板方式：</strong>Spring JDBC 框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如Jdbc Template、NamedParameterJdbcTemplate、SimpleJdbcTemplate。 </li>
<li><strong>关系数据库对象化方式：</strong>Spring JDBC 框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoreProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li>
<li><strong>SimpleJdbc 方式</strong>：Spring JDBC框架还提供了<strong>SimpleJdbc 方式</strong>来简化JDBC编程，SimpleJdbcInsert、SimpleJdbcCall用来简化数据库表插入、存储过程或函数访问；</li>
</ul>
<p>Spring JDBC还提供了一些强大的工具类，如DataSourceUtils来在必要的时候手工获取数据库连接等。</p>
<h4 id="Spring的JDBC架构"><a href="#Spring的JDBC架构" class="headerlink" title="Spring的JDBC架构"></a>Spring的JDBC架构</h4><p>Spring JDBC抽象框架由四部分组成：datasource、support、core、object。如图7-2所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20JDBC%20%E6%9E%B6%E6%9E%84%E5%9B%BE.JPG?raw=true" alt=""></p>
<p>图7-2 Spring JDBC架构图</p>
<pre><code>**support包：**提供将JDBC异常转化为DAO非检查异常转换类、一些工具类如JdbcUtils等。
</code></pre><p>​    <strong>dataSource包：</strong>提供简化访问JDBC数据源(javax.sql.DataSource实现)工具类，并提供了一些    DataSource简单实现类从而能使从这些DataSource获取的连接能自动得到Spring管理事务支持。</p>
<p>​    <strong>coe包：</strong>提供JDBC模板类实现及可变部分的回调接口，还提供SimpleJdbcInsert等辅助类。</p>
<p>​    <strong>object包：</strong>提供关系数据库的对象表示形式，如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类，该包是基于core包JDBC模板类实现。</p>
<h3 id="JDBC模板类"><a href="#JDBC模板类" class="headerlink" title="JDBC模板类"></a>JDBC模板类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​       Spring JDBC抽象框架core包提供了JDBC模板类，其中JdbcTemplate是core包的核心类，所以其他模板类都是基于它封装完成的，JDBC模板类是第一种工作模式。</p>
<p>​        JdbcTemplate类通过模板设计模式帮助我们消除了冗长的代码，只做需要做的事情（即可变部分），并且帮我们做哪些固定部分，如连接的创建及关闭。</p>
<p>​        JdbcTemplate类对可变部分采用回调接口方式实现，如ConnectionCallback通过回调接口返回给用户一个连接，从而可以使用该连接做任何事情、StatementCallback通过回调接口返回给用户一个Statement，从而可以使用该Statement做任何事情等等，还有其他一些回调接口如图7-3所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JdbcTemplate%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3.JPG?raw=true" alt=""></p>
<p>图7-3 JdbcTemplate支持的回调接口</p>
<p> Spring除了提供JdbcTemplate核心类，还提供了基于JdbcTemplate实现的NamedParameterJdbcTemplate类用于支持命名参数绑定、 SimpleJdbcTemplate类用于支持Java5+的可变参数及自动装箱拆箱等特性。</p>
<h4 id="传统JDBC编程替代方案"><a href="#传统JDBC编程替代方案" class="headerlink" title="传统JDBC编程替代方案"></a>传统JDBC编程替代方案</h4><p>前边我们已经使用过传统JDBC编程方式，接下来让我们看下Spring JDBC框架提供的更好的解决方案。</p>
<p> 1）准备需要的jar包并添加到类路径中：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.springframework.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）传统JDBC编程替代方案：</p>
<p> 在使用JdbcTemplate模板类时必须通过DataSource获取数据库连接，Spring JDBC提供了DriverManagerDataSource实现，它通过包装“DriverManager.getConnection”获取数据库连接，具体DataSource相关请参考【7.5.1控制数据库连接】。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url=<span class="string">"jdbc:hsqldb:mem:test"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"123"</span>;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource(url,username,password);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"org.hsqldb.jdbcDriver"</span>);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、声明SQL</span></span><br><span class="line">        String sql=<span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//2.处理结果集</span></span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们具体分析一下：</p>
<p>1）  <strong>jdbc:hsqldb:mem:test：</strong>表示使用hsqldb内存数据库，数据库名为“test”。</p>
<p>2）  <strong>public static void setUpClass()：</strong>使用junit的@BeforeClass注解，表示在所以测试方法之前执行，且只执行一次。在此方法中定义了DataSource并使用DataSource对象创建了JdbcTemplate对象。JdbcTemplate对象是线程安全的。</p>
<p>3）  <strong>JdbcTemplate执行流程：</strong>首先定义SQL，其次调用JdbcTemplate方法执行SQL，最后通过RowCallbackHandler回调处理ResultSet结果集。</p>
<p>Spring JDBC解决方法相比传统JDBC编程方式是不是简单多了，是不是只有可变部分需要我们来做，其他的都由Spring JDBC框架来实现了。</p>
<p>接下来让我们深入JdbcTemplate及其扩展吧。</p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>​       首先让我们来看下如何使用JdbcTemplate来实现增删改查。</p>
<p> 一、首先创建表结构：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String createTableSql = <span class="string">"create memory table test"</span> + <span class="string">"(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "</span> + <span class="string">"name varchar(100))"</span>;</span><br><span class="line">    jdbcTemplate.update(createTableSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dropTableSql = <span class="string">"drop table test"</span>;</span><br><span class="line">    jdbcTemplate.execute(dropTableSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  org.junit包下的<strong>@Before和@After</strong>分别表示在测试方法之前和之后执行的方法，对于每个测试方法都将执行一次； </p>
<p>2）  <strong>create memory table test</strong>表示创建hsqldb内存表，包含两个字段id和name，其中id是具有自增功能的主键，如果有朋友对此不熟悉hsqldb可以换成熟悉的数据库。 </p>
<p>二、定义测试骨架，该测试方法将用于实现增删改查测试：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring-AOP/" itemprop="url">Spring--AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T16:21:43+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/4.jpg?raw=true" alt=""></p>
<h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>​       在进行AOP开发前，先熟悉几个概念：</p>
<ul>
<li><strong>连接点（Jointpoint）：</strong>表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，<strong>在AOP中表示为“在哪里干”</strong>；</li>
<li><strong>切入点（Pointcut）：</strong>选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，<strong>在AOP中表示为“在哪里干的集合”</strong>；</li>
<li><strong>通知（Advice）：</strong>在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；<strong>在AOP中表示为“干什么”；</strong></li>
<li><strong>方面/切面（Aspect）：</strong>横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；<strong>在AOP中表示为“在哪干和干什么集合”；</strong></li>
<li><strong>引入（inter-type declaration）：</strong>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, <strong>在AOP中表示为“干什么（引入什么）”</strong>；</li>
<li><strong>目标对象（Target Object）：</strong>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，<strong>在AOP中表示为“对谁干”</strong>；</li>
<li><strong>AOP代理（AOP Proxy）：</strong>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是<strong>通过代理来对目标对象应用切面</strong>。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li>
<li><p><strong>织入（Weaving）：</strong>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</p>
<p>在AOP中，通过切入点选择目标对象的连接点，然后在目标对象的相应连接点处织入通知，而切入点和通知就是切面（横切关注点），而在目标对象连接点处应用切面的实现方式是通过AOP代理对象，如图6-2所示。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/AOP%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.JPG?raw=true" alt=""></p>
</li>
</ul>
<p>图6-2 概念关系</p>
<p> 接下来再让我们具体看看Spring有哪些通知类型：</p>
<ul>
<li><strong>前置通知（Before Advice）:</strong>在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li>
<li><strong>后置通知（After Advice）:</strong>在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li>
<li><strong>后置返回通知(After returning Advice)：</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置异常通知(After throwing Advice):</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置最终通知(After finally Advice):</strong>在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java的finally块。</li>
<li><strong>环绕通知(Around Advice):</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li>
</ul>
<p>各种通知类型在UML序列图中的位置如图6-3所示:<br>   <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.JPG?raw=true" alt=""></p>
<p>图6-3 通知类型</p>
<h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>​       AOP代理就是AOP框架通过代理模式创建的对象，Spring使用JDK动态代理或CGLIB代理来实现，Spring缺省使用JDK动态代理来实现，从而任何接口都可别代理，如果被代理的对象实现不是接口将默认使用CGLIB代理，不过CGLIB代理当然也可应用到接口。</p>
<p>​        <strong>AOP代理的目的就是将切面织入到目标对象。</strong></p>
<p>​        概念都将完了，接下来让我们看一下AOP的 HelloWorld!吧。</p>
<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>​       首先准备开发需要的jar包，请到spring-framework-3.0.5.RELEASE-dependencies.zip和spring-framework-3.0.5.RELEASE-with-docs中查找如下jar包：</p>
<p>  org.springframework.aop-3.0.5.RELEASE.jar</p>
<p>  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</p>
<p>  com.springsource.org.aopalliance-1.0.0.jar</p>
<p>   com.springsource.net.sf.cglib-2.2.0.jar </p>
<h4 id="定义目标类"><a href="#定义目标类" class="headerlink" title="定义目标类"></a>定义目标类</h4><p>​       1）定义目标接口：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）定义目标接口实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注：在日常开发中最后将业务逻辑定义在一个专门的service包下，而实现定义在service包下的impl包中，服务接口以IXXXService形式，而服务实现就是XXXService，这就是规约设计，见名知义。当然可以使用公司内部更好的形式，只要大家都好理解就可以了。</p>
<h4 id="定义切面支持类"><a href="#定义切面支持类" class="headerlink" title="定义切面支持类"></a>定义切面支持类</h4><p>​       有了目标类，该定义切面了，切面就是通知和切入点的组合，而切面是通过配置方式定义的，因此这定义切面前，我们需要定义切面支持类，切面支持类提供了通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========after finally advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       此处HelloWorldAspect类不是真正的切面实现，只是定义了通知实现的类，在此我们可以把它看作就是缺少了切入点的切面。</p>
<p>​        注：对于AOP相关类最后专门放到一个包下，如“aop”包，因为AOP是动态织入的，所以如果某个目标类被AOP拦截了并应用了通知，可能很难发现这个通知实现在哪个包里，因此推荐使用规约命名，方便以后维护人员查找相应的AOP实现。</p>
<h4 id="在XML中进行配置"><a href="#在XML中进行配置" class="headerlink" title="在XML中进行配置"></a>在XML中进行配置</h4><p>有了通知实现，那就让我们来配置切面吧：</p>
<p>​       1）首先配置AOP需要aop命名空间，配置头如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       2）配置目标类：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       3）配置切面：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"helloWorldService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"aspect"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldAspect"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* com.zero.aop.*.*(..))"</span>/&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">"aspect"</span>&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"beforeAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">        &lt;aop:after pointcut=<span class="string">"execution(* com.zero.aop.*.*(..))"</span> method=<span class="string">"afterFinallyAdvice"</span>/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>​       切入点使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>配置，expression属性用于定义切入点模式，默认是AspectJ语法，“execution(<em> cn.javass..</em>.*(..))”表示匹配cn.javass包及子包下的任何方法执行。</p>
<p> 切面使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签配置，其中“ref”用来引用切面支持类的方法。</p>
<p> 前置通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签来定义，pointcut-ref属性用于引用切入点Bean，而method用来引用切面通知实现类中的方法，该方法就是通知实现，即在目标类方法执行之前调用的方法。</p>
<p> 最终通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签来定义，切入点除了使用pointcut-ref属性来引用已经存在的切入点，也可以使用pointcut属性来定义，如pointcut=”execution(<em> cn.javass..</em>.*(..))”，method属性同样是指定通知实现，即在目标类方法执行之后调用的方法。</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>测试类非常简单，调用被代理Bean跟调用普通Bean完全一样，Spring AOP将为目标对象创建AOP代理，具体测试代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop.xml"</span>);</span><br><span class="line">        IHelloWorldService helloworldService =</span><br><span class="line">                ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);</span><br><span class="line">        helloworldService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       该测试将输出如下如下内容：</p>
<p> ===========before advice<br>============Hello World!<br>===========after finally advice</p>
<p>​        从输出我们可以看出：前置通知在切入点选择的连接点（方法）之前允许，而后置通知将在连接点（方法）之后执行，具体生成AOP代理及执行过程如图6-4所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20AOP%E6%A1%86%E6%9E%B6%E7%94%9F%E6%88%90AOP%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.JPG?raw=true" alt=""></p>
<p> 图6-4 Spring AOP框架生成AOP代理过程</p>
<h3 id="基于Schema的AOP"><a href="#基于Schema的AOP" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h3><h4 id="基于Schema的AOP-1"><a href="#基于Schema的AOP-1" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h4><p>​     基于Schema的AOP从Spring2.0之后通过“aop”命名空间来定义切面、切入点及声明通知。</p>
<p> 在Spring配置文件中，所有AOP相关定义必须放在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，该标签下可以有<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>、<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>、<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签，配置顺序不可变。 </p>
<ul>
<li><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>：用来定义切入点，该切入点可以重用；</li>
<li><a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>：用来定义只有一个通知和一个切入点的切面；</li>
<li><p><a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，advisor只包含一个通知和一个切入点。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/aop-schema.JPG?raw=true" alt=""></p>
</li>
</ul>
<h4 id="声明切面"><a href="#声明切面" class="headerlink" title="声明切面"></a>声明切面</h4><p>​    切面就是包含切入点和通知的对象，在Spring容器中将被定义为一个Bean，Schema方式的切面需要一个切面支持Bean，该支持Bean的字段和方法提供了切面的状态和行为信息，并通过配置方式来指定切入点和通知实现。</p>
<p>​      切面使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签指定，ref属性用来引用切面支持Bean。</p>
<p>​     切面支持Bean“aspectSupportBean”跟普通Bean完全一样使用，切面使用“ref”属性引用它。</p>
<h4 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​    切入点在Spring中也是一个Bean，Bean定义方式可以有很三种方式：</p>
<p>​     <strong>1）在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>，该切入点可以被多个切面使用，对于需要共享使用的切入点最好使用该方式，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>**2）在&lt;aop:aspect&gt;*标签下使用&lt;aop:pointcut&gt;声明一个切入点Bean**，该切入点可以被多个切面使用，但一般该切入点只被该切面使用，当然也可以被其他切面使用，但最好不要那样使用，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式： 
</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">" pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>3）匿名切入点Bean，</strong>可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h4><p> 基于Schema方式支持前边介绍的5中通知类型：</p>
<p> <strong>一、前置通知：</strong>在切入点选择的方法之前执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">"前置通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">arg-names</span>=<span class="string">"前置通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>二者选一，指定切入点；</p>
<p>​         <strong>method：</strong>指定前置通知实现方法名，如果是多态需要加上参数类型，多个用“，”隔开，如beforeAdvice(java.lang.String)；</p>
<p>​         <strong>arg-names：</strong>指定通知实现方法的参数名字，多个用“，”分隔，可选，类似于【3.1.2 构造器注入】中的参数名注入限制：<strong>在class文件中没生成变量调试信息是获取不到方法参数名字的，因此只有在类没生成变量调试信息时才需要使用arg-names属性来指定参数名，如</strong>arg-names=”param”表示通知实现方法的参数列表的第一个参数名字为“param”。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayBefore(..)) and args(param)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">method</span>=<span class="string">"beforeAdvice(java.lang.String)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">arg-names</span>=<span class="string">"param"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaBeforeAdvice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">     ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">     IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">     helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=====================================================before advice param:before============say before==========================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayBefore(..)) ”匹配目标方法sayBefore，且使用“args(param)”匹配目标方法只有一个参数且传入的参数类型为通知实现方法中同名的参数类型；</p>
<p><strong>2）目标方法定义：</strong>使用method=” beforeAdvice(java.lang.String) “指定前置通知实现方法，且该通知有一个参数类型为java.lang.String参数；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=” param “指定通知实现方法参数名为“param”，切入点中使用“args(param)”匹配的目标方法参数将自动传递给通知实现方法同名参数。</p>
<p>   <strong>二、后置返回通知：</strong>在切入点选择的方法正常返回时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-returning" target="_blank" rel="noopener">aop:after-returning</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">"后置返回通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">"后置返回通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">returning</span>=<span class="string">"返回值对应的后置返回通知实现方法参数名"</span>  </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>returning：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法执行正常返回后，将把目标方法返回值传给通知方法；returning限定了只有目标方法返回值匹配与通知方法相应参数类型时才能执行后置返回通知，否则不执行，对于returning对应的通知方法参数为Object类型将匹配任何目标返回值。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============after returning"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterReturningAdvice"</span>  </span></span><br><span class="line"><span class="tag">                               <span class="attr">arg-names</span>=<span class="string">"retVal"</span>    </span></span><br><span class="line"><span class="tag">                               <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterReturningAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterReturning();      </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================after returning===========after returning advice retVal:true======================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterReturning(..)) ”匹配目标方法sayAfterReturning，该方法返回true；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterReturningAdvice”指定后置返回通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”retVal”指定通知实现方法参数名为“retVal”；</p>
<p><strong>4）返回值命名：</strong>returning=”retVal”用于将目标返回值赋值给通知实现方法参数名为“retVal”的参数上。</p>
<p> <strong>三、后置异常通知：</strong>在切入点选择的方法抛出异常时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-throwing" target="_blank" rel="noopener">aop:after-throwing</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"后置异常通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"后置异常通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"将抛出的异常赋值给的通知实现方法参数名"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>   <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>throwing：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；throwing限定了只有目标方法抛出的异常匹配与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，对于throwing对应的通知方法参数为Throwable类型将匹配任何异常。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============before throwing"</span>);  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterThrowingAdvice"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"exception"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"exception"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException.class)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterThrowingAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterThrowing();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================before throwing===========after throwing advice exception:java.lang.RuntimeException======================================</td>
</tr>
</tbody>
</table>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterThrowing(..))”匹配目标方法sayAfterThrowing，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterThrowingAdvice”指定后置异常通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”exception”指定通知实现方法参数名为“exception”；</p>
<p><strong>4）异常命名：</strong>returning=”exception”用于将目标方法抛出的异常赋值给通知实现方法参数名为“exception”的参数上。</p>
<p> <strong>四、后置最终通知：</strong>在切入点选择的方法返回时执行，不管是正常返回还是抛出异常都执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterFinally</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterFinally(..))”匹配目标方法sayAfterFinally，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=” afterFinallyAdvice “指定后置最终通知实现方法。</p>
<p> <strong>五、环绕通知：</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值，可通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:around &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型，在通知实现方法内部使用ProceedingJoinPoint的proceed()方法使目标方法执行，proceed 方法可以传入可选的Object[]数组，该数组的值将被作为目标方法执行时的参数。</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"============around param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.zero..*.sayAround(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">"aroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAroundAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAround(<span class="string">"haha"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ===========================</p>
<p>======================around before advice</p>
<p>============around param:replace</p>
<p>===========around after advice</p>
<p>====================================== </p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAround(..))”匹配目标方法sayAround；</p>
<p><strong>2）目标方法定义：</strong>使用method=”aroundAdvice”指定环绕通知实现方法，在该实现中，第一个方法参数为pjp，类型为ProceedingJoinPoint，其中“Object retVal = pjp.proceed(new Object[] {“replace”});”，用于执行目标方法，且目标方法参数被“new Object[] {“replace”}”替换，最后返回“retVal ”返回值。</p>
<p><strong>3）测试：</strong>我们使用“helloworldService.sayAround(“haha”);”传入参数为“haha”，但最终输出为“replace”，说明参数被替换了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);</span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);</span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​     Spring引入允许为目标对象引入新的接口，通过在&lt; aop:aspect&gt;标签内使用&lt; aop:declare-parents&gt;标签进行引入，定义方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">types-matching</span>=<span class="string">"AspectJ语法类型表达式"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">implement-interface</span>=<span class="string">引入的接口</span>"               </span></span><br><span class="line"><span class="tag">          <span class="attr">default-impl</span>=<span class="string">"引入接口的默认实现"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">delegate-ref</span>=<span class="string">"引入接口的默认实现Bean引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>types-matching：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；</p>
<p>​         <strong>implement-interface：</strong>定义需要引入的接口；</p>
<p>​         <strong>default-impl和delegate-ref：</strong>定义引入接口的默认实现，二者选一，default-impl是接口的默认实现类全限定名，而delegate-ref是默认的实现的委托Bean名；</p>
<p>接下来让我们练习一下吧：</p>
<p>​    首先定义引入的接口及默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroductiondService</span> <span class="keyword">implements</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========introduction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">"com.zero..*.IHelloWorldService+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">"com.zero.iin.IIntroductionService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">"com.zero.iin.IntroductiondService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后测试一下吧，测试代码cn.javass.spring.chapter6.AopTest：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaIntroduction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IIntroductionService introductionService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IIntroductionService.class);  </span><br><span class="line">    introductionService.induct();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> =========introduction</p>
<p> ======================================  </p>
<p> 分析一下吧：</p>
<p><strong>1）目标对象类型匹配：</strong>使用types-matching=”cn.javass..*.IHelloWorldService+”匹配IHelloWorldService接口的子类型，如HelloWorldService实现；</p>
<p><strong>2）引入接口定义：</strong>通过implement-interface属性表示引入的接口，如“cn.javass.spring.chapter6.service.IIntroductionService”。</p>
<p><strong>3）引入接口的实现：</strong>通过default-impl属性指定，如“cn.javass.spring.chapter6.service.impl.IntroductiondService”，也可以使用“delegate-ref”来指定实现的Bean。</p>
<p><strong>4）获取引入接口：</strong>如使用“ctx.getBean(“helloWorldService”, IIntroductionService.class);”可直接获取到引入的接口。</p>
<h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p> Advisor表示只有一个通知和一个切入点的切面，由于Spring AOP都是基于AOP联盟的拦截器模型的环绕通知的，所以引入Advisor来支持各种通知类型（如前置通知等5种），Advisor概念来自于Spring1.2对AOP的支持，在AspectJ中没有相应的概念对应。</p>
<p> Advisor可以使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>标签定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span> <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"通知API实现引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**二者选一，指定切入点表达式；</p>
<p>​         <strong>advice-ref：</strong>引用通知API实现Bean，如前置通知接口为MethodBeforeAdvice；</p>
<p> 接下来让我们看一下示例吧：</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三定义前置通知API实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceImpl</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在chapter6/advice.xml配置文件中先添加通知实现Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeAdvice"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.BeforeAdviceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，添加Advisor定义，添加时注意顺序：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..))"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAdvisor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">   IHelloWorldService helloworldService =  </span><br><span class="line">   ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">   helloworldService.sayAdvisorBefore(<span class="string">"haha"</span>);  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> ===========before advice</p>
<p> ============say haha</p>
<p> ======================================  </p>
<h3 id="基于-AspectJ的AOP"><a href="#基于-AspectJ的AOP" class="headerlink" title="基于@AspectJ的AOP"></a>基于@AspectJ的AOP</h3><p>​       Spring除了支持Schema方式配置AOP，还支持注解方式：使用@AspectJ风格的切面声明。</p>
<h4 id="启用对-AspectJ的支持"><a href="#启用对-AspectJ的支持" class="headerlink" title="启用对@AspectJ的支持"></a>启用对@AspectJ的支持</h4><p>Spring默认不支持@AspectJ风格的切面声明，为了支持需要使用如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样Spring就能发现@AspectJ风格的切面并且将切面应用到目标对象。</p>
<h4 id="声明切面-1"><a href="#声明切面-1" class="headerlink" title="声明切面"></a>声明切面</h4><p>​       @AspectJ风格的声明切面非常简单，使用@Aspect注解进行声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>()  </span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span></span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       然后将该切面在配置文件中声明为Bean后，Spring就能自动识别并进行AOP方面的配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"……Aspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       该切面就是一个POJO，可以在该切面中进行切入点及通知定义，接着往下看吧。</p>
<h4 id="声明切入点-1"><a href="#声明切入点-1" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​       @AspectJ风格的命名切入点使用org.aspectj.lang.annotation包下的@Pointcut+方法（方法必须是返回void类型）实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"切入点表达式"</span>, argNames = <span class="string">"参数名列表"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutName</span><span class="params">(……)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式；</p>
<p>​       <strong>argNames：</strong>指定命名切入点方法参数列表参数名字，可以有多个用“，”分隔，这些参数将传递给通知方法同名的参数，同时比如切入点表达式“args(param)”将匹配参数类型为命名切入点方法同名参数指定的参数类型。</p>
<p>​       <strong>pointcutName：</strong>切入点名字，可以使用该名字进行引用该切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个切入点，名字为“beforePointcut”，该切入点将匹配目标方法的第一个参数类型为通知方法实现中参数名为“param”的参数类型。</p>
<h4 id="声明通知-1"><a href="#声明通知-1" class="headerlink" title="声明通知"></a>声明通知</h4><p>​       @AspectJ风格的声明通知也支持5种通知类型：</p>
<p> <strong>一、前置通知：</strong>使用org.aspectj.lang.annotation 包下的@Before注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"切入点表达式或命名切入点"</span>, argNames = <span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义。</p>
<p>接下来示例一下吧：</p>
<p>1、定义接口和实现，在此我们就使用Schema风格时的定义；</p>
<p>2、定义切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;  </span><br><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect2</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义切入点：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义通知：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"beforePointcut(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在chapter6/advice2.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">            </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span>  </span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect2"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6、测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationBeforeAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice2.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<p> ==========================================</p>
<p> ===========before advice param:before</p>
<p> ============say before</p>
<p> ==========================================  </p>
<p>切面、切入点、通知全部使用注解完成：</p>
<p>​       1）使用@Aspect将POJO声明为切面；</p>
<p>​       2）使用@Pointcut进行命名切入点声明，同时指定目标方法第一个参数类型必须是java.lang.String，对于其他匹配的方法但参数类型不一致的将也是不匹配的，通过argNames = “param”指定了将把该匹配的目标方法参数传递给通知同名的参数上；</p>
<p>​       3）使用@Before进行前置通知声明，其中value用于定义切入点表达式或引用命名切入点；</p>
<p>​       4）配置文件需要使用<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>来开启注解风格的@AspectJ支持；</p>
<p>​       5）需要将切面注册为Bean，如“aspect”Bean；</p>
<p>​       6）测试代码完全一样。</p>
<p><strong>二、后置返回通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterReturning注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">returning=<span class="string">"返回值对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argName：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>returning：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayBefore(..))"</span>,  </span><br><span class="line">    pointcut=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"retVal"</span>, returning=<span class="string">"retVal"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterReturningAdvice测试方法。</p>
<p> <strong>三、后置异常通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterThrowing注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">throwing=<span class="string">"异常对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>throwing：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"exception"</span>, throwing=<span class="string">"exception"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterThrowingAdvice测试方法。</p>
<p> <strong>四、后置最终通知：</strong>使用org.aspectj.lang.annotation 包下的@After注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* cn.javass..*.sayAfterFinally(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after finally advice"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterFinallyAdvice测试方法。 </p>
<p><strong>五、环绕通知：</strong>使用org.aspectj.lang.annotation 包下的@Around注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value=<span class="string">"execution(* cn.javass..*.sayAround(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的annotationAroundAdviceTest测试方法。 </p>
<h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>​       @AspectJ风格的引入声明在切面中使用org.aspectj.lang.annotation包下的@DeclareParents声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">value=<span class="string">" AspectJ语法类型表达式"</span>,  </span><br><span class="line">defaultImpl=引入接口的默认实现类)  </span><br><span class="line"><span class="keyword">private</span> Interface <span class="class"><span class="keyword">interface</span></span>;</span><br></pre></td></tr></table></figure>
<p> <strong>value：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；与Schema方式中的types-matching属性同义；</p>
<p>​       private Interface interface<strong>：</strong>指定需要引入的接口；</p>
<p>​       defaultImpl<strong>：</strong>指定引入接口的默认实现类，没有与Schema方式中的delegate-ref属性同义的定义方式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">    value=<span class="string">"cn.javass..*.IHelloWorldService+"</span>, defaultImpl=cn.javass.spring.chapter6.service.impl.IntroductiondService.class)  </span><br><span class="line"><span class="keyword">private</span> IIntroductionService introductionService;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationIntroduction测试方法。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bill">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Bill">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bill">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Bill</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/LeetCode/" itemprop="url">LeetCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>## </p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>206    反向链表</li>
</ul>
<p>141，21，19，876</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>20,155,232,844,224,682,496</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Java基础/" itemprop="url">Java Base</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Base/" itemprop="url" rel="index">
                    <span itemprop="name">Base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java中的参数"><a href="#Java中的参数" class="headerlink" title="Java中的参数"></a>Java中的参数</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p><strong>在实例化类的时候指明泛型的具体类型</strong></p>
<p><strong><code>类型的参数化，可以把类型像方法的参数那样传递。</code></strong></p>
<p>优点：<strong><code>泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。如果我们在对一个对象赋值不符合其泛型的规范，就会编译报错</code></strong></p>
<p>1、代码重用：我们可以编写一个方法/类/接口，并用于我们想要的任何类型。</p>
<p>2、类型安全：泛型使错误显示在编译时而不是在运行时</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Simple Java program to demonstrate that NOT using </span></span><br><span class="line"><span class="comment">// generics can cause run time exceptions </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creatinga an ArrayList without any type specified </span></span><br><span class="line">        ArrayList al = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">        al.add(<span class="number">10</span>); <span class="comment">// Compiler allows this </span></span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Causes Runtime Exception </span></span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只有在运行时才会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p><strong>类型转换异常</strong></p>
<p><strong>泛型如何解决这个问题？</strong></p>
<p>在定义ArrayList时，我们可以指定此列表只能使用String对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creating a an ArrayList with String specified </span></span><br><span class="line">        ArrayList &lt;String&gt; al = <span class="keyword">new</span> ArrayList&lt;String&gt; (); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Now Compiler doesn't allow this </span></span><br><span class="line">        al.add(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、不需要单独类型转换：如果我们不使用泛型，那么，在上面的例子中，每次我们从ArrayList检索数据时，我们必须对它进行强制类型转换，而且还要自己检查是否是String类型，否则就会报错，因为从List中取出元素时，其类型会默认为Object。在每次检索操作中进行类型转换都是一个令人头痛的问 如果我们已经知道我们的列表只包含字符串数据，那么我们不需要每次都对它进行类型转换。</p>
<p>4、实现通用算法：通过使用泛型，我们可以实现适用于不同类型对象的算法，同时它们也是类型安全的。</p>
<p>5、有界泛型</p>
<p><strong><em>在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Animal&gt;<span class="comment">//限定T是Animal的子类</span></span><br><span class="line"></span><br><span class="line">&lt;T <span class="keyword">super</span> Dog &gt;<span class="comment">//限定T是Dog的超类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killAll</span><span class="params">(ArrayList&lt;T extends Animal&gt; animals)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>多个限定时我们可以使用&amp;来进行分割，这时关键词只能使用extends。与多重继承类似，这里只可以有一个类，其他都是接口。</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Object&amp;Comparable&amp;Serializable&gt;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p><strong>在调用方法的时候指明泛型的具体类型</strong></p>
<p><code>定义泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958544-ba9ac600-87d5-11e9-9473-ea75ecb5077f.png" alt=""></p>
<p><code>调用泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958730-25e49800-87d6-11e9-9619-7774468f4e20.png" alt=""></p>
<p>​       <strong>说明一下，定义泛型方法时，必须在返回值前边加一个<t>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。</t></strong></p>
<p>​       Class<t>的作用就是指明泛型的具体类型，而Class<t>类型的变量c，可以用来创建泛型类的对象。</t></t></p>
<p>​       为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>​       泛型方法要求的参数是Class<t>类型，而Class.forName()方法的返回值也是Class<t>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<t>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<user>类型的对象，因此调用泛型方法时，变量c的类型就是Class<user>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</user></user></t></t></t></p>
<p>​       当然，泛型方法不是仅仅可以有一个参数Class<t>，可以根据需要添加其他参数。</t></p>
<p>​       为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h2 id="Java数据结构应用"><a href="#Java数据结构应用" class="headerlink" title="Java数据结构应用"></a>Java数据结构应用</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList()方法"></a>subList()方法</h4><p>截取list的一段，但是如果对这一段做了修改，那么原来的list也会发生相应的变化。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>定义：</strong>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p><strong>简单定义：</strong>有一个或多个抽象方法的类，必须声明为抽象类。不能创建实例</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="为啥用抽象类"><a href="#为啥用抽象类" class="headerlink" title="为啥用抽象类"></a>为啥用抽象类</h3><ol>
<li>父类中的方法确实没有必要写(通用方法)，当然可以用类的覆盖，但是没有必要</li>
<li>各个子类中的这个方法肯定会不同</li>
<li>抽象方法有提示作用</li>
<li>发现共性，向上抽取。方法功能声明相同，但是方法功能主体不同。</li>
</ol>
<p>总结：</p>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法(用static修饰的方法)不能声明为抽象方法</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li>
<li>具体派生类必须覆盖基类的抽象方法</li>
<li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</li>
</ol>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>线程不安全就意味着线程的调度顺序会影响最终结果</p>
</li>
<li><p>线程安全的优先级高于性能</p>
</li>
<li>进程是程序向操作系统申请资源的基本单位。线程(Thread)是进程中可独立执行的最小单位。</li>
<li>一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。进程与线程之间的关系，好比一个营业中的饭店与其正在工作的员工之间的关系。</li>
</ul>
<p><strong>总结涉及到多线程的内容：</strong></p>
<ul>
<li>扎好马步：线程的状态</li>
<li>内功心法：每个对象都有的方法（机制）</li>
<li>太祖长拳：基本线程类</li>
<li>九阴真经：高级多线程控制类</li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://user-images.githubusercontent.com/24977343/65651829-3b5e2600-e042-11e9-9cd3-b3c98492a75b.png" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/24977343/65651887-634d8980-e042-11e9-94d0-7170924c22e0.png" alt=""></p>
<ul>
<li>Runnable :可运行</li>
<li>Running：运行中</li>
<li>Blocked ： 阻塞</li>
<li>Dead ： 结束</li>
</ul>
<p>实现多线程的三种方式：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runable接口</li>
<li>实现Callable接口</li>
</ul>
<h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><h3 id="进程、线程与任务"><a href="#进程、线程与任务" class="headerlink" title="进程、线程与任务"></a>进程、线程与任务</h3><ul>
<li>进程是程序向操作系统申请资源(如内存空间和文件句柄)的基本单位，是程序运行的实例。线程(Thread)是进程中可独立执行的最小单位。运行一个Java程序的实质是启动一个Java虚拟机进程，也就是说一个运行的Java程序的实质是启动一个Java虚拟机进程。</li>
<li>可以运行一个以上线程的程序称为多线程程序(multithreaded)</li>
<li>多进程和多线程的本质区别：每个进程拥有自己的一整套变量，而线程则共享数据。有风险，但是线程通信比进程更有效、容易、更轻量级；创建、撤销一个线程比启动新进程的开销要小得多。</li>
</ul>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>使用线程给其他任务提供机会</p>
<p>Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或</p>
<h4 id="线程的层次关系"><a href="#线程的层次关系" class="headerlink" title="线程的层次关系"></a>线程的层次关系</h4><ul>
<li>一个线程是否是一个守护线程默认取决于其父线程；默认父线程是守护线程，则子线程也是守护线程。父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon方法，将相应的线程设置为守护线程(或者用户线程)。</li>
<li>程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。</li>
<li>如果没有设置一个线程的优先级，那么这个线程优先级默认与父线程的优先级值相等。</li>
<li>Java平台中并没有API用于获取一个线程的父线程或者一个线程的所有子线程。</li>
<li>父线程与子线程的生命周期没有必然联系。</li>
</ul>
<h4 id="线程的生命周期状态"><a href="#线程的生命周期状态" class="headerlink" title="线程的生命周期状态"></a>线程的生命周期状态</h4><p>​    一个线程从</p>
<p><img src="https://user-images.githubusercontent.com/24977343/67002732-1b84c400-f10f-11e9-8606-f1dd7c05ad72.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Spring-MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Spring-MVC/" itemprop="url">Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SpringMVC的注解"><a href="#SpringMVC的注解" class="headerlink" title="SpringMVC的注解"></a>SpringMVC的注解</h3><ol>
<li>@ModelAttribute</li>
</ol>
<p>大致有两种使用方式，一种是直接标记在方法上，一种是标记在方法的参数中，两种标记方法产生的效果也各不相同。</p>
<ul>
<li>注解放在方法上面</li>
</ul>
<p>当同一个controller中有任意一个方法被@ModelAttribute注解标记，页面请求只要进入这个控制器，不管请求那个方法，均会先执行被@ModelAttribute标记的方法，所以我们可以用@ModelAttribute注解的方法做一些初始化操作。当同一个controller中有多个方法被@ModelAttribute注解标记，所有被@ModelAttribute标记的方法均会被执行，按先后顺序执行，然后再进入请求的方法。</p>
<p>​    </p>
<p>下面方法做一些变形，变形为带有参数的返回，这样也是实际开发中经常会操作的 </p>
<p>首先创建一个pojo对象，对象包含name，sex两个属性。并对JSP及控制器代码做一些修改</p>
<p>页面首先使用EL表达式接收返回参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span> + request.getServerName() + <span class="string">":"</span> + request.getServerPort() + path + <span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>, function () &#123;</span><br><span class="line"></span><br><span class="line">                window.location.href = <span class="string">"&lt;%=basePath%&gt;model/modelTest.do"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.name &#125;"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>@ModelAtterbute方法无返回值情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="keyword">null</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问ModelTest.jsp页面并点击测试</p>
<p> <img src="https://img-blog.csdn.net/20170225235700722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从执行结果看出，当访问请求时，会首先访问init方法，然后再对modelTest方法进行访问，并且是同一个请求，因为model模型数据的作用域与request相同，所以可以用此标记直接标记在方法上对实际要访问的方法进行一些初始化操作</p>
<ul>
<li>@ModelAttribute标记方法有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入init方法"</span>);</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"model/befor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"befor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">befor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入befor方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里稍微做了点变形，可以看到在被@ModelAttribute方法中设值了返回路径为befor方法，但是在在代码运行的过程中并不会跳转befor方法，而是在代码执行完成return之前直接跳转了实际请求的方法。不执行return</p>
<p> 进入init方法<br>进入modelTest方法</p>
<ul>
<li><p>当@RequestMapping标记和@ModelAttribute同时标记在一个方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试页面发现进入控制器后返回，页面报404，这是因为当两个注解标记到同一个方法上时，逻辑视图名并不是返回值，而是返回请求的路径，根据model/modelTest.do生成逻辑视图。在这里我们修改下代码，把controller上的@RequestMapping标记去掉，并修改下页面的请求路径，让生成的视图路径和访问的页面路径相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(function()&#123;</span><br><span class="line">           $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">  </span><br><span class="line">               window.location.href=<span class="string">"&lt;%=basePath%&gt;modelTest.do"</span>;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo &#125;"</span>&gt;</span><br><span class="line">  </span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>点击测试页面，会发现当两个注解同时注解到一个方法上时，方法的返回值会变成model模型的返回值，key是标记的名</p>
<h4 id="ModelAttribute标记在参数前"><a href="#ModelAttribute标记在参数前" class="headerlink" title="@ModelAttribute标记在参数前"></a>@ModelAttribute标记在参数前</h4><p>从from表单或url地址中取值，这里就以url地址为例，为了避免url地址中文乱码问题，这里调用了encodeURL函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line"></span><br><span class="line">                window.location.href=<span class="string">"&lt;%=basePath%&gt;model/modelTest.do?userName="</span>+encodeURI(<span class="string">'小明'</span>)+<span class="string">"&amp;sex="</span>+encodeURI(<span class="string">'男'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.userName &#125;"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pojo.setUserName(<span class="keyword">new</span> String(pojo.getUserName().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">            pojo.setSex(<span class="keyword">new</span> String(pojo.getSex().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击页面测试，页面文本框会显示URL地址传递过来的参数，因为SpringMVC会自动匹匹配页面传递过来的参数的name属性和后台控制器中的方法中的参数名，如果参数名相同，会自动匹配，如果控制器中方法是封装的bean,会自动匹配bean中的属性，其实这种取值方式不需要用@ModelAttribute注解，只要满足匹配要求，也能拿得到值</p>
<p> <img src="https://img-blog.csdn.net/20170226011711946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从model对象中取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PojoTest <span class="title">init</span><span class="params">( PojoTest pojo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setSex(<span class="string">"男"</span>);</span><br><span class="line">        <span class="keyword">return</span> pojo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setUserName(<span class="string">"小明"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试发现，modelTest拿到inint方法中的pojo对象，合并两次set的参数后返回页面</p>
</li>
</ul>
<p>   <img src="https://img-blog.csdn.net/20170226023308348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/FastDfs分布式文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/FastDfs分布式文件系统/" itemprop="url">FastDFS 分布式文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T10:40:45+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="FastDfs简介"><a href="#FastDfs简介" class="headerlink" title="FastDfs简介"></a>FastDfs简介</h3><ol>
<li>FastDfs是一个轻量级的开源分布式文件系统</li>
<li>FastDfs主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>
<li>FastDfs实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>
<li>支持存储服务器在线扩容</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>
<li><p>FastDFS特别适合大中型网站使用，用来存储资源文件(如：图片、文档、音频、视频等等)</p>
<p>  FastDFS是一个开源的轻量级分布式文件系统，她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。  </p>
</li>
</ol>
<p>FastDFS服务端有两个角色：<strong>跟踪器(tracker)</strong>和<strong>存储节点(storage)</strong>。跟踪器主要做调度工作，在访问上起负载均衡 的作用。</p>
<h4 id="Tracker"><a href="#Tracker" class="headerlink" title="Tracker"></a>Tracker</h4><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%BC%95%E5%85%A5Tracker.jpg?raw=true" alt=""></p>
<p>Group之间是相互独立的，Group内是相互备份的；Tracker之间也是相互独立的。</p>
<ul>
<li><p>Group之间 相互独立</p>
</li>
<li><p>同一Group内的Storage Server 之间需要互相备份</p>
<p>文件存放到一个Storage以后，需要备份到别的服务器</p>
</li>
<li><p>Tracker之间是不交互的</p>
<ul>
<li>每个storage server都需要向所有Tracker去主动报告信息</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ol>
<li>group内的server内容都是一致的</li>
<li>一个负责跟踪一个负责存储</li>
<li>group会向每个tracker都汇报，tracker存储的信息很少</li>
</ol>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg?raw=true" alt=""></p>
<h4 id="选定Tracker-Server"><a href="#选定Tracker-Server" class="headerlink" title="选定Tracker Server"></a>选定Tracker Server</h4><ul>
<li>Tracker Server不止一个，客户端选择哪一个做上传文件？</li>
</ul>
<p>Client是如何知道上传到那个Tracker Server</p>
<p>Client可以维护一个Tracker列表</p>
<ul>
<li>Tracker如何选择Group？(三种策略)<ul>
<li>round robin(轮询)</li>
<li>load balance(选择最大剩余空间的组上传文件)</li>
<li>specify group(指定group上传)</li>
</ul>
</li>
</ul>
<h4 id="选定Storage-Server"><a href="#选定Storage-Server" class="headerlink" title="选定Storage Server"></a>选定Storage Server</h4><ul>
<li>一个组内有多个Storage Server ，选择哪一个？<ul>
<li><ol>
<li>Round robin，所有server轮询使用(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>根据IP地址进行排序选择第一个服务器(IP地址最小者)</li>
</ol>
</li>
<li><ol start="3">
<li>根据优先级进行排序(上传优先级由storage server来设置，参数为upload_priority)</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%20%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" alt=""></p>
<h4 id="选择storage-path"><a href="#选择storage-path" class="headerlink" title="选择storage path"></a>选择storage path</h4><ul>
<li>如何选择storage path(虚拟磁盘目录M00，M01路径)<ul>
<li><ol>
<li>round robin ，轮询(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>load balance，选择使用剩余空间最大的存储路径</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>目录和文件</p>
<ul>
<li>选定存放目录？<ul>
<li>storage会生成一个file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg)，采用Base64编码，file_id包含字段包括：storage server_ip(文件的源服务器)、文件创建时间、文件大小、文件CRC32校验码和随机数、；(这个时候文件名已经和最早的文件名是两回事儿了)</li>
<li>每个存储目录下有两个256*256个子目录，storage 会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为文件名存储到该子目录下</li>
</ul>
</li>
</ul>
<p>Group1/M00/00/OC/wKjGgVgbV2-ABdo-AAAAHw.jpg   </p>
<p>tracker可以通过上面的东西迅速的找到文件</p>
<p><strong>要点：</strong></p>
<ul>
<li>server之间不分主从，每个目录可以不止放一个文件</li>
<li>存储服务器启动的时候就会把两个256*256个目录一次创建出来</li>
<li>file_id必须由client来保存。</li>
</ul>
<p>怎么确定存放在那个目录</p>
<p>storage会按照文件的file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg   )做两次hash算法，路由到其中一个子目录中。</p>
<h4 id="Storage-Server之间的文件同步"><a href="#Storage-Server之间的文件同步" class="headerlink" title="Storage Server之间的文件同步"></a>Storage Server之间的文件同步</h4><ul>
<li>同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；</li>
<li>文件同步只在组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器；</li>
<li>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</li>
<li>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一套storage server将已有的所有数据(包括源头数据和备份数据)同步给新增服务器</li>
</ul>
<p>client是FastDFS提供的客户端</p>
<p>FastDFS有覆盖方法，可以修改某个已经上传的文件，甚至是追加操作。</p>
<p>例子：</p>
<p>A，B，C三个服务器在同一个组中</p>
<ul>
<li>9:30用户向服务器A上传了一个文件X(文件创建时间9:30)</li>
<li>9:31用户向服务器B上传了一个文件Y(文件创建时间9:31)</li>
<li>9:32用户向服务器A上传了一个文件Z(文件创建时间9:32)</li>
</ul>
<p>A向B，C同步文件X，并且向Tracker Server汇报</p>
<ul>
<li>我向B同步了X(文件创建时间9:30)</li>
<li>我向C同步了X(文件创建时间9:30)</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A52.jpg?raw=true" alt=""></p>
<p>通过文件名都可以取到创建时间和源服务器地址</p>
<p>这个时候下载文件Y，tracker会去那个服务器上面寻找呢?</p>
<p>这个时候可以直接从B中下载，如果这个时候B宕机了，只有和A或C中找，查tracker中的表时，B–&gt;A在9：31前的都同步了，就去A中找。如果A也宕机了，就去C中找，看这个时间前的是否同步。</p>
<p>tracker不需要保存左侧的信息，根据文件名就可以了。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A53.jpg?raw=true" alt=""></p>
<p>这个时候假设用户想下载文件Z，就去源服务器下载，如果源服务器宕机，就去其他服务器下载。根据时间判断是否在这个时间前的同步了，如果同步了就下载，如果没有就下载。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A54.jpg?raw=true" alt=""></p>
<p>当试图下载文件的时候，根据文件名拿到创建时间和服务器，根据时间来判断是否可以下载。</p>
<p>FastDFS文件同步方式</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F.jpg?raw=true" alt=""></p>
<p>最后最早同步时间，</p>
<p>对于服务器A来讲，服务器B向他同步的时间是9:31,服务器C是9:33.计算最后的时间，那么根据上图。</p>
<p>对服务器A，它的最早同步时间是9:31</p>
<p>对服务器B，它的最早同步时间是9:32</p>
<p><strong>取最小值，然后直接和最小值进行比对。</strong></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%9C%80%E5%90%8E%E6%9C%80%E6%97%A9%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4.jpg?raw=true" alt=""></p>
<p>X可以从三个服务器下载</p>
<p>Y可以从A和B服务器下载，C不行。</p>
<p>Z可以从源服务器A下载，或者服务器B下载,C不行</p>
<p>W只能从服务器C这个源服务器下载，虽然根据时间判断C已经将9:33前的同步到了A和B这两个服务器，但是根据规则，它不能去A和B下载。</p>
<p>虽然简单，但是会牺牲一下。</p>
<p>选择一个可供下载的Storage Server策略</p>
<ul>
<li>该文件上传到源Storage server(文件直接上传到该服务器上的)</li>
<li>文件创建时间戳&lt;Storage server被同步到的文件时间戳，这意味着当前文件已经被同步过来了；</li>
<li>文件创建时间戳=Storage server被同步到的文件时间戳，且(当前时间-文件创建时间戳)&gt;一个文件同步完成需要的最大时间(如5分钟);</li>
<li>(当前时间-文件创建时间戳)&gt;文件同步延迟阈值，比如我们把阈值设置为1天，表示文件同步在一天内肯定可以完成</li>
</ul>
<p>当走到第四个的时候可能已经出问题了。</p>
<p>tracker定位一个组中的server</p>
<h3 id="FastDFS的使用"><a href="#FastDFS的使用" class="headerlink" title="FastDFS的使用"></a>FastDFS的使用</h3><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8.jpg?raw=true" alt=""></p>
<p>这里的FastDFSAPI可以当做client</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8Cnagix%E9%9B%86%E6%88%90.jpg?raw=true" alt=""></p>
<p>上图这种就是</p>
<p>如果上传的话还是走Nginx，到应用服务器</p>
<p>如果下载的时候，直接通过Nginx，直接到FastDFS，模块和Nginx集成。绕过应用服务器</p>
<p>要点：</p>
<ul>
<li>Tracker server内部没有数据库，要么是内存要么是纯文件，文件格式自己定义</li>
</ul>
<h3 id="防止盗链"><a href="#防止盗链" class="headerlink" title="防止盗链"></a>防止盗链</h3><ul>
<li>辛苦上传的文件不想被人盗取</li>
<li>给URL增加token<ul>
<li>Token只有自己的网站才能生成</li>
<li>Token会过期</li>
</ul>
</li>
</ul>
<p>refer</p>
<h4 id="防止盗链的配置"><a href="#防止盗链的配置" class="headerlink" title="防止盗链的配置"></a>防止盗链的配置</h4><p>是否做token检查，缺省为false</p>
<p>http.anti_steal.check_token=true</p>
<p>即生成token的有效时长 秒</p>
<p>http.anti_steal.token_ttl=900</p>
<p>生成token的密钥，尽量设置得长一些</p>
<p>http.anti_steal.secret<em>key=@#%*&amp;$)87)</em>+$%!~</p>
<p>Token = md5(文件名，密钥，时间戳)</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E9%98%B2%E6%AD%A2%E7%9B%97%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE.jpg?raw=true" alt=""></p>
<p>将文件名、密钥和时间戳的组合通过md5加密传给token</p>
<p>token是在服务器端生成</p>
<p>客户端下载文件的时候，除了传fileid以外还需要token</p>
<p>客户端发送的是fileid，服务器端返回的是一个token</p>
<h4 id="合并存储"><a href="#合并存储" class="headerlink" title="合并存储"></a>合并存储</h4><ul>
<li>海量小文件的缺点<ul>
<li>元数据管理低效，磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上</li>
<li>数据存储分散</li>
<li>磁盘的大量随机访问降低效率</li>
</ul>
</li>
<li>FastDFS提供的合并存储功能<ul>
<li>默认大文件64M</li>
<li>每个文件空间称为slot(256bytes&lt;=slot&lt;=16MB)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%B2%A1%E6%9C%89%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6ID.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6.jpg?raw=true" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>FastDFS是穷人的解决方案</li>
<li>FastDFS把简洁和高效做到了极致，非常节约资源，中小网站完全用的起</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-集成Hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-集成Hibernate3/" itemprop="url">Spring--集成Hibernate3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T17:26:07+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E9%95%BF%E9%A2%88%E9%B9%BF.jpg?raw=true" alt=""></p>
<h3 id="集成Hibernate3"><a href="#集成Hibernate3" class="headerlink" title="集成Hibernate3"></a>集成Hibernate3</h3><p>​       Hibernate是全自动的ORM框架，能自动为对象生成相应SQL并透明的持久化对象到数据库。</p>
<p> <strong>Spring2.5+版本支持Hibernate 3.1+版本，不支持低版本，Spring3.0.5版本提供对Hibernate 3.6.0 Final版本支持。</strong></p>
<h4 id="如何集成"><a href="#如何集成" class="headerlink" title="如何集成"></a>如何集成</h4><p>Spring通过使用如下Bean进行集成Hibernate：</p>
<ul>
<li>LocalSessionFactoryBean ：用于支持XML映射定义读取：</li>
<li>configLocation和configLocations：用于定义Hibernate配置文件位置，一般使用classpath:hibernate.cfg.xml形式指定；</li>
<li>mappingLocations：用于指定Hibernate映射文件位置，如chapter8/hbm/user.hbm.xml;</li>
<li>hibernateProperties：用于定义Hibernate属性，即Hibernate配置文件中的属性；</li>
<li>dataSource：定义数据源；</li>
<li>hibernateProperties、dataSource用于消除Hibernate配置文件，因此如果使用configLocations指定配置文件，就不要设置这两个属性了，否则会产生重复配置。推荐使用dataSource来指定数据源，而使用hibernateProperties指定Hibernate属性。</li>
<li>AnnotationSessionFactoryBean：用于支持注解风格映射定义读取，该类继承LocalSessionFactoryBean并额外提供自动查找注解风格配置模型的能力；</li>
<li>AnnotatedClasses：设置注解了模型类，通过注解指定映射元数据。</li>
<li>packagesToScan：通过扫码指定的包获取注解模型类，而不是手工指定，如”com.zero.**.model”将扫码com.zero包及子包下的model包下所有注解模型类。</li>
</ul>
<p>接下来学习一下Spring如何继承Hibernate吧；</p>
<p><strong>1、准备jar包：</strong></p>
<p>首先准备Spring对ORM框架支持的jar包：</p>
<p>org.springframework.orm-3.0.5.RELEASE.jar      //提供对ORM框架集成</p>
<p>下载hibernate-distribution-3.6.0.Final包，获取如下Hibernate需要的jar包：</p>
<p>hibernate3.jar        //核心包</p>
<p>lib\required\antlr-2.7.6.jar        //HQL解析时使用的包</p>
<p>lib\required\javassist-3.9.0.GA.jar        //字节码类库，类似与cglib</p>
<p>lib\required\commons-collections-3.1.jar  //对集合类型支持包，前边测试时已经提供过了，无需再拷贝该包了</p>
<p>lib\required\dom4j-1.6.1.jar            //xml解析包，用于解析配置使用</p>
<p>lib\required\jta-1.1.jar                 //JTA事务支持包</p>
<p>lib\jpa\hibernate-jpa-2.0-api-1.0.0.Final.jar //用于支持JPA</p>
<p> 下载slf4j-1.6.1.zip（<a href="http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple" target="_blank" rel="noopener">http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple</a> Logging Facade for Java），用于对各种日志框架提供给一致的日志访问接口，从而能随时替换日志框架（如log4j、java.util.logging）：</p>
<p>将这些jar包添加到类路径中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-JDBC/" itemprop="url">Spring-JDBC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T15:02:23+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E8%A9%B9%E5%A7%86%E6%96%AF.jpg?raw=true" alt=""></p>
<p>抄自开涛博客   <a href="http://jinnianshilongnian.iteye.com/blog/1423896" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1423896</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h4><p>​       传统应用程序开发中，进行JDBC编程是相当痛苦的，如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cn.javass.spring.chapter7. TraditionalJdbcTest  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">    PreparedStatement pstmt = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      conn = getConnection();              <span class="comment">//1.获取JDBC连接  </span></span><br><span class="line">                                       <span class="comment">//2.声明SQL  </span></span><br><span class="line">      String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;  </span><br><span class="line">      pstmt = conn.prepareStatement(sql);    <span class="comment">//3.预编译SQL  </span></span><br><span class="line">      ResultSet rs = pstmt.executeQuery();   <span class="comment">//4.执行SQL  </span></span><br><span class="line">      process(rs);                       <span class="comment">//5.处理结果集  </span></span><br><span class="line">      closeResultSet(rs);                 <span class="comment">//5.释放结果集  </span></span><br><span class="line">      closeStatement(pstmt);              <span class="comment">//6.释放Statement  </span></span><br><span class="line">      conn.commit();                    <span class="comment">//8.提交事务  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">      <span class="comment">//9.处理异常并回滚事务  </span></span><br><span class="line">      conn.rollback();  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      <span class="comment">//10.释放JDBC连接，防止JDBC连接不关闭造成的内存泄漏  </span></span><br><span class="line">      closeConnection(conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       以上代码片段具有冗长、重复、容易忘记某一步骤从而导致出错、显示控制事务、显示处理受检查异常等等。</p>
<p>​        有朋友可能重构出自己的一套JDBC模板，从而能简化日常开发，但自己开发的JDBC模板不够通用，而且对于每一套JDBC模板实现都差不多，从而导致开发人员必须掌握每一套模板。</p>
<p>​        Spring JDBC提供了一套JDBC抽象框架，用于简化JDBC开发，而且如果各个公司都使用该抽象框架，开发人员首先减少了学习成本，直接上手开发，如图7-1所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JDBC.JPG?raw=true" alt=""></p>
<p>图7-1 Spring JDBC与传统JDBC编程对比</p>
<h4 id="Spring对JDBC的支持"><a href="#Spring对JDBC的支持" class="headerlink" title="Spring对JDBC的支持"></a>Spring对JDBC的支持</h4><p>​       Spring通过抽象JDBC访问并提供一致的API来简化JDBC编程的工作量。我们只需要<strong>声明SQL、调用合适的Spring JDBC框架API、处理结果集</strong>即可。事务由Spring管理，并将JDBC受查异常转换为Spring一致的非受查异常，从而简化开发。</p>
<p>​        Spring主要提供<strong>JDBC模板方式、关系数据库对象化方式和SimpleJdbc</strong>方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p>
<ul>
<li><strong>JDBC模板方式：</strong>Spring JDBC 框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如Jdbc Template、NamedParameterJdbcTemplate、SimpleJdbcTemplate。 </li>
<li><strong>关系数据库对象化方式：</strong>Spring JDBC 框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoreProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li>
<li><strong>SimpleJdbc 方式</strong>：Spring JDBC框架还提供了<strong>SimpleJdbc 方式</strong>来简化JDBC编程，SimpleJdbcInsert、SimpleJdbcCall用来简化数据库表插入、存储过程或函数访问；</li>
</ul>
<p>Spring JDBC还提供了一些强大的工具类，如DataSourceUtils来在必要的时候手工获取数据库连接等。</p>
<h4 id="Spring的JDBC架构"><a href="#Spring的JDBC架构" class="headerlink" title="Spring的JDBC架构"></a>Spring的JDBC架构</h4><p>Spring JDBC抽象框架由四部分组成：datasource、support、core、object。如图7-2所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20JDBC%20%E6%9E%B6%E6%9E%84%E5%9B%BE.JPG?raw=true" alt=""></p>
<p>图7-2 Spring JDBC架构图</p>
<pre><code>**support包：**提供将JDBC异常转化为DAO非检查异常转换类、一些工具类如JdbcUtils等。
</code></pre><p>​    <strong>dataSource包：</strong>提供简化访问JDBC数据源(javax.sql.DataSource实现)工具类，并提供了一些    DataSource简单实现类从而能使从这些DataSource获取的连接能自动得到Spring管理事务支持。</p>
<p>​    <strong>coe包：</strong>提供JDBC模板类实现及可变部分的回调接口，还提供SimpleJdbcInsert等辅助类。</p>
<p>​    <strong>object包：</strong>提供关系数据库的对象表示形式，如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类，该包是基于core包JDBC模板类实现。</p>
<h3 id="JDBC模板类"><a href="#JDBC模板类" class="headerlink" title="JDBC模板类"></a>JDBC模板类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​       Spring JDBC抽象框架core包提供了JDBC模板类，其中JdbcTemplate是core包的核心类，所以其他模板类都是基于它封装完成的，JDBC模板类是第一种工作模式。</p>
<p>​        JdbcTemplate类通过模板设计模式帮助我们消除了冗长的代码，只做需要做的事情（即可变部分），并且帮我们做哪些固定部分，如连接的创建及关闭。</p>
<p>​        JdbcTemplate类对可变部分采用回调接口方式实现，如ConnectionCallback通过回调接口返回给用户一个连接，从而可以使用该连接做任何事情、StatementCallback通过回调接口返回给用户一个Statement，从而可以使用该Statement做任何事情等等，还有其他一些回调接口如图7-3所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JdbcTemplate%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3.JPG?raw=true" alt=""></p>
<p>图7-3 JdbcTemplate支持的回调接口</p>
<p> Spring除了提供JdbcTemplate核心类，还提供了基于JdbcTemplate实现的NamedParameterJdbcTemplate类用于支持命名参数绑定、 SimpleJdbcTemplate类用于支持Java5+的可变参数及自动装箱拆箱等特性。</p>
<h4 id="传统JDBC编程替代方案"><a href="#传统JDBC编程替代方案" class="headerlink" title="传统JDBC编程替代方案"></a>传统JDBC编程替代方案</h4><p>前边我们已经使用过传统JDBC编程方式，接下来让我们看下Spring JDBC框架提供的更好的解决方案。</p>
<p> 1）准备需要的jar包并添加到类路径中：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.springframework.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）传统JDBC编程替代方案：</p>
<p> 在使用JdbcTemplate模板类时必须通过DataSource获取数据库连接，Spring JDBC提供了DriverManagerDataSource实现，它通过包装“DriverManager.getConnection”获取数据库连接，具体DataSource相关请参考【7.5.1控制数据库连接】。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url=<span class="string">"jdbc:hsqldb:mem:test"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"123"</span>;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource(url,username,password);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"org.hsqldb.jdbcDriver"</span>);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、声明SQL</span></span><br><span class="line">        String sql=<span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//2.处理结果集</span></span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们具体分析一下：</p>
<p>1）  <strong>jdbc:hsqldb:mem:test：</strong>表示使用hsqldb内存数据库，数据库名为“test”。</p>
<p>2）  <strong>public static void setUpClass()：</strong>使用junit的@BeforeClass注解，表示在所以测试方法之前执行，且只执行一次。在此方法中定义了DataSource并使用DataSource对象创建了JdbcTemplate对象。JdbcTemplate对象是线程安全的。</p>
<p>3）  <strong>JdbcTemplate执行流程：</strong>首先定义SQL，其次调用JdbcTemplate方法执行SQL，最后通过RowCallbackHandler回调处理ResultSet结果集。</p>
<p>Spring JDBC解决方法相比传统JDBC编程方式是不是简单多了，是不是只有可变部分需要我们来做，其他的都由Spring JDBC框架来实现了。</p>
<p>接下来让我们深入JdbcTemplate及其扩展吧。</p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>​       首先让我们来看下如何使用JdbcTemplate来实现增删改查。</p>
<p> 一、首先创建表结构：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String createTableSql = <span class="string">"create memory table test"</span> + <span class="string">"(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "</span> + <span class="string">"name varchar(100))"</span>;</span><br><span class="line">    jdbcTemplate.update(createTableSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dropTableSql = <span class="string">"drop table test"</span>;</span><br><span class="line">    jdbcTemplate.execute(dropTableSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  org.junit包下的<strong>@Before和@After</strong>分别表示在测试方法之前和之后执行的方法，对于每个测试方法都将执行一次； </p>
<p>2）  <strong>create memory table test</strong>表示创建hsqldb内存表，包含两个字段id和name，其中id是具有自增功能的主键，如果有朋友对此不熟悉hsqldb可以换成熟悉的数据库。 </p>
<p>二、定义测试骨架，该测试方法将用于实现增删改查测试：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring-AOP/" itemprop="url">Spring--AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T16:21:43+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/4.jpg?raw=true" alt=""></p>
<h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>​       在进行AOP开发前，先熟悉几个概念：</p>
<ul>
<li><strong>连接点（Jointpoint）：</strong>表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，<strong>在AOP中表示为“在哪里干”</strong>；</li>
<li><strong>切入点（Pointcut）：</strong>选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，<strong>在AOP中表示为“在哪里干的集合”</strong>；</li>
<li><strong>通知（Advice）：</strong>在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；<strong>在AOP中表示为“干什么”；</strong></li>
<li><strong>方面/切面（Aspect）：</strong>横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；<strong>在AOP中表示为“在哪干和干什么集合”；</strong></li>
<li><strong>引入（inter-type declaration）：</strong>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, <strong>在AOP中表示为“干什么（引入什么）”</strong>；</li>
<li><strong>目标对象（Target Object）：</strong>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，<strong>在AOP中表示为“对谁干”</strong>；</li>
<li><strong>AOP代理（AOP Proxy）：</strong>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是<strong>通过代理来对目标对象应用切面</strong>。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li>
<li><p><strong>织入（Weaving）：</strong>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</p>
<p>在AOP中，通过切入点选择目标对象的连接点，然后在目标对象的相应连接点处织入通知，而切入点和通知就是切面（横切关注点），而在目标对象连接点处应用切面的实现方式是通过AOP代理对象，如图6-2所示。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/AOP%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.JPG?raw=true" alt=""></p>
</li>
</ul>
<p>图6-2 概念关系</p>
<p> 接下来再让我们具体看看Spring有哪些通知类型：</p>
<ul>
<li><strong>前置通知（Before Advice）:</strong>在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li>
<li><strong>后置通知（After Advice）:</strong>在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li>
<li><strong>后置返回通知(After returning Advice)：</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置异常通知(After throwing Advice):</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置最终通知(After finally Advice):</strong>在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java的finally块。</li>
<li><strong>环绕通知(Around Advice):</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li>
</ul>
<p>各种通知类型在UML序列图中的位置如图6-3所示:<br>   <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.JPG?raw=true" alt=""></p>
<p>图6-3 通知类型</p>
<h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>​       AOP代理就是AOP框架通过代理模式创建的对象，Spring使用JDK动态代理或CGLIB代理来实现，Spring缺省使用JDK动态代理来实现，从而任何接口都可别代理，如果被代理的对象实现不是接口将默认使用CGLIB代理，不过CGLIB代理当然也可应用到接口。</p>
<p>​        <strong>AOP代理的目的就是将切面织入到目标对象。</strong></p>
<p>​        概念都将完了，接下来让我们看一下AOP的 HelloWorld!吧。</p>
<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>​       首先准备开发需要的jar包，请到spring-framework-3.0.5.RELEASE-dependencies.zip和spring-framework-3.0.5.RELEASE-with-docs中查找如下jar包：</p>
<p>  org.springframework.aop-3.0.5.RELEASE.jar</p>
<p>  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</p>
<p>  com.springsource.org.aopalliance-1.0.0.jar</p>
<p>   com.springsource.net.sf.cglib-2.2.0.jar </p>
<h4 id="定义目标类"><a href="#定义目标类" class="headerlink" title="定义目标类"></a>定义目标类</h4><p>​       1）定义目标接口：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）定义目标接口实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注：在日常开发中最后将业务逻辑定义在一个专门的service包下，而实现定义在service包下的impl包中，服务接口以IXXXService形式，而服务实现就是XXXService，这就是规约设计，见名知义。当然可以使用公司内部更好的形式，只要大家都好理解就可以了。</p>
<h4 id="定义切面支持类"><a href="#定义切面支持类" class="headerlink" title="定义切面支持类"></a>定义切面支持类</h4><p>​       有了目标类，该定义切面了，切面就是通知和切入点的组合，而切面是通过配置方式定义的，因此这定义切面前，我们需要定义切面支持类，切面支持类提供了通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========after finally advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       此处HelloWorldAspect类不是真正的切面实现，只是定义了通知实现的类，在此我们可以把它看作就是缺少了切入点的切面。</p>
<p>​        注：对于AOP相关类最后专门放到一个包下，如“aop”包，因为AOP是动态织入的，所以如果某个目标类被AOP拦截了并应用了通知，可能很难发现这个通知实现在哪个包里，因此推荐使用规约命名，方便以后维护人员查找相应的AOP实现。</p>
<h4 id="在XML中进行配置"><a href="#在XML中进行配置" class="headerlink" title="在XML中进行配置"></a>在XML中进行配置</h4><p>有了通知实现，那就让我们来配置切面吧：</p>
<p>​       1）首先配置AOP需要aop命名空间，配置头如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       2）配置目标类：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       3）配置切面：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"helloWorldService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"aspect"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldAspect"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* com.zero.aop.*.*(..))"</span>/&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">"aspect"</span>&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"beforeAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">        &lt;aop:after pointcut=<span class="string">"execution(* com.zero.aop.*.*(..))"</span> method=<span class="string">"afterFinallyAdvice"</span>/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>​       切入点使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>配置，expression属性用于定义切入点模式，默认是AspectJ语法，“execution(<em> cn.javass..</em>.*(..))”表示匹配cn.javass包及子包下的任何方法执行。</p>
<p> 切面使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签配置，其中“ref”用来引用切面支持类的方法。</p>
<p> 前置通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签来定义，pointcut-ref属性用于引用切入点Bean，而method用来引用切面通知实现类中的方法，该方法就是通知实现，即在目标类方法执行之前调用的方法。</p>
<p> 最终通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签来定义，切入点除了使用pointcut-ref属性来引用已经存在的切入点，也可以使用pointcut属性来定义，如pointcut=”execution(<em> cn.javass..</em>.*(..))”，method属性同样是指定通知实现，即在目标类方法执行之后调用的方法。</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>测试类非常简单，调用被代理Bean跟调用普通Bean完全一样，Spring AOP将为目标对象创建AOP代理，具体测试代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop.xml"</span>);</span><br><span class="line">        IHelloWorldService helloworldService =</span><br><span class="line">                ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);</span><br><span class="line">        helloworldService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       该测试将输出如下如下内容：</p>
<p> ===========before advice<br>============Hello World!<br>===========after finally advice</p>
<p>​        从输出我们可以看出：前置通知在切入点选择的连接点（方法）之前允许，而后置通知将在连接点（方法）之后执行，具体生成AOP代理及执行过程如图6-4所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20AOP%E6%A1%86%E6%9E%B6%E7%94%9F%E6%88%90AOP%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.JPG?raw=true" alt=""></p>
<p> 图6-4 Spring AOP框架生成AOP代理过程</p>
<h3 id="基于Schema的AOP"><a href="#基于Schema的AOP" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h3><h4 id="基于Schema的AOP-1"><a href="#基于Schema的AOP-1" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h4><p>​     基于Schema的AOP从Spring2.0之后通过“aop”命名空间来定义切面、切入点及声明通知。</p>
<p> 在Spring配置文件中，所有AOP相关定义必须放在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，该标签下可以有<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>、<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>、<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签，配置顺序不可变。 </p>
<ul>
<li><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>：用来定义切入点，该切入点可以重用；</li>
<li><a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>：用来定义只有一个通知和一个切入点的切面；</li>
<li><p><a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，advisor只包含一个通知和一个切入点。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/aop-schema.JPG?raw=true" alt=""></p>
</li>
</ul>
<h4 id="声明切面"><a href="#声明切面" class="headerlink" title="声明切面"></a>声明切面</h4><p>​    切面就是包含切入点和通知的对象，在Spring容器中将被定义为一个Bean，Schema方式的切面需要一个切面支持Bean，该支持Bean的字段和方法提供了切面的状态和行为信息，并通过配置方式来指定切入点和通知实现。</p>
<p>​      切面使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签指定，ref属性用来引用切面支持Bean。</p>
<p>​     切面支持Bean“aspectSupportBean”跟普通Bean完全一样使用，切面使用“ref”属性引用它。</p>
<h4 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​    切入点在Spring中也是一个Bean，Bean定义方式可以有很三种方式：</p>
<p>​     <strong>1）在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>，该切入点可以被多个切面使用，对于需要共享使用的切入点最好使用该方式，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>**2）在&lt;aop:aspect&gt;*标签下使用&lt;aop:pointcut&gt;声明一个切入点Bean**，该切入点可以被多个切面使用，但一般该切入点只被该切面使用，当然也可以被其他切面使用，但最好不要那样使用，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式： 
</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">" pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>3）匿名切入点Bean，</strong>可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h4><p> 基于Schema方式支持前边介绍的5中通知类型：</p>
<p> <strong>一、前置通知：</strong>在切入点选择的方法之前执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">"前置通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">arg-names</span>=<span class="string">"前置通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>二者选一，指定切入点；</p>
<p>​         <strong>method：</strong>指定前置通知实现方法名，如果是多态需要加上参数类型，多个用“，”隔开，如beforeAdvice(java.lang.String)；</p>
<p>​         <strong>arg-names：</strong>指定通知实现方法的参数名字，多个用“，”分隔，可选，类似于【3.1.2 构造器注入】中的参数名注入限制：<strong>在class文件中没生成变量调试信息是获取不到方法参数名字的，因此只有在类没生成变量调试信息时才需要使用arg-names属性来指定参数名，如</strong>arg-names=”param”表示通知实现方法的参数列表的第一个参数名字为“param”。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayBefore(..)) and args(param)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">method</span>=<span class="string">"beforeAdvice(java.lang.String)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">arg-names</span>=<span class="string">"param"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaBeforeAdvice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">     ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">     IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">     helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=====================================================before advice param:before============say before==========================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayBefore(..)) ”匹配目标方法sayBefore，且使用“args(param)”匹配目标方法只有一个参数且传入的参数类型为通知实现方法中同名的参数类型；</p>
<p><strong>2）目标方法定义：</strong>使用method=” beforeAdvice(java.lang.String) “指定前置通知实现方法，且该通知有一个参数类型为java.lang.String参数；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=” param “指定通知实现方法参数名为“param”，切入点中使用“args(param)”匹配的目标方法参数将自动传递给通知实现方法同名参数。</p>
<p>   <strong>二、后置返回通知：</strong>在切入点选择的方法正常返回时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-returning" target="_blank" rel="noopener">aop:after-returning</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">"后置返回通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">"后置返回通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">returning</span>=<span class="string">"返回值对应的后置返回通知实现方法参数名"</span>  </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>returning：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法执行正常返回后，将把目标方法返回值传给通知方法；returning限定了只有目标方法返回值匹配与通知方法相应参数类型时才能执行后置返回通知，否则不执行，对于returning对应的通知方法参数为Object类型将匹配任何目标返回值。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============after returning"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterReturningAdvice"</span>  </span></span><br><span class="line"><span class="tag">                               <span class="attr">arg-names</span>=<span class="string">"retVal"</span>    </span></span><br><span class="line"><span class="tag">                               <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterReturningAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterReturning();      </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================after returning===========after returning advice retVal:true======================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterReturning(..)) ”匹配目标方法sayAfterReturning，该方法返回true；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterReturningAdvice”指定后置返回通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”retVal”指定通知实现方法参数名为“retVal”；</p>
<p><strong>4）返回值命名：</strong>returning=”retVal”用于将目标返回值赋值给通知实现方法参数名为“retVal”的参数上。</p>
<p> <strong>三、后置异常通知：</strong>在切入点选择的方法抛出异常时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-throwing" target="_blank" rel="noopener">aop:after-throwing</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"后置异常通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"后置异常通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"将抛出的异常赋值给的通知实现方法参数名"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>   <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>throwing：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；throwing限定了只有目标方法抛出的异常匹配与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，对于throwing对应的通知方法参数为Throwable类型将匹配任何异常。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============before throwing"</span>);  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterThrowingAdvice"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"exception"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"exception"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException.class)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterThrowingAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterThrowing();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================before throwing===========after throwing advice exception:java.lang.RuntimeException======================================</td>
</tr>
</tbody>
</table>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterThrowing(..))”匹配目标方法sayAfterThrowing，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterThrowingAdvice”指定后置异常通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”exception”指定通知实现方法参数名为“exception”；</p>
<p><strong>4）异常命名：</strong>returning=”exception”用于将目标方法抛出的异常赋值给通知实现方法参数名为“exception”的参数上。</p>
<p> <strong>四、后置最终通知：</strong>在切入点选择的方法返回时执行，不管是正常返回还是抛出异常都执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterFinally</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterFinally(..))”匹配目标方法sayAfterFinally，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=” afterFinallyAdvice “指定后置最终通知实现方法。</p>
<p> <strong>五、环绕通知：</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值，可通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:around &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型，在通知实现方法内部使用ProceedingJoinPoint的proceed()方法使目标方法执行，proceed 方法可以传入可选的Object[]数组，该数组的值将被作为目标方法执行时的参数。</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"============around param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.zero..*.sayAround(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">"aroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAroundAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAround(<span class="string">"haha"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ===========================</p>
<p>======================around before advice</p>
<p>============around param:replace</p>
<p>===========around after advice</p>
<p>====================================== </p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAround(..))”匹配目标方法sayAround；</p>
<p><strong>2）目标方法定义：</strong>使用method=”aroundAdvice”指定环绕通知实现方法，在该实现中，第一个方法参数为pjp，类型为ProceedingJoinPoint，其中“Object retVal = pjp.proceed(new Object[] {“replace”});”，用于执行目标方法，且目标方法参数被“new Object[] {“replace”}”替换，最后返回“retVal ”返回值。</p>
<p><strong>3）测试：</strong>我们使用“helloworldService.sayAround(“haha”);”传入参数为“haha”，但最终输出为“replace”，说明参数被替换了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);</span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);</span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​     Spring引入允许为目标对象引入新的接口，通过在&lt; aop:aspect&gt;标签内使用&lt; aop:declare-parents&gt;标签进行引入，定义方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">types-matching</span>=<span class="string">"AspectJ语法类型表达式"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">implement-interface</span>=<span class="string">引入的接口</span>"               </span></span><br><span class="line"><span class="tag">          <span class="attr">default-impl</span>=<span class="string">"引入接口的默认实现"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">delegate-ref</span>=<span class="string">"引入接口的默认实现Bean引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>types-matching：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；</p>
<p>​         <strong>implement-interface：</strong>定义需要引入的接口；</p>
<p>​         <strong>default-impl和delegate-ref：</strong>定义引入接口的默认实现，二者选一，default-impl是接口的默认实现类全限定名，而delegate-ref是默认的实现的委托Bean名；</p>
<p>接下来让我们练习一下吧：</p>
<p>​    首先定义引入的接口及默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroductiondService</span> <span class="keyword">implements</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========introduction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">"com.zero..*.IHelloWorldService+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">"com.zero.iin.IIntroductionService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">"com.zero.iin.IntroductiondService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后测试一下吧，测试代码cn.javass.spring.chapter6.AopTest：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaIntroduction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IIntroductionService introductionService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IIntroductionService.class);  </span><br><span class="line">    introductionService.induct();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> =========introduction</p>
<p> ======================================  </p>
<p> 分析一下吧：</p>
<p><strong>1）目标对象类型匹配：</strong>使用types-matching=”cn.javass..*.IHelloWorldService+”匹配IHelloWorldService接口的子类型，如HelloWorldService实现；</p>
<p><strong>2）引入接口定义：</strong>通过implement-interface属性表示引入的接口，如“cn.javass.spring.chapter6.service.IIntroductionService”。</p>
<p><strong>3）引入接口的实现：</strong>通过default-impl属性指定，如“cn.javass.spring.chapter6.service.impl.IntroductiondService”，也可以使用“delegate-ref”来指定实现的Bean。</p>
<p><strong>4）获取引入接口：</strong>如使用“ctx.getBean(“helloWorldService”, IIntroductionService.class);”可直接获取到引入的接口。</p>
<h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p> Advisor表示只有一个通知和一个切入点的切面，由于Spring AOP都是基于AOP联盟的拦截器模型的环绕通知的，所以引入Advisor来支持各种通知类型（如前置通知等5种），Advisor概念来自于Spring1.2对AOP的支持，在AspectJ中没有相应的概念对应。</p>
<p> Advisor可以使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>标签定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span> <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"通知API实现引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**二者选一，指定切入点表达式；</p>
<p>​         <strong>advice-ref：</strong>引用通知API实现Bean，如前置通知接口为MethodBeforeAdvice；</p>
<p> 接下来让我们看一下示例吧：</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三定义前置通知API实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceImpl</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在chapter6/advice.xml配置文件中先添加通知实现Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeAdvice"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.BeforeAdviceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，添加Advisor定义，添加时注意顺序：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..))"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAdvisor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">   IHelloWorldService helloworldService =  </span><br><span class="line">   ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">   helloworldService.sayAdvisorBefore(<span class="string">"haha"</span>);  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> ===========before advice</p>
<p> ============say haha</p>
<p> ======================================  </p>
<h3 id="基于-AspectJ的AOP"><a href="#基于-AspectJ的AOP" class="headerlink" title="基于@AspectJ的AOP"></a>基于@AspectJ的AOP</h3><p>​       Spring除了支持Schema方式配置AOP，还支持注解方式：使用@AspectJ风格的切面声明。</p>
<h4 id="启用对-AspectJ的支持"><a href="#启用对-AspectJ的支持" class="headerlink" title="启用对@AspectJ的支持"></a>启用对@AspectJ的支持</h4><p>Spring默认不支持@AspectJ风格的切面声明，为了支持需要使用如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样Spring就能发现@AspectJ风格的切面并且将切面应用到目标对象。</p>
<h4 id="声明切面-1"><a href="#声明切面-1" class="headerlink" title="声明切面"></a>声明切面</h4><p>​       @AspectJ风格的声明切面非常简单，使用@Aspect注解进行声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>()  </span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span></span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       然后将该切面在配置文件中声明为Bean后，Spring就能自动识别并进行AOP方面的配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"……Aspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       该切面就是一个POJO，可以在该切面中进行切入点及通知定义，接着往下看吧。</p>
<h4 id="声明切入点-1"><a href="#声明切入点-1" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​       @AspectJ风格的命名切入点使用org.aspectj.lang.annotation包下的@Pointcut+方法（方法必须是返回void类型）实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"切入点表达式"</span>, argNames = <span class="string">"参数名列表"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutName</span><span class="params">(……)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式；</p>
<p>​       <strong>argNames：</strong>指定命名切入点方法参数列表参数名字，可以有多个用“，”分隔，这些参数将传递给通知方法同名的参数，同时比如切入点表达式“args(param)”将匹配参数类型为命名切入点方法同名参数指定的参数类型。</p>
<p>​       <strong>pointcutName：</strong>切入点名字，可以使用该名字进行引用该切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个切入点，名字为“beforePointcut”，该切入点将匹配目标方法的第一个参数类型为通知方法实现中参数名为“param”的参数类型。</p>
<h4 id="声明通知-1"><a href="#声明通知-1" class="headerlink" title="声明通知"></a>声明通知</h4><p>​       @AspectJ风格的声明通知也支持5种通知类型：</p>
<p> <strong>一、前置通知：</strong>使用org.aspectj.lang.annotation 包下的@Before注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"切入点表达式或命名切入点"</span>, argNames = <span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义。</p>
<p>接下来示例一下吧：</p>
<p>1、定义接口和实现，在此我们就使用Schema风格时的定义；</p>
<p>2、定义切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;  </span><br><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect2</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义切入点：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义通知：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"beforePointcut(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在chapter6/advice2.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">            </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span>  </span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect2"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6、测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationBeforeAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice2.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<p> ==========================================</p>
<p> ===========before advice param:before</p>
<p> ============say before</p>
<p> ==========================================  </p>
<p>切面、切入点、通知全部使用注解完成：</p>
<p>​       1）使用@Aspect将POJO声明为切面；</p>
<p>​       2）使用@Pointcut进行命名切入点声明，同时指定目标方法第一个参数类型必须是java.lang.String，对于其他匹配的方法但参数类型不一致的将也是不匹配的，通过argNames = “param”指定了将把该匹配的目标方法参数传递给通知同名的参数上；</p>
<p>​       3）使用@Before进行前置通知声明，其中value用于定义切入点表达式或引用命名切入点；</p>
<p>​       4）配置文件需要使用<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>来开启注解风格的@AspectJ支持；</p>
<p>​       5）需要将切面注册为Bean，如“aspect”Bean；</p>
<p>​       6）测试代码完全一样。</p>
<p><strong>二、后置返回通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterReturning注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">returning=<span class="string">"返回值对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argName：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>returning：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayBefore(..))"</span>,  </span><br><span class="line">    pointcut=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"retVal"</span>, returning=<span class="string">"retVal"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterReturningAdvice测试方法。</p>
<p> <strong>三、后置异常通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterThrowing注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">throwing=<span class="string">"异常对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>throwing：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"exception"</span>, throwing=<span class="string">"exception"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterThrowingAdvice测试方法。</p>
<p> <strong>四、后置最终通知：</strong>使用org.aspectj.lang.annotation 包下的@After注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* cn.javass..*.sayAfterFinally(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after finally advice"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterFinallyAdvice测试方法。 </p>
<p><strong>五、环绕通知：</strong>使用org.aspectj.lang.annotation 包下的@Around注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value=<span class="string">"execution(* cn.javass..*.sayAround(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的annotationAroundAdviceTest测试方法。 </p>
<h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>​       @AspectJ风格的引入声明在切面中使用org.aspectj.lang.annotation包下的@DeclareParents声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">value=<span class="string">" AspectJ语法类型表达式"</span>,  </span><br><span class="line">defaultImpl=引入接口的默认实现类)  </span><br><span class="line"><span class="keyword">private</span> Interface <span class="class"><span class="keyword">interface</span></span>;</span><br></pre></td></tr></table></figure>
<p> <strong>value：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；与Schema方式中的types-matching属性同义；</p>
<p>​       private Interface interface<strong>：</strong>指定需要引入的接口；</p>
<p>​       defaultImpl<strong>：</strong>指定引入接口的默认实现类，没有与Schema方式中的delegate-ref属性同义的定义方式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">    value=<span class="string">"cn.javass..*.IHelloWorldService+"</span>, defaultImpl=cn.javass.spring.chapter6.service.impl.IntroductiondService.class)  </span><br><span class="line"><span class="keyword">private</span> IIntroductionService introductionService;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationIntroduction测试方法。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring之资源与表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring之资源与表达式/" itemprop="url">Spring之资源与表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T11:27:18+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E6%9C%88%E5%85%89%E4%B8%8B%E7%9A%84%E7%A5%81%E8%BF%9E%E5%B1%B1%E6%9C%80%E9%AB%98%E5%B3%B0.jpg?raw=true" alt=""></p>
<p>抄自：开涛  <a href="http://jinnianshilongnian.iteye.com/blog/1416319" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1416319</a></p>
<p>### </p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="资源基础知识"><a href="#资源基础知识" class="headerlink" title="资源基础知识"></a>资源基础知识</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在日常程序开发中，处理外部资源是很繁琐的事情，我们可能需要处理URL资源、File资源、ClassPath相关资源、服务器相关资源(JBoss AS 5.x 上的VFS资源)等等很多资源。因此处理这些资源需要使用不同的接口，这就增加了我们系统的复杂性；而且处理这些资源步骤都是类似的(打开资源、读取资源、关闭资源)，因此如果能抽象出一个统一的接口来对这些底层资源进行统一访问，是不是很方便，而且使我们系统更加简洁，都是对不同的底层资源使用同一个接口进行访问。</p>
<p>Spring提供了一个Resource接口来统一这些底层资源一直的访问，而且提供了一些便利的接口，从而能提供我们的生产力。</p>
<h4 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h4><p>Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;  </span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)InputStreamSource接口解析： </p>
<p><strong>getInputStream：</strong>每次调用都将返回一个新鲜的资源对应的java.io.InputStream字节流，调用者在使用完毕后必须关闭该资源。</p>
<p>2）Resource接口继承InputStreamSource接口，并提供一些便利方法：</p>
<ul>
<li><p><strong>exists：</strong>返回当前Resource代表的底层资源是否可读，true表示可读</p>
</li>
<li><p><strong>isReadable</strong>：返回当前Resource代表的底层资源是否可读，true表示可读。</p>
</li>
<li><p><strong>isOpen</strong>：返回当前Resource代表的底层资源是否已经打开，如果返回true，则只能被读取一次然后关闭以避免资源泄露；常见的Resource实现一般返回false。 </p>
</li>
<li><p><strong>getURL</strong>：如果当前Resource代表的底层资源能由java.util.URL代表，则返回该URL，否则抛出IOException。</p>
</li>
<li><p><strong>getURI</strong>：如果当前Resource代表的底层资源能由java.util.URI代表，则返回该URI，否则抛出IOException。 </p>
</li>
<li><p><strong>getFile</strong>：如果当前Resource代表的底层资源能由java.io.File代表，则返回该File，否则抛出IOException。 </p>
</li>
<li><p><strong>contentLength</strong>：返回当前Resource代表的底层文件资源的长度，一般是值代表的文件资源的长度。</p>
</li>
<li><p><strong>lastModified</strong> ：返回当前Resource代表的底层资源的最后修改时间。 </p>
</li>
<li><p><strong>createRelative</strong>：用于创建相对于当前Resource代表的底层资源的资源，比如当前Resource代表文件资源“d:/test/”则createRelative（“test.txt”）将返回表文件资源“d:/test/test.txt”Resource资源。 </p>
</li>
<li><p><strong>getFilename</strong>：返回当前Resource代表的底层文件资源的文件路径，比如File资源“file://d:/test.txt”将返回“d:/test.txt”，而URL资源<a href="http://www.javass.cn将返回“”，因为只返回文件路径。" target="_blank" rel="noopener">http://www.javass.cn将返回“”，因为只返回文件路径。</a> </p>
</li>
<li><p><strong>getDescription</strong>：返回当前Resource代表的底层资源的描述符，通常就是资源的全路径（实际文件名或实际URL地址）。</p>
<p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p>
</li>
</ul>
<h3 id="内置Resource实现"><a href="#内置Resource实现" class="headerlink" title="内置Resource实现"></a>内置Resource实现</h3><h4 id="ByteArrayResource"><a href="#ByteArrayResource" class="headerlink" title="ByteArrayResource"></a>ByteArrayResource</h4><p>ByteArrayResource代表byte[]数组资源对于“getInputStream”操作将返回一个ByteArrayInputStream。</p>
<p>首先让我们看下使用ByteArrayResource如何处理byte数组资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByteArrayResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ByteArrayResource(<span class="string">"Hello World !"</span>.getBytes()); <span class="comment">//得到一个操作系统默认的编码格式的字节数组。</span></span><br><span class="line">        <span class="keyword">if</span> (resource.exists())&#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，让我们看下“dumpStream”实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpStream</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取文件资源</span></span><br><span class="line">            is = resource.getInputStream();</span><br><span class="line">            <span class="comment">//2.读取资源</span></span><br><span class="line">            <span class="keyword">byte</span>[] descBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(descBytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(descBytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3.关闭资源</span></span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    让我们来仔细看一下代码，dumpStream方法很抽象定义了访问流的三部曲：打开资源、读取资源、关闭资源，所以dunpStrean可以再进行抽象从而能在自己项目中使用；byteArrayResourceTest测试方法，也定义了基本步骤：定义资源、验证资源存在、访问资源。</p>
<p>​        ByteArrayResource可多次读取数组资源，即isOpen ()永远返回false。</p>
<h4 id="InputStreamResource"><a href="#InputStreamResource" class="headerlink" title="InputStreamResource"></a>InputStreamResource</h4><p>​       InputStreamResource代表java.io.InputStream字节流，对于“getInputStream ”操作将直接返回该字节流，因此只能读取一次该字节流，即“isOpen”永远返回true。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInputStreamResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"Hello World!"</span>.getBytes());</span><br><span class="line">    Resource resource = <span class="keyword">new</span> InputStreamResource(bis);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h4><p>​       FileSystemResource代表java.io.File资源，对于“getInputStream ”操作将返回底层文件的字节流，“isOpen”将永远返回false，从而表示可多次读取底层文件的字节流。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意由于“isOpen”将永远返回false，所以可以多次调用dumpStream(resource)。</p>
<h4 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h4><p>​       ClassPathResource代表classpath路径的资源，将使用ClassLoader进行加载资源。classpath 资源存在于类路径中的文件系统中或jar包里，且“isOpen”永远返回false，表示可多次读取资源。</p>
<pre><code>ClassPathResource加载资源替代了Class类和ClassLoader类的“getResource(String name)”和“getResourceAsStream(String name)”两个加载类路径资源方法，提供一致的访问方式。
</code></pre><p> ClassPathResource提供了三个构造器：</p>
<p>​          <strong>public ClassPathResource(String path)</strong>：使用默认的ClassLoader加载“path”类路径资源；</p>
<p>​          <strong>public ClassPathResource(String path, ClassLoader classLoader)</strong>：使用指定的ClassLoader加载“path”类路径资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/test1.properties”；</p>
<p>​          <strong>public ClassPathResource(String path, Class&lt;?&gt; clazz)</strong>：使用指定的类加载“path”类路径资源，将加载相对于当前类的路径的资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties”；</p>
<p>​        而如果需要 加载的资源路径为“test1.properties”，将加载的资源为“cn/javass/spring/chapter4/test1.properties”。</p>
<p>​        让我们直接看测试代码吧：</p>
<p> 1）使用默认的加载器加载资源，将加载当前ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByDefaultClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）使用指定的ClassLoader进行加载资源，将加载指定的ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , cl);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）使用指定的类进行加载资源，将尝试加载相对于当前类的路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">    Resource resource1 = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , clazz);</span><br><span class="line">    <span class="keyword">if</span>(resource1.exists()) &#123;</span><br><span class="line">        dumpStream(resource1);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource1.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource1.isOpen());</span><br><span class="line"></span><br><span class="line">    Resource resource2 = <span class="keyword">new</span> ClassPathResource(<span class="string">"test1.properties"</span> , <span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">if</span>(resource2.exists()) &#123;</span><br><span class="line">        dumpStream(resource2);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource2.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource2.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       “resource1”将加载cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties资源；“resource2”将加载“cn/javass/spring/chapter4/test1.properties”；</p>
<p> 4）加载jar包里的资源，首先在当前类路径下找不到，最后才到Jar包里找，而且在第一个Jar包里找到的将被返回：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classpathResourceTestFromJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"overview.html"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getURL().getPath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前类路径包含“overview.html”，在项目的“resources”目录下，将加载该资源，否则将加载Jar包里的“overview.html”，而且不能使用“resource.getFile()”，应该使用“resource.getURL()”，因为资源不存在于文件系统而是存在于jar包里，URL类似于“file:/C:/…/***.jar!/overview.html”。</p>
<p> 类路径一般都是相对路径，即相对于类路径或相对于当前类的路径，因此如果使用“/test1.properties”带前缀“/”的路径，将自动删除“/”得到“test1.properties”。</p>
<h4 id="UrlResource"><a href="#UrlResource" class="headerlink" title="UrlResource"></a>UrlResource</h4><p>​       UrlResource代表URL资源，用于简化URL资源访问。“isOpen”永远返回false，表示可多次读取资源。</p>
<p>​        UrlResource一般支持如下资源访问：</p>
<p>​      UrlResource一般支持如下资源访问：</p>
<p>​         <strong>http：</strong>通过标准的http协议访问web资源，如new UrlResource(“http://地址”)；</p>
<p>​         <strong>ftp：</strong>通过ftp协议访问资源，如new UrlResource(“ftp://地址”)；</p>
<p>​         <strong>file：</strong>通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”)；</p>
<p>具体使用方法在此就不演示了，可以参考cn.javass.spring.chapter4.ResourceTest中urlResourceTest测试方法。</p>
<h4 id="ServletContextResource"><a href="#ServletContextResource" class="headerlink" title="ServletContextResource"></a>ServletContextResource</h4><p>​       ServletContextResource代表web应用资源，用于简化servlet容器的ServletContext接口的getResource操作和getResourceAsStream操作；在此就不具体演示了。</p>
<h4 id="VfsResource"><a href="#VfsResource" class="headerlink" title="VfsResource"></a>VfsResource</h4><p>VfsResource代表Jboss 虚拟文件系统资源。</p>
<p> Jboss VFS(Virtual File System)框架是一个文件系统资源访问的抽象层，它能一致的访问物理文件系统、jar资源、zip资源、war资源等，VFS能把这些资源一致的映射到一个目录上，访问它们就像访问物理文件资源一样，而其实这些资源不存在于物理文件系统。</p>
<p> 在示例之前需要准备一些jar包，在此我们使用的是Jboss VFS3版本，可以下载最新的Jboss AS 6x，拷贝lib目录下的“jboss-logging.jar”和“jboss-vfs.jar”两个jar包拷贝到我们项目的lib目录中并添加到“Java Build Path”中的“Libaries”中。</p>
<p> 让我们看下示例（cn.javass.spring.chapter4.ResourceTest）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForRealFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home"</span>);</span><br><span class="line"><span class="comment">//2.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mount(home, <span class="keyword">new</span> RealFileSystem(<span class="keyword">new</span> File(<span class="string">"d:"</span>)));</span><br><span class="line"><span class="comment">//3.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//4.通过一致的接口访问</span></span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.首先获取jar包路径</span></span><br><span class="line">        File realFile = <span class="keyword">new</span> File(<span class="string">"lib/org.springframework.beans-3.0.5.RELEASE.jar"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home2"</span>);</span><br><span class="line">        <span class="comment">//3.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mountZipExpanded(realFile, home,</span><br><span class="line">                TempFileProvider.create(<span class="string">"tmp"</span>, Executors.newScheduledThreadPool(<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//4.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"META-INF/spring.handlers"</span>);</span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​       通过VFS，对于jar里的资源和物理文件系统访问都具有一致性，此处只是简单示例，如果需要请到Jboss官网深入学习。</p>
<h3 id="访问Resource"><a href="#访问Resource" class="headerlink" title="访问Resource"></a>访问Resource</h3><h4 id="ResourceLoader接口"><a href="#ResourceLoader接口" class="headerlink" title="ResourceLoader接口"></a>ResourceLoader接口</h4><p>ResourceLoader接口用于返回Resource对象；其实现可以看作是一个生产Resource的工厂类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       getResource接口用于根据提供的location参数返回相应的Resource对象；而getClassLoader则返回加载这些Resource的ClassLoader。</p>
<p>​        Spring提供了一个适用于所有环境的DefaultResourceLoader实现，可以返回ClassPathResource、UrlResource；还提供一个用于web环境的ServletContextResourceLoader，它继承了DefaultResourceLoader的所有功能，又额外提供了获取ServletContextResource的支持。</p>
<p>​        ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：“classpath:path”表示返回ClasspathResource，“<a href="http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：" target="_blank" rel="noopener">http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testResourceLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader loader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">    Resource resource = loader.getResource(<span class="string">"classpath:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(ClassPathResource.class, resource.getClass());</span><br><span class="line">    Resource resource2 = loader.getResource(<span class="string">"file:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(UrlResource.class, resource2.getClass());</span><br><span class="line">    Resource resource3 = loader.getResource(<span class="string">"cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返默认可以加载ClasspathResource</span></span><br><span class="line">    Assert.assertTrue(resource3 <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于目前所有ApplicationContext都实现了ResourceLoader，因此可以使用其来加载资源。</p>
<p>​         <strong>ClassPathXmlApplicationContext：</strong>不指定前缀将返回默认的ClassPathResource资源，否则将根据前缀来加载资源；</p>
<p>​         <strong>FileSystemXmlApplicationContext：</strong>不指定前缀将返回FileSystemResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>WebApplicationContext：</strong>不指定前缀将返回ServletContextResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>其他：</strong>不指定前缀根据当前上下文返回Resource实现，否则将根据前缀来加载资源。</p>
<h4 id="ResourceLoaderAware接口"><a href="#ResourceLoaderAware接口" class="headerlink" title="ResourceLoaderAware接口"></a>ResourceLoaderAware接口</h4><p>​       ResourceLoaderAware是一个标记接口，用于通过ApplicationContext上下文注入ResourceLoader。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  首先准备测试Bean，我们的测试Bean还简单只需实现ResourceLoaderAware接口，然后通过回调将ResourceLoader保存下来就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）  配置Bean定义（chapter4/resourceLoaderAware.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）测试(cn.javass.spring.chapter4.ResoureLoaderAwareTest)：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        ResourceBean resourceBean = ctx.getBean(ResourceBean.class);</span><br><span class="line">        ResourceLoader loader = resourceBean.getResourceLoader();</span><br><span class="line">        Assert.assertTrue(loader <span class="keyword">instanceof</span> ApplicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意此处“loader instanceof ApplicationContext”，说明了ApplicationContext就是个ResoureLoader。</p>
<p>​        由于上述实现回调接口注入ResourceLoader的方式属于侵入式，所以不推荐上述方法，可以采用更好的自动注入方式，如“byType”和“constructor”，此处就不演示了。   </p>
<h4 id="注入Resource"><a href="#注入Resource" class="headerlink" title="注入Resource"></a>注入Resource</h4><p>​       通过回调或注入方式注入“ResourceLoader”，然后再通过“ResourceLoader”再来加载需要的资源对于只需要加载某个固定的资源是不是很麻烦，有没有更好的方法类似于前边实例中注入“java.io.File”类似方式呢？</p>
<p>​        Spring提供了一个PropertyEditor “ResourceEditor”用于在注入的字符串和Resource之间进行转换。因此可以使用注入方式注入Resource。</p>
<p>​        ResourceEditor完全使用ApplicationContext根据注入的路径字符串获取相应的Resource，说白了还是自己做还是容器帮你做的问题。</p>
<p> 接下让我们看下示例：</p>
<p>​        1）准备Bean：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）准备配置文件（chapter4/ resourceInject.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span> <span class="attr">value</span>=<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">"classpath:cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       注意此处“resourceBean1”注入的路径没有前缀表示根据使用的ApplicationContext实现进行选择Resource实现。</p>
<p>​        3）让我们来看下测试代码（cn.javass.spring.chapter4.ResourceInjectTest）吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter4/resourceInject.xml"</span>);</span><br><span class="line">    ResourceBean3 resourceBean1 = ctx.getBean(<span class="string">"resourceBean1"</span>, ResourceBean3.class);</span><br><span class="line">    ResourceBean3 resourceBean2 = ctx.getBean(<span class="string">"resourceBean2"</span>, ResourceBean3.class);</span><br><span class="line">    Assert.assertTrue(resourceBean1.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">    Assert.assertTrue(resourceBean2.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       接下来一节让我们深入ApplicationContext对各种Resource的支持，及如何使用更便利的资源加载方式。</p>
<h3 id="Resource通配符路径"><a href="#Resource通配符路径" class="headerlink" title="Resource通配符路径"></a>Resource通配符路径</h3><h4 id="使用路径通配符加载Resource"><a href="#使用路径通配符加载Resource" class="headerlink" title="使用路径通配符加载Resource"></a>使用路径通配符加载Resource</h4><p>​        前面介绍的资源路径都是非常简单的一个路径匹配一个资源，Spring还提供了一种更强大的Ant模式通配符匹配，从能一个路径匹配一批资源。</p>
<p>​        Ant路径通配符支持“？”、“*”、“**”，注意通配符匹配不包括目录分隔符“/”：</p>
<p> <strong>“?**</strong>”：匹配一个字符**，如“config?.xml”将匹配“config1.xml”；</p>
<p>​         <strong>“***</strong>”：匹配零个或多个字符串*<em>，如“cn/</em>/config.xml”将匹配“cn/javass/config.xml”，但不匹配匹配“cn/config.xml”；而“cn/config-*.xml”将匹配“cn/config-dao.xml”；</p>
<p>​         <strong>“****</strong>”：匹配路径中的零个或多个目录<strong>，如“cn/</strong>/config.xml”将匹配“cn /config.xml”，也匹配“cn/javass/spring/config.xml”；而“cn/javass/config-<strong>.xml”将匹配“cn/javass/config-dao.xml”，即把“</strong>”当做两个“*”处理。</p>
<p>Spring提供AntPathMatcher来进行Ant风格的路径匹配。具体测试请参考cn.javass.spring.chapter4. AntPathMatcherTest。</p>
<p>Spring在加载类路径资源时除了提供前缀“classpath:”的来支持加载一个Resource，还提供一个前缀“classpath*:”来支持加载所有匹配的类路径Resource。</p>
<p>Spring提供ResourcePatternResolver接口来加载多个Resource，该接口继承了ResourceLoader并添加了“Resource[] getResources(String locationPattern)”用来加载多个Resource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;  </span><br><span class="line">       String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;  </span><br><span class="line">       Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring提供了一个ResourcePatternResolver实现PathMatchingResourcePatternResolver，它是基于模式匹配的，默认使用AntPathMatcher进行路径匹配，它除了支持ResourceLoader支持的前缀外，还额外支持“classpath<em>:”用于加载所有匹配的类路径Resource，ResourceLoader不支持前缀“classpath</em>:”：</p>
<p> 首先做下准备工作，在项目的“resources”创建“META-INF”目录，然后在其下创建一个“INDEX.LIST”文件。同时在“org.springframework.beans-3.0.5.RELEASE.jar”和“org.springframework.context-3.0.5.RELEASE.jar”两个jar包里也存在相同目录和文件。然后创建一个“LICENSE”文件，该文件存在于“com.springsource.cn.sf.cglib-2.2.0.jar”里。</p>
<p> <strong>一、“classpath</strong>”：*<em> 用于加载类路径（包括jar包）中的一个且仅一个资源；对于多个匹配的也只返回一个，所以如果需要多个匹配的请考虑“classpath</em>:”前缀；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathPrefix</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();  </span><br><span class="line">    <span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, resources.length);  </span><br><span class="line">    <span class="comment">//只加载一个匹配的Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二、“classpath*”：</strong> 用于加载类路径（包括jar包）中的所有匹配的资源。带通配符的classpath使用“ClassLoader”的“Enumeration<url> getResources(String name)”方法来查找通配符之前的资源，然后通过模式匹配来获取匹配的资源。如“classpath:META-INF/*.LIST”将首先加载通配符之前的目录“META-INF”，然后再遍历路径进行子路径匹配从而获取匹配的资源。 </url></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefix</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">     ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();        </span><br><span class="line">     <span class="comment">//将加载多个绝对匹配的所有Resource  </span></span><br><span class="line">    <span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);      </span><br><span class="line">    <span class="comment">//将加载多个模式匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意“resources.length &gt;1”说明返回多个Resource。不管模式匹配还是非模式匹配只要匹配的都将返回。</p>
<pre><code>在“com.springsource.cn.sf.cglib-2.2.0.jar”里包含“asm-license.txt”文件，对于使用“classpath*: asm-*.txt”进行通配符方式加载资源将什么也加载不了“asm-license.txt”文件，注意一定是模式路径匹配才会遇到这种问题。这是由于“ClassLoader”的“getResources(String name)”方法的限制，对于name为“”的情况将只返回文件系统的类路径，不会包换jar包根路径。 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefixLimit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();      <span class="comment">//将首先通过ClassLoader.getResources("")加载目录，  </span></span><br><span class="line">    <span class="comment">//将只返回文件系统的类路径不返回jar的跟路径  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources = resolver.getResources(<span class="string">"classpath*:asm-*.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//将通过ClassLoader.getResources("asm-license.txt")加载  </span></span><br><span class="line">    <span class="comment">//asm-license.txt存在于com.springsource.net.sf.cglib-2.2.0.jar  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:asm-license.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">0</span>);       </span><br><span class="line">    <span class="comment">//将只加载文件系统类路径匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:LICENS*"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于“resolver.getResources(“classpath<em>:asm-</em>.txt”);”，由于在项目“resources”目录下没有所以应该返回0个资源；“resolver.getResources(“classpath<em>:asm-license.txt”);”将返回jar包里的Resource；“resolver.getResources(“classpath</em>:LICENS*”);”，因为将只返回文件系统类路径资源，所以返回1个资源。</p>
<p> 因此加载通配符路径时（即路径中包含通配符），必须包含一个根目录才能保证加载的资源是所有的，而不是部分。</p>
<p> <strong>三、“file”：</strong>加载一个或多个文件系统中的Resource。如“file:D:/*.txt”将返回D盘下的所有txt文件；      </p>
<p><strong>四、无前缀</strong>：通过ResourceLoader实现加载一个资源。</p>
<p>AppliacationContext提供的getResources方法将获取资源委托给ResourcePatternResolver实现，默认使用PathMatchingResourcePatternResolver。所有在此就无需介绍其使用方法了。</p>
<h4 id="注入Resource数组"><a href="#注入Resource数组" class="headerlink" title="注入Resource数组"></a>注入Resource数组</h4><p>​       Spring还支持注入Resource数组，直接看配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>log4j.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span> <span class="attr">value</span>=<span class="string">"classpath*:META-INF/INDEX.LIST"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean3"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath*:META-INF/INDEX.LIST<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       “resourceBean1”就不用多介绍了，传统实现方式；对于“resourceBean2”则使用前缀“classpath*”，看到这大家应该懂的，加载匹配多个资源；“resourceBean3”是混合使用的；测试代码在“cn.javass.spring.chapter4.ResourceInjectTest.testResourceArrayInject”。</p>
<p>​        Spring通过ResourceArrayPropertyEditor来进行类型转换的，而它又默认使用“PathMatchingResourcePatternResolver”来进行把路径解析为Resource对象。所有大家只要会使用“PathMatchingResourcePatternResolver”，其它一些实现都是委托给它的，比如AppliacationContext的“getResources”方法等。</p>
<h4 id="AppliacationContext实现对各种Resource的支持"><a href="#AppliacationContext实现对各种Resource的支持" class="headerlink" title="AppliacationContext实现对各种Resource的支持"></a>AppliacationContext实现对各种Resource的支持</h4><p>​       <strong>一、ClassPathXmlApplicationContext：</strong>默认将通过classpath进行加载返回ClassPathResource，提供两类构造器方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1）通过ResourcePatternResolver实现根据configLocation获取资源  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span>；  </span></span><br><span class="line"><span class="function">       <span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, ……)</span></span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//2）通过直接根据path直接返回ClasspathResource  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String path, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz, ……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       第一类构造器是根据提供的配置文件路径使用“ResourcePatternResolver ”的“getResources()”接口通过匹配获取资源；即如“classpath:config.xml”</p>
<p>​        第二类构造器则是根据提供的路径和clazz来构造ClassResource资源。即采用“public ClassPathResource(String path, Class&lt;?&gt; clazz)”构造器获取资源。</p>
<p>​        <strong>二、FileSystemXmlApplicationContext：</strong>将加载相对于当前工作目录的“configLocation”位置的资源，注意在linux系统上不管“configLocation”是否带“/”，都作为相对路径；而在window系统上如“D:/resourceInject.xml”是绝对路径。因此在除非很必要的情况下，不建议使用该ApplicationContext。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span></span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String... configLocations,……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       此处还需要注意：在linux系统上，构造器使用的是相对路径，而ctx.getResource()方法如果以“/”开头则表示获取绝对路径资源，而不带前导“/”将返回相对路径资源。如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"/root/confg.xml"</span>);  </span><br><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       因此如果需要加载绝对路径资源最好选择前缀“file”方式，将全部根据绝对路径加载。如在linux系统“ctx.getResource (“file:/root/confg.xml”);”    </p>
<h2 id="Spring表达式语言"><a href="#Spring表达式语言" class="headerlink" title="Spring表达式语言"></a>Spring表达式语言</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​       Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>​        表达式语言给静态Java语言增加了动态功能。</p>
<p>​        SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h4 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h4><p> 表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>​       SpEL支持如下表达式：</p>
<p><strong>一、基本表达式：</strong>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p><strong>二、类相关表达式：</strong>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p><strong>三、集合相关表达式：</strong>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p><strong>四、其他表达式</strong>：模板表达式。</p>
<p><strong>注：SpEL表达式中的关键字是不区分大小写的。</strong></p>
<h3 id="SpEL基础"><a href="#SpEL基础" class="headerlink" title="SpEL基础"></a>SpEL基础</h3><h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>​       首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>​        SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>​        让我们看下代码片段吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression =</span><br><span class="line">                parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<p>1）创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</p>
<p>2）解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</p>
<p>3）构造上下文：准备比如变量定义等等表达式需要的上下文数据。</p>
<p>4）求值：通过Expression接口的getValue方法根据上下文获得表达式值。</p>
<p>是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h4 id="SpEL原理及接口"><a href="#SpEL原理及接口" class="headerlink" title="SpEL原理及接口"></a>SpEL原理及接口</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/日志相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/日志相关/" itemprop="url">日志相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T15:39:35+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="日志相关的类"><a href="#日志相关的类" class="headerlink" title="日志相关的类"></a>日志相关的类</h4><h4 id="Logger-getLogger和-LogFactory-getLog"><a href="#Logger-getLogger和-LogFactory-getLog" class="headerlink" title="Logger.getLogger和 LogFactory.getLog"></a>Logger.getLogger和 LogFactory.getLog</h4><p>Logger来自log4j自己的包。如果用Logger.getLogger，需要一个log4j的jar包，用此方式你只能依靠log4；</p>
<p>而LogFactory来自common-logging包。如果用LogFactory.getLog，你可以用任何实现了通用日志接口的日志记录器替换log4j，而程序不受影响。apache的common-logging包是通用日志接口，通过这个中间层，你可以随便指定到底用哪个日志系统。增加系统的灵活性。若log4j它不存在, commons-logging 会另行选择其它的日志实现类。 这样保证了程序中不一定要使用log4j这个日志文件了 </p>
<p>增强灵活性的理由：   </p>
<ol>
<li>首先在classpath下寻找自己的配置文件commons-logging.properties，如果找到，则使用其中定义的Log实现类；</li>
<li>如果找不到commons-logging.properties  文件，则再查找是否已定义系统环境变量  org.apache.commons.logging.Log ，找到则使用其定义的 Log 实现类；  </li>
<li>否则，查看 classpath 中是否有 Log4j 的包，如果发现，则自动使用 Log4j 作为日志实现类；  </li>
<li>否则，使用 JDK 自身的日志实现类（ JDK1.4 以后才有日志实现类）；  </li>
<li>否则，使用 commons-logging 自己提供的一个简单的日志实现类 SimpleLog ；  </li>
</ol>
<p>为了简化配置 commons-logging ，一般不使用 commons-logging 的配置文件，也不设置与 commons-logging 相关的系统环境变量，而只需将 Log4j 的 Jar 包放置到 classpash 中就可以了。这样就很简单地完成了 commons-logging 与 Log4j 的融合。   </p>
<p>根据不同的性质，日志信息通常被分成不同的级别，从低到高依次是：“调试（ DEBUG ）”“信息（ INFO ）”“警告（ WARN ）”“错误（ERROR ）”“致命错误（ FATAL ）”。   </p>
<p>commons-logging 仅仅对 Log4j( 当然还包括其它 LOG 实现 ) 作了一层包装，具体的日志输出还是在内部转交给身后的 Log4j 来处理，还有log4j会默认的去classes目录下去寻找log4j.properties 文件</p>
<p>apache common logging是一种log的框架接口,它本身并不实现log记录的功能,而是在运行时动态查找目前存在的日志库,调用相关的日志函数,从而隐藏具体的日志实现  </p>
<p>log4j是具体的日志实现,真正负责”写”日志的这个功能  </p>
<p>common logging本身不是log,你可以把它看做是一个日志的接口  </p>
<p>而log4j就是日志的实现  </p>
<p>使用common logging方式实现日志,主要的原因在于可以忽略底层的日志实现,或者说为以后的日志实现库的更换提供透明界面  </p>
<p>你可以考虑下,假设从log4j更换为logback,势必要重写所有原本使用log4j的源代码,而使用common logging的情况下,只需要更换jar包,而不需要对源代码做任何改动</p>
<p>做日志的时候一般是两者一起用，commons-logging工作原理做接口，log4j做实现，应用起来比单独的使用log4j要简单  </p>
<p>commons-logging工作原理:  </p>
<ol>
<li>首先在classpath下寻找自己的配置文件commons-logging.properties,如果找到,则使用其中定义的Log实现类  </li>
<li>如果找不到commons-logging.properties文件,则在查找是否已定义系统环境变量org.apache.commons.logging.Log,找到则使用其定义的Log实现类 </li>
<li>查看classpath中是否有Log4j的包,如果发现,则自动使用Log4j作为日志实现类 </li>
<li>使用JDK自身的日志实现类(JDK1.4以后才有日志实现类) </li>
<li>使用commons-logging自己提供的一个简单的日志实现类SimpleLog (以上顺序不保证完全准确,请参考官方文档) commons-logging总是能找到一个日志实现类,并且尽可能找到一个”最合适”的日志实现类. </li>
</ol>
<h3 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h3><h4 id="commons-logging和slf4j两种日志门面的使用"><a href="#commons-logging和slf4j两种日志门面的使用" class="headerlink" title="commons-logging和slf4j两种日志门面的使用"></a>commons-logging和slf4j两种日志门面的使用</h4><p>　　早期<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>项目使用最多的日志门面是commons-logging，log4j是推荐的日志实现库，需要的jar包为commons-logging.jar、log4j.jar。   </p>
<p>　　现今java项目推荐的日志门面是slf4j，log4j仍是推荐的日志实现库，需要的jar包为slf4j-api.jar、slf4j-log4j12.jar、log4j.jar，其中绑定包slf4j-log4j12.jar指定了要使用的实现库。   </p>
<p>　　commons-logging存在osgi问题，但早期项目多使用其作为日志门面，为保证兼容仍使用其作为日志门面，但通过slf4j的静态绑定技术来加载具体的日志库log4j，需要的jar包为commons-logging.jar、jcl-over-slf4j.jar、slf4j-api.jar、slf4j-log4j12.jar、log4j.jar，其中jcl-over-slf4j.jar将日志的接口重定向到slf4j。</p>
<pre><code> 　　使用log4j需先将日志的相关信息在属性文件properties或xml文件配置好，剩下的事情就是在项目中的适当位置打日志。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/21/Spring基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/Spring基础/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T19:37:39+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抄自：Iteye开涛博客 <a href="http://jinnianshilongnian.iteye.com/category/206533?page=2" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/category/206533?page=2</a></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/7.jpg?raw=true" alt=""></p>
<h3 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h3><h4 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h4><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/JavaEE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要另外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。<br>Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下Spring到底能帮我们做些什么？</p>
<h4 id="Spring能帮我们做什么"><a href="#Spring能帮我们做什么" class="headerlink" title="Spring能帮我们做什么"></a>Spring能帮我们做什么</h4><p>Spring除了不能帮我们写业务逻辑，其余的几乎什么都能帮助我们简化开发：</p>
<p>一、传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用Spring，则由Spring根据配置文件来进行创建及组装对象间依赖关系，只需要修改配置文件即可，无需重新编译。所以，<strong>Spring能帮我们根据配置文件创建及组装对象之间的依赖关系。</strong></p>
<p>二、当我们要进行一些日志记录、权限控制、性能统计等时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使有人说我把通用部分提取出来，那必然存在调用还是存在重复，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个要访问方法中；还有权限控制，必须在方法执行开始进行审核，想想这些是多么可怕而且是多么无聊的工作。如果采用Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过Spring支持的面向切面编程，在需要这些功能的地方动态添加这些功能，无需渗透到各个需要的方法或对象中；有人可能说了，我们可以使用”代理设计模式”或”包装器设计模式”，你可以使用这些，但是还是需要通过编程方式来完成上述功能，一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。所以，<strong>Spring面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。</strong></p>
<p>三、在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用Spring，我们只需获取连接，执行SQL，其他的都交给Spring来管理了，简单吧。所以，<strong>Spring能非常简单的帮我们管理数据库事务。</strong></p>
<p>四、Spring还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。</p>
<p>五、Spring还提供与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</p>
<p>六、Spring能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</p>
<p>Spring能帮我们做这么多事情，提供这么多功能和与那么多主流技术整合，而且是帮我们做了开发中比较头疼和困难的事情，那可能有人会问，难道只有Spring这一个框架，没有其他选择？当然有，比如EJB需要依赖应用服务器、开发效率低、在开发中小型项目是宰鸡拿牛刀，虽然发展到现在EJB比较好用了，但还是比较笨重还需要依赖应用服务器等。那为何需要使用Spring，而不是其他框架呢？让我们接着往下看。</p>
<h4 id="为何需要Spring？"><a href="#为何需要Spring？" class="headerlink" title="为何需要Spring？"></a>为何需要Spring？</h4><p>一、首先阐述几个概念</p>
<p><strong>1、应用程序：</strong>是能完成我们所需功能的成品，比如购物网站、OA系统。</p>
<p><strong>2、框架：</strong>是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就常见出来了。而且框架规定了你在开发应用程序时的整体框架，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</p>
<p><strong>3、非侵入式设计：</strong>从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</p>
<p><strong>4、轻量级及重量级：</strong>轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</p>
<p><strong>5、POJO：</strong>POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p>
<p><strong>6、容器：</strong>在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是<strong>装对象的的对象</strong>，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p>
<p><strong>7、控制反转：</strong>即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</p>
<p><strong>8、Bean：</strong>一般指容器管理对象，在Spring中指Spring IoC容器管理对象。</p>
<p>二 为什么需要Spring及Spring的优点</p>
<ul>
<li><strong>非常轻量级的容器：</strong>以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。而且核心JAR包非常小，Spring 3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</li>
<li><strong>AOP：</strong>AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</li>
<li><strong>简单的数据库事务管理：</strong>在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</li>
<li><strong>JDBC抽象及ORM框架支持：</strong>Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；并且完全支持Spring事务和使用Spring提供的一致的异常体系。</li>
<li><strong>灵活的Web层支持：</strong>Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</li>
<li>简化各种技术集成：提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</li>
</ul>
<p>Spring能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的MVC框架，可以把Spring看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。</p>
<h4 id="如何学好Spring？"><a href="#如何学好Spring？" class="headerlink" title="如何学好Spring？"></a>如何学好Spring？</h4><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。</p>
<h4 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h4><p><strong>Spring架构图</strong></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg?raw=true" alt=""></p>
<p><strong>核心容器：</strong>包括Core、Beans、Context、EL模块。</p>
<ul>
<li><strong>Core模块：</strong>封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li><strong>Beans模块：</strong>提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现”单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</li>
<li><strong>Context模块：</strong>以Core和Beans为基础，集成Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器声明周期、事件传播等；核心接口是ApplicationContext。</li>
<li><strong>EL模块：</strong>提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<p><strong>AOP、Aspects模块：</strong></p>
<ul>
<li><strong>AOP模块：</strong>Spring AOP 模块提供了符合 AOP Alliance规范的面向方面的编程(aspect-oriented programming) 实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</li>
<li><strong>Aspects模块：</strong>提供了对AspectJ 的集成，AspectJ 提供了比 Spring AOP 更强大的功能。</li>
</ul>
<p><strong>数据访问/集成模块：</strong>该模块包括了JDBC、ORM、OXM、JMS 和事务管理。</p>
<ul>
<li><strong>事务模块：</strong>该模块用于Spring 管理事务，只要是Spring管理对象都能得到Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</li>
<li><strong>JDBC模块：</strong>提供了一个JDBC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring 管理事务的好处。</li>
<li><strong>ORM模块：</strong>提供与流行的”对象-关系”映射框架的无缝继承，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</li>
<li><strong>OXM模块：</strong>提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans 和 XStream。</li>
<li><strong>JMS模块：</strong> 用于JMS(Java Messaging Service)，提供一套”消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li>
</ul>
<p><strong>Web/Remoting模块：</strong>Web/Remoting 模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</p>
<ul>
<li><strong>Web模块：</strong>提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问(RMI、Hessian、Burlap)以及Web Service 支持，并提供了一个RestTemplate类来提供方便的Restful service 访问。</li>
<li><strong>Web-Servlet模块：</strong>提供了一个Spring MVC Web框架实现。</li>
<li><strong>Web-Struts 模块：</strong>提供了与Struts无缝集成，Struts1.x和Struts2.x都支持</li>
</ul>
<p><strong>Test模块：</strong>Spring 支持 Junit 和TestNG 测试框架，而且还额外提供了一些基于Spring 的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p>
<h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><p>Spring可以应用到许多场景，从最简单的标准Java SE 程序到企业级应用程序都能使用Spring来构建。以下介绍几个比较流行的应用场景：</p>
<ul>
<li><strong>典型Web应用程序应用场景：</strong></li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.jpg?raw=true" alt=""></p>
<p>在Web应用程序应用场景中，典型的三层架构：数据模型层实现域对象；数据访问层实现数据访问；逻辑层实现业务逻辑；web层提供页面展示；所有这些层组件都由Spring进行管理，享受到Spring事务管理、AOP等好处，而且请求唯一入口就是DispachterServlet，它通过把请求映射为相应web层组件来实现相应请求功能。</p>
<ul>
<li><strong>远程访问应用场景：</strong></li>
</ul>
<p>Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现，后边会有介绍；</p>
<ul>
<li><strong>EJB应用场景：</strong></li>
</ul>
<p>Spring也可以与EJB轻松集成，后边会详细介绍。</p>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><h4 id="IoC基础"><a href="#IoC基础" class="headerlink" title="IoC基础"></a>IoC基础</h4><h5 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h5><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<ul>
<li><strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li>
<li><strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</li>
</ul>
<p>图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E4%BC%A0%E7%BB%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg?raw=true" alt=""></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/IoCDI%E5%AE%B9%E5%99%A8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.JPG?raw=true" alt=""></p>
<h5 id="IoC能做什么"><a href="#IoC能做什么" class="headerlink" title="IoC能做什么"></a>IoC能做什么</h5><p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了”主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>IoC很好的体现了面向对象设计法则之一 – 好莱坞法则：”别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h5 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h5><p><strong>DI–Dependency  Injecton</strong>，即”依赖注入”：是组件之间<strong>依赖关系由容器在运行期决定</strong>，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可以指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：”谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><strong>谁依赖于谁：</strong>当然是某个容器管理对象依赖于IoC容器；”被注入对象的对象”依赖于”依赖对象”；</li>
<li><strong>为什么需要依赖：</strong>容器管理对象需要IoC容器来提供对象需要的外部资源；</li>
<li><strong>谁注入谁：</strong>很明细是IoC容器注入某个对象，也就是注入”依赖对象”；</li>
<li><strong>注入了什么</strong>：就是注入某个对象所需要的外部资源(包括对象、资源、常量数据)。</li>
</ul>
<p>IoC和DI有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较模糊(可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系)，所以2004年大师级人物Martin Fowler又给出了一个新的名字：”依赖注入”，相对于IoC而言，<strong>“依赖注入”明确描述了”被注入对象依赖IoC容器配置依赖对象”。</strong></p>
<h4 id="IoC容器基本原理"><a href="#IoC容器基本原理" class="headerlink" title="IoC容器基本原理"></a>IoC容器基本原理</h4><h5 id="Ioc容器的概念"><a href="#Ioc容器的概念" class="headerlink" title="Ioc容器的概念"></a>Ioc容器的概念</h5><p>IoC容器就是具有依赖注入功能的容器，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IoC容器进行组装。在Spring中BeanFactory是IoC容器的实际代表者。</p>
<p>Spring IoC容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IoC容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于xml配置文件进行配置元数据，而且<strong>Spring与配置文件完全解耦的</strong>，可以使用其他任何可能的方式进行配置元数据，比如注解、基于java文件的、基于属性文件的配置都可以。</p>
<p>那么Spring IoC容器管理的对象叫什么呢？</p>
<h5 id="Bean的概念"><a href="#Bean的概念" class="headerlink" title="Bean的概念"></a>Bean的概念</h5><p>由IoC容器管理的哪些组成你应用程序的对象我们就叫它Bean，Bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了。那IoC怎样确定如何实例化Bean、管理Bean之间的依赖关系以及管理Bean呢？这就需要配置元数据，在Spring中由BeanDefinition代表，后边会详细介绍，配置元数据指定如何实例化Bean、如何组装Bean等。概念知道的差不多了，让我们来做个简单的例子。</p>
<h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>准备Jar包</p>
<p>1、 <strong>核心jar包：</strong></p>
<p>org.springframework.asm-3.0.5.RELEASE.jar<br>org.springframework.core-3.0.5.RELEASE.jar<br>org.springframework.beans-3.0.5.RELEASE.jar<br>org.springframework.context-3.0.5.RELEASE.jar<br>org.springframework.expression-3.0.5.RELEASE.jar</p>
<p>依赖的jar包：从下载的spring-framework-3.0.5.RELEASE-dependencies.zip中查找如下依赖jar包</p>
<p>com.springsource.org.apache.log4j-1.2.15.jar</p>
<p>com.springsource.org.apache.commons.logging-1.1.1.jar</p>
<p>com.springsource.org.apache.commons.collections-3.2.1.jar</p>
<p>pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zero.spring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--集中定义依赖版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>3.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring相关jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.apache.commons.logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.apache.log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.apache.commons.collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Junit4--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HelloApi接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter2.helloworld;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloApi</span> </span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloImpl类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">HelloApi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、读取配置文件实例化一个IoC容器</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        <span class="comment">//2、从容器中获取Bean，注意此处完全"面向接口编程，而不是面向实现"</span></span><br><span class="line">        HelloApi helloApi = context.getBean(<span class="string">"hello"</span>, HelloApi.class);</span><br><span class="line">        <span class="comment">//3、执行业务逻辑</span></span><br><span class="line">        helloApi.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans</span><br><span class="line">        xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- id 表示你这个组件的名字，<span class="class"><span class="keyword">class</span>表示组件类 --&gt;</span></span><br><span class="line">    &lt;bean id="hello" class="com.zero.spring.chapter.HelloImpl"&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>例子很简单。</p>
<p>下面深入的理解一下容器和Bean。</p>
<h5 id="详解IoC"><a href="#详解IoC" class="headerlink" title="详解IoC"></a>详解IoC</h5><p>在Spring IoC容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IoC容器最基本的功能；而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory  ，还提供了与Spring AOP集成、国际化处理、事件传播及提供不同层次的context实现(如针对web应用的WebApplicationContext)。简单说，BeanFactory提供了IoC容器最基本功能，而ApplicationContext则增加了更多支持企业级功能支持。ApplicationContext完全继承BeanFactory，因而BeanFactory所具有的语义也适用于ApplicationContext。</p>
<p>容器实现一览： </p>
<ul>
<li><strong>XmlBeanFactory</strong>：BeanFactory实现，提供基本的IoC容器功能，可以从classpath或文件系统等获取资源；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）       File file = <span class="keyword">new</span> File(<span class="string">"fileSystemConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">           Resource resource = <span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line"></span><br><span class="line">           BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br><span class="line"></span><br><span class="line">  （<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">          Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"classpath.xml"</span>);                 </span><br><span class="line"></span><br><span class="line">          BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ClassPathXmlApplicationContext：</strong> ApplicationContext实现，从classpath获取配置文件；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>FileSystemXmlApplicationContext:</strong>ApplicationContext实现， 从文件系统获取配置文件。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory1 = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"fileSystemConfig.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>ApplicationContext接口获取Bean方法简介：</p>
<ul>
<li>Object getBean(String name)根据名称返回一个Bean，客户端需要自己进行类型转换；</li>
<li>T getBean(String name,Class<t> requiredType)根据名称和指定的类型返回一个Bean，客户端无需自己进行类型转换，如果类型抓换失败，容器抛出异常；</t></li>
<li>T getBean(Class<t> requiredType) 根据指定的类型返回一个Bean，客户端无需自己进行类型转换，如果没有或有多于一个Bean存在容器将抛出异常； </t></li>
<li>Map&lt;String, T&gt; getBeansOfType(Class<t> type) 根据指定的类型返回一个键值为名字和值为Bean对象的 Map，如果没有Bean对象存在则返回空的Map。 </t></li>
</ul>
<p>让我们来看下IoC容器到底是如何工作。在此我们以xml配置方式来分析一下：</p>
<p> <strong>一、准备配置文件：</strong>就像前边Hello World 配置文件一样，在配置文件中声明Bean定义也就是BeanDefinition配置元数据。</p>
<p><strong>二、由IoC容器进行解析元数据：</strong>IoC容器的Bean Reader读取并解析配置文件，根据定义生成Bean Definition配置元数据对象，IoC容器根据BeanDefinition进行实例化、配置及组装Bean。</p>
<p><strong>三、实例化IoC容器：</strong>由客户端实例化容器，获取需要的Bean。</p>
<p>整个过程是不是很简单，执行过程如图2-5，其实IoC容器很容易使用，主要是如何进行Bean定义。下一章我们详细介绍定义Bean。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/SpringIoC%E5%AE%B9%E5%99%A8.jpg?raw=true" alt=""></p>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>除了测试程序的代码外，也就是程序入口，所有代码都没有出现Spring任何组件，而且我们写的代码没有实现框架拥有的接口，因而能非常容易的替换掉Spring，是不是非侵入。</p>
<p>客户端代码完全面向接口编程，无需知道实现类，可以通过修改配置文件来更换接口实现，客户端代码不需要任何修改。是不是低耦合。</p>
<p>如果在开发初期没有真正的实现，我们可以模拟一个实现来测试，不耦合代码，是不是很方便测试。</p>
<p>Bean之间几乎没有依赖关系，是不是很容易重用。</p>
<h4 id="IoC的配置使用"><a href="#IoC的配置使用" class="headerlink" title="IoC的配置使用"></a>IoC的配置使用</h4><h5 id="XML配置的结构"><a href="#XML配置的结构" class="headerlink" title="XML配置的结构"></a>XML配置的结构</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">”resource1.xml”/</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”bean1”class</span>=<span class="string">””</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”bean2”class</span>=<span class="string">””</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">”bean2”class</span>=<span class="string">””</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">alias</span>=<span class="string">"bean3"</span> <span class="attr">name</span>=<span class="string">"bean2"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">”resource2.xml”/</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、<bean>标签主要用来进行Bean定义；</bean></p>
<p>2、alias用于定义Bean别名的；</p>
<p>3、import用于导入其他配置文件的Bean定义，这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new String[] {“config1.xml”, config2.xml}）传给ApplicationContext实现进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用Bean Definition Reader 读取Bean定义，内部实现没有任何区别。<import>标签可以放在<beans>下的任何位置，没有顺序关系。</beans></import></p>
<h5 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h5><p>Spring IoC容器目的就是管理Bean，这些Bean将根据配置文件中的Bean定义进行创建，而Bean定义在容器内部由BeanDefinition对象表示，该定义主要包含以下信息：</p>
<ul>
<li>全限定类名（FQN）：用于定义Bean的实现类;</li>
<li>Bean行为定义：这些定义了Bean在容器中的行为；包括作用域（单例、原型创建）、是否惰性初始化及生命周期等；</li>
<li>Bean创建方式定义：说明是通过构造器还是工厂方法创建Bean；</li>
<li>Bean之间关系定义：即对其他bean的引用，也就是依赖关系定义，这些引用bean也可以称之为同事bean 或依赖bean，也就是依赖注入。</li>
</ul>
<p>Bean定义只有“全限定类名”在当使用构造器或静态工厂方法进行实例化bean时是必须的，其他都是可选的定义。难道Spring只能通过配置方式来创建Bean吗？回答当然不是，某些SingletonBeanRegistry接口实现类实现也允许将那些非BeanFactory创建的、已有的用户对象注册到容器中，这些对象必须是共享的，比如使用DefaultListableBeanFactory 的registerSingleton() 方法。不过建议采用元数据定义。</p>
<h5 id="Bean的命名"><a href="#Bean的命名" class="headerlink" title="Bean的命名"></a>Bean的命名</h5><p>每个Bean可以有一个或多个id(或称之为标识符或名字)，在这里我们把<strong>第一个id称为”标识符”,其余id叫做”别名”</strong>；这些id在IoC容器中必须唯一。如何为Bean指定id呢，有以下几种方式：</p>
<p>一、  不指定id，只配置必须的全限定类名，由IoC容器为其生成一个标识，客户端必须通过接口“T getBean(Class<t> requiredType)”获取Bean； </t></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">”</span> <span class="attr">cn.javass.spring.chapter2.helloworld.HelloImpl</span>”/&gt;</span></span><br></pre></td></tr></table></figure>
<p>而是代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">BeanFactory beanFactory =  </span><br><span class="line">   <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean1.xml"</span>);  </span><br><span class="line">    <span class="comment">//根据类型获取bean  </span></span><br><span class="line">    HelloApi helloApi = beanFactory.getBean(HelloApi.class);  </span><br><span class="line">    helloApi.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 二、指定id，必须在Ioc容器中唯一；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”</span> <span class="attr">bean</span>” <span class="attr">class</span>=<span class="string">”</span> <span class="attr">cn.javass.spring.chapter2.helloworld.HelloImpl</span>”/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码片段如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean2.xml"</span>);  </span><br><span class="line"><span class="comment">//根据id获取bean  </span></span><br><span class="line">    HelloApi bean = beanFactory.getBean(<span class="string">"bean"</span>, HelloApi.class);  </span><br><span class="line">    bean.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、指定name，这样name就是“标识符”，必须在Ioc容器中唯一；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">”</span> <span class="attr">bean</span>” <span class="attr">class</span>=<span class="string">”</span> <span class="attr">cn.javass.spring.chapter2.helloworld.HelloImpl</span>”/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码片段如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean3.xml"</span>);  </span><br><span class="line">    <span class="comment">//根据name获取bean  </span></span><br><span class="line">HelloApi bean = beanFactory.getBean(<span class="string">"bean"</span>, HelloApi.class);  </span><br><span class="line">bean.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、指定id和name，id就是标识符，而name就是别名，必须在Ioc容器中唯一；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”bean1”name</span>=<span class="string">”alias1”</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">”</span> <span class="attr">cn.javass.spring.chapter2.helloworld.HelloImpl</span>”/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 如果id和name一样，IoC容器能检测到，并消除冲突 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">name</span>=<span class="string">"bean3"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean4.xml"</span>);  </span><br><span class="line">    <span class="comment">//根据id获取bean  </span></span><br><span class="line">    HelloApi bean1 = beanFactory.getBean(<span class="string">"bean1"</span>, HelloApi.class);  </span><br><span class="line">    bean1.sayHello();  </span><br><span class="line">    <span class="comment">//根据别名获取bean  </span></span><br><span class="line">    HelloApi bean2 = beanFactory.getBean(<span class="string">"alias1"</span>, HelloApi.class);  </span><br><span class="line">    bean2.sayHello();  </span><br><span class="line">    <span class="comment">//根据id获取bean  </span></span><br><span class="line">    HelloApi bean3 = beanFactory.getBean(<span class="string">"bean3"</span>, HelloApi.class);  </span><br><span class="line">    bean3.sayHello();  </span><br><span class="line">    String[] bean3Alias = beanFactory.getAliases(<span class="string">"bean3"</span>);  </span><br><span class="line">    <span class="comment">//因此别名不能和id一样，如果一样则由IoC容器负责消除冲突  </span></span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>, bean3Alias.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、指定多个name，多个name用“，”、“；”、“ ”分割，第一个被用作标识符，其他的（alias1、alias2、alias3）是别名，所有标识符也必须在Ioc容器中唯一；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">”</span> <span class="attr">bean1</span>;<span class="attr">alias11</span>,<span class="attr">alias12</span>;<span class="attr">alias13</span> <span class="attr">alias14</span>”  </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">”</span> <span class="attr">cn.javass.spring.chapter2.helloworld.HelloImpl</span>”/&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 当指定id时，name指定的标识符全部为别名 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">name</span>=<span class="string">"alias21;alias22"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean5.xml"</span>);  </span><br><span class="line">    <span class="comment">//1根据id获取bean  </span></span><br><span class="line">    HelloApi bean1 = beanFactory.getBean(<span class="string">"bean1"</span>, HelloApi.class);  </span><br><span class="line">    bean1.sayHello();  </span><br><span class="line">    <span class="comment">//2根据别名获取bean  </span></span><br><span class="line">    HelloApi alias11 = beanFactory.getBean(<span class="string">"alias11"</span>, HelloApi.class);  </span><br><span class="line">    alias11.sayHello();  </span><br><span class="line">    <span class="comment">//3验证确实是四个别名         </span></span><br><span class="line">    String[] bean1Alias = beanFactory.getAliases(<span class="string">"bean1"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"=======namingbean5.xml bean1 别名========"</span>);  </span><br><span class="line">    <span class="keyword">for</span>(String alias : bean1Alias) &#123;  </span><br><span class="line">        System.out.println(alias);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Assert.assertEquals(<span class="number">4</span>, bean1Alias.length);  </span><br><span class="line">    <span class="comment">//根据id获取bean  </span></span><br><span class="line">    HelloApi bean2 = beanFactory.getBean(<span class="string">"bean2"</span>, HelloApi.class);  </span><br><span class="line">    bean2.sayHello();  </span><br><span class="line">    <span class="comment">//2根据别名获取bean  </span></span><br><span class="line">    HelloApi alias21 = beanFactory.getBean(<span class="string">"alias21"</span>, HelloApi.class);  </span><br><span class="line">    alias21.sayHello();  </span><br><span class="line">    <span class="comment">//验证确实是两个别名  </span></span><br><span class="line">    String[] bean2Alias = beanFactory.getAliases(<span class="string">"bean2"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"=======namingbean5.xml bean2 别名========"</span>);  </span><br><span class="line">    <span class="keyword">for</span>(String alias : bean2Alias) &#123;  </span><br><span class="line">        System.out.println(alias);  </span><br><span class="line">    &#125;     </span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, bean2Alias.length);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>六、使用<alias>标签指定别名，别名也必须在IoC容器中唯一</alias></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">alias</span>=<span class="string">"alias1"</span> <span class="attr">name</span>=<span class="string">"bean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">alias</span>=<span class="string">"alias2"</span> <span class="attr">name</span>=<span class="string">"bean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/namingbean6.xml"</span>);  </span><br><span class="line">    <span class="comment">//根据id获取bean  </span></span><br><span class="line">    HelloApi bean = beanFactory.getBean(<span class="string">"bean"</span>, HelloApi.class);  </span><br><span class="line">   bean.sayHello();  </span><br><span class="line">    <span class="comment">//根据别名获取bean  </span></span><br><span class="line">    HelloApi alias1 = beanFactory.getBean(<span class="string">"alias1"</span>, HelloApi.class);  </span><br><span class="line">    alias1.sayHello();  </span><br><span class="line">    HelloApi alias2 = beanFactory.getBean(<span class="string">"alias2"</span>, HelloApi.class);  </span><br><span class="line">    alias2.sayHello();  </span><br><span class="line">    String[] beanAlias = beanFactory.getAliases(<span class="string">"bean"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"=======namingbean6.xml bean 别名========"</span>);  </span><br><span class="line">    <span class="keyword">for</span>(String alias : beanAlias) &#123;  </span><br><span class="line">        System.out.println(alias);  </span><br><span class="line">   &#125;  </span><br><span class="line">   System.out.println(<span class="string">"=======namingbean6.xml bean 别名========"</span>);  </span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, beanAlias.length);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从定义来看，name或id如果指定它们中的一个时都作为“标识符”，那为什么还要有id和name同时存在呢？这是因为当使用基于XML的配置元数据时，在XML中id是一个真正的XML id属性，因此当其他的定义来引用这个id时就体现出id的好处了，可以利用XML解析器来验证引用的这个id是否存在，从而更早的发现是否引用了一个不存在的bean，而使用name，则可能要在真正使用bean时才能发现引用一个不存在的bean。</p>
<p>注：ID可以被xml解析器验证是否存在，而name只有在真正调用的时候才知道</p>
<ul>
<li><strong>Bean命名约定：</strong>Bean的命名遵循XML命名规范，但最好符合Java命名规范，由”字母、数字、下划线组成”，而且应该养成一个良好的命名习惯，比如采用”驼峰式”,即第一个单词首字母开始，从第二个单词开始首字母大写开始，这样可以增加可读性。</li>
</ul>
<h5 id="实例化Bean"><a href="#实例化Bean" class="headerlink" title="实例化Bean"></a>实例化Bean</h5><p>Spring IoC容器如何实例化Bean呢？传统应用程序可以通过new和反射方式进行实例化Bean。而Spring IoC容器则需要根据Bean定义里的配置元数据使用反射机制来创建Bean。在Spring IoC容器中根据Bean定义创建Bean主要有以下几种方式：</p>
<p> 一、使用构造器实例化Bean：这是最简单的方式，Spring IoC容器即能使用默认空构造器也能使用有参数构造器两种方式创建Bean，如以下方式指定要创建的Bean类型：</p>
<p> 使用空构造器进行定义，使用此种方式，class属性指定的类必须有空构造器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.HelloImpl2"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用有参数构造器进行定义，使用此中方式，可以使用&lt; constructor-arg &gt;标签指定构造器参数值，其中index表示位置，value表示常量值，也可以指定引用，指定引用使用ref来引用另一个Bean定义，后边会详细介绍：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.HelloImpl2"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 指定构造器参数 --&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello Spring!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>知道如何配置了，让我们做个例子的例子来实践一下吧：</p>
<p>（1）准备Bean class(HelloImpl2.java)，该类有一个空构造器和一个有参构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter2;   </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl2</span> <span class="keyword">implements</span> <span class="title">HelloApi</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">private</span> String message;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                  <span class="keyword">this</span>.message = <span class="string">"Hello World!"</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">         <span class="function">Public <span class="title">HelloImpl2</span><span class="params">(String message)</span> </span>&#123;  </span><br><span class="line">                  <span class="keyword">this</span>.message = message;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="meta">@Override</span>  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                  System.out.println(message);  </span><br><span class="line">           &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)在配置文件xml中配置Bean定义，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用默认构造器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl2"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用有参数的构造器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl2"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定构造器参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello Spring"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）配置完了，让我们写段测试代码（InstantiatingContainerTest）来看下是否工作吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、读取配置文件实例化一个IoC容器</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        <span class="comment">//2、从容器中获取Bean，注意此处完全"面向接口编程，而不是面向实现"</span></span><br><span class="line">        HelloApi bean1 = beanFactory.getBean(<span class="string">"bean1"</span>, HelloApi.class);</span><br><span class="line">        <span class="comment">//3、执行业务逻辑</span></span><br><span class="line">        bean1.sayHello();</span><br><span class="line">        HelloApi bean2 = beanFactory.getBean(<span class="string">"bean2"</span>,HelloApi.class);</span><br><span class="line">        bean2.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、使用静态工厂方式实例化Bean，使用这种方式除了指定必须的class属性，还要指定factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也允许指定方法参数，spring IoC容器将调用此属性指定的方法来获取Bean，配置如下所示：</p>
<p>​    （1）先来看看静态工厂类代码吧HelloApiStaticFactory：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApiStaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloApi <span class="title">newInstance</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回需要的Bean实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）静态工厂写完了，让我们在配置文件(resources/**.xml)配置Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用静态工厂方法 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.HelloApiStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello Spring!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）配置完了，让我们写段测试代码（InstantiatingContainerTest）来看下是否工作吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInstantiatingBeanByStaticFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//使用静态工厂方法  </span></span><br><span class="line">       BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chaper2/instantiatingBean.xml"</span>);  </span><br><span class="line">       HelloApi bean3 = beanFactory.getBean(<span class="string">"bean3"</span>, HelloApi.class);  </span><br><span class="line">       bean3.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、使用实例工厂方法实例化Bean，使用这种方式不能指定class属性，此时必须使用factory-bean属性来指定工厂Bean，factory-method属性指定实例化Bean的方法，而且使用实例工厂方法允许指定方法参数，方式和使用构造器方式一样，配置如下：</p>
<p> （1）实例工厂类代码（HelloApiInstanceFactory.java）如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter2;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApiInstanceFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloApi <span class="title">newInstance</span><span class="params">(String message)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> HelloImpl2(message);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）让我们在配置文件(resources/chapter2/instantiatingBean.xml)配置Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!—1、定义实例工厂Bean</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanInstanceFactory"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.HelloApiInstanceFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">!—2、使用实例工厂Bean创建Bean</span> <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean4"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">factory-bean</span>=<span class="string">"beanInstanceFactory"</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello Spring!"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）测试代码InstantiatingBeanTest：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInstantiatingBeanByInstanceFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//使用实例工厂方法  </span></span><br><span class="line">       BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter2/instantiatingBean.xml"</span>);  </span><br><span class="line">       HelloApi bean4 = beanFactory.getBean(<span class="string">"bean4"</span>, HelloApi.class);  </span><br><span class="line">       bean4.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过以上例子我们已经基本掌握了如何实例化Bean了，大家是否注意到？这三种方式只是配置不一样，从获取方式看完全一样，没有任何不同。这也是Spring IoC的魅力，Spring IoC帮你创建Bean，我们只管使用就可以了，是不是很简单。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>到此我们已经讲完了Spring IoC基础部分，包括IoC容器概念，如何实例化容器，Bean配置、命名及实例化，Bean获取等等。不知大家是否注意到目前为止，我们只能通过简单的实例化Bean，没有涉及Bean之间关系。接下来一章让我们进入配置Bean之间关系章节，也就是依赖注入。</p>
<h3 id="DI的配置使用"><a href="#DI的配置使用" class="headerlink" title="DI的配置使用"></a>DI的配置使用</h3><h4 id="依赖和依赖注入"><a href="#依赖和依赖注入" class="headerlink" title="依赖和依赖注入"></a>依赖和依赖注入</h4><p>​    传统应用程序设计中所说的依赖一般指”类之间的关系”，那让我们复习一下类之间的关系：</p>
<ul>
<li><strong>泛化：</strong>表示类与类之间的继承关系、接口与接口之间的继承关系；</li>
<li><strong>实现：</strong>表示类对接口的实现；</li>
<li><strong>依赖</strong>：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。</li>
<li><strong>关联：</strong>表示类与类或类与接口之间的依赖关系，表现为“拥有关系”；具体到代码可以用实例变量来表示；</li>
<li><strong>聚合：</strong>属于是关联的特殊情况，体现部分-整体关系，是一种弱拥有关系；整体和部分可以有不一样的生命周期；是一种弱关联；</li>
<li><strong>组合：</strong>属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；整体与部分有相同的生命周期，是一种强关联；</li>
</ul>
<p>Spring IoC容器的依赖有两层含义：Bean依赖容器和容器注入Bean的依赖资源：</p>
<ul>
<li><strong>Bean依赖容器：</strong>：也就是说Bean要依赖于容器，这里的依赖是指容器负责创建Bean并管理Bean的生命周期，正是由于由容器来控制创建Bean并注入依赖，也就是控制权被反转了，这也正是IoC名字的由来，<strong>此处的有依赖是指Bean和容器之间的依赖关系。</strong></li>
<li><strong>容器注入Bean的依赖资源：</strong>容器负责注入Bean的依赖资源，依赖资源可以是Bean、外部文件、常量数据等，在Java中都反映为对象，并且由容器负责组装Bean之间的依赖关系，<strong>此处的依赖是指Bean之间的依赖关系，可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系。</strong></li>
</ul>
<p>为什么要应用依赖注入，应用依赖注入能给我们带来哪些好处呢？</p>
<ul>
<li><strong>动态替换Bean依赖对象，程序更灵活：</strong>替换Bean依赖对象，无需修改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能随时动态的替换Bean的依赖对象，无需修改java源文件；</li>
<li><strong>更好实践面向接口编程，代码更清晰：</strong>：在Bean中只需指定依赖对象的接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；</li>
<li><strong>更好实践优先使用对象组合，而不是类继承：</strong>因为IoC容器采用注入依赖，也就是组合对象，从而更好的实践对象组合。</li>
</ul>
<p>采用对象组合，Bean的功能可能由几个依赖Bean的功能组合而成，其Bean本身可能只提供少许功能或根本无任何功能，全部委托给依赖Bean，对象组合具有动态性，能更方便的替换掉依赖Bean，从而改变Bean功能；</p>
<p>而如果采用类继承，Bean没有依赖Bean，而是采用继承方式添加新功能，，而且功能是在编译时就确定了，不具有动态性，而且采用类继承导致Bean与子Bean之间高度耦合，难以复用。</p>
<ul>
<li><strong>增加Bean可复用性：</strong>依赖于对象组合，Bean更可复用且复用更简单；</li>
<li><strong>降低Bean之间耦合：</strong>由于我们完全采用面向接口编程，在代码中没有直接引用Bean依赖实现，全部引用接口，而且不会出现显示的创建依赖对象代码，而且这些依赖是由容器来注入，很容易替换依赖实现类，从而降低Bean与依赖之间耦合；</li>
<li><strong>代码结构更清晰：</strong>要应用依赖注入，代码结构要按照规约方式进行书写，从而更好的应用一些最佳实践，因此代码结构更清晰。</li>
</ul>
<p>从以上我们可以看出，其实依赖注入只是一种装配对象的手段，设计的类结构才是基础，如果设计的类结构不支持依赖注入，Spring IoC容器也注入不了任何东西，从而从根本上说<strong>“如何设计好类结构才是关键，依赖注入只是一种装配对象手段”。</strong></p>
<p>前边IoC一章我们已经了解了Bean依赖容器，那容器如何注入Bean的依赖资源，Spring IoC容器注入依赖资源主要有以下两种基本实现方式：</p>
<p>​      <strong>构造器注入：</strong>就是容器实例化Bean时注入那些依赖，通过在在Bean定义中指定构造器参数进行注入依赖，包括实例工厂方法参数注入依赖，<strong>但静态工厂方法参数不允许注入依赖</strong>；</p>
<p>​      <strong>setter注入</strong>：通过setter方法进行注入依赖；</p>
<p>​      <strong>方法注入</strong>：能通过配置方式替换掉Bean方法，也就是通过配置改变Bean方法 功能。</p>
<p> 我们已经知道注入实现方式了，接下来让我们来看看具体配置吧。</p>
<h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>​       使用构造器注入通过配置构造器参数实现，<strong>构造器参数就是依赖</strong>。除了构造器方式，还有静态工厂、实例工厂方法可以进行构造器注入。如图3-1所示：</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>图3-1 实例化 </p>
<p>构造器注入可以根据参数索引注入、参数类型注入或Spring3支持的参数名注入，但参数名注入是有限制的，需要使用在编译程序时打开调试模式（即在编译时使用“javac –g:vars”在class文件中生成变量调试信息，默认是不包含变量调试信息的，从而能获取参数名字，否则获取不到参数名字）或在构造器上使用@ConstructorProperties（java.beans.ConstructorProperties）注解来指定参数名。</p>
<p> 首先让我们准备测试构造器类HelloImpl3.java，该类只有一个包含两个参数的构造器：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl3</span> <span class="keyword">implements</span> <span class="title">HelloApi</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@java.beans.ConstructorProperties(&#123;"message", "index"&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl3</span><span class="params">(String message, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(index + <span class="string">":"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一、根据参数索引注入，使用标签“<constructor-arg index="1" value="1">”来指定注入的依赖，其中“index”表示索引，从0开始，即第一个参数索引为0，“value”来指定注入的常量值，配置方式如下：</constructor-arg></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%8F%82%E6%95%B0%E7%B4%A2%E5%BC%95%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>二、根据参数类型进行注入，使用标签“<constructor-arg type="java.lang.String" value="Hello World!">”来指定注入的依赖，其中“type”表示需要匹配的参数类型，可以是基本类型也可以是其他类型，如“int”、“java.lang.String”，“value”来指定注入的常量值，配置方式如下：</constructor-arg></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>三、根据参数名进行注入，使用标签“<constructor-arg name="message" value="Hello World!">”来指定注入的依赖，其中“name”表示需要匹配的参数名字，“value”来指定注入的常量值，配置方式如下：</constructor-arg></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%8F%82%E6%95%B0%E5%90%8D%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>四、让我们来用具体的例子来看一下构造器注入怎么使用吧。</p>
<p> （1）首先准备Bean类，在此我们就使用“HelloImpl3”这个类。</p>
<p> （2）有了Bean类，接下来要进行Bean定义配置，我们需要配置三个Bean来完成上述三种依赖注入测试，其中Bean ”byIndex”是通过索引注入依赖；Bean ”byType”是根据类型进行注入依赖；Bean ”byName”是根据参数名字进行注入依赖，具体配置文件（resources/chapter3/ constructorDependencyInject.xml）如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过构造器参数索引方式依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byIndex"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过构造器参数类型方式依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byType"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过构造器参数名称方式依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byName"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（4）接下来让我们测试一下配置是否工作，具体测试代码（cn.javass.spring.chapter3. DependencyInjectTest）如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line"><span class="comment">//获取根据参数索引依赖注入的Bean</span></span><br><span class="line">        HelloApi byIndex = beanFactory.getBean(<span class="string">"byIndex"</span>, HelloApi.class);</span><br><span class="line">        byIndex.sayHello();</span><br><span class="line"><span class="comment">//获取根据参数类型依赖注入的Bean</span></span><br><span class="line">        HelloApi byType = beanFactory.getBean(<span class="string">"byType"</span>, HelloApi.class);</span><br><span class="line">        byType.sayHello();</span><br><span class="line"><span class="comment">//获取根据参数名字依赖注入的Bean</span></span><br><span class="line">        HelloApi byName = beanFactory.getBean(<span class="string">"byName"</span>, HelloApi.class);</span><br><span class="line">        byName.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       通过以上测试我们已经会基本的构造器注入配置了，在测试通过参数名字注入时，除了可以使用以上方式，还可以通过在构造器上添加@java.beans.ConstructorProperties({“message”, “index”})注解来指定参数名字，在HelloImpl3构造器上把注释掉的“ConstructorProperties”打开就可以了，这个就留给大家做练习，自己配置然后测试一下。</p>
<p> 五、大家已经会了构造器注入，那让我们再看一下静态工厂方法注入和实例工厂注入吧，其实它们注入配置是完全一样，在此我们只示范一下静态工厂注入方式和实例工厂方式配置，测试就留给大家自己练习：</p>
<p>​        （1）静态工厂类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂类  </span></span><br><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> cn.javass.spring.chapter2.helloworld.HelloApi;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectByStaticFactory</span> </span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloApi <span class="title">newInstance</span><span class="params">(String message, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> HelloImpl3(message, index);  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        静态工厂类Bean定义配置文件（chapter3/staticFactoryDependencyInject.xml）</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byIndex"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.DependencyInjectByStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byType"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.DependencyInjectByStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byName"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.DependencyInjectByStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）实例工厂类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例工厂类  </span></span><br><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> cn.javass.spring.chapter2.helloworld.HelloApi;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectByInstanceFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloApi <span class="title">newInstance</span><span class="params">(String message, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloImpl3(message, index);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        实例工厂类Bean定义配置文件（chapter3/instanceFactoryDependencyInject.xml）</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.DependencyInjectByInstanceFactory"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byIndex"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span>  <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byType"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"byName"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       （3）测试代码和构造器方式完全一样，只是配置文件不一样，大家只需把测试文件改一下就可以了。还有一点需要大家注意就是静态工厂方式和实例工厂方式根据参数名字注入的方式只支持通过在class文件中添加“变量调试信息”方式才能运行，ConstructorProperties注解方式不能工作，它只对构造器方式起作用，<strong>不建议使用根据参数名进行构造器注入</strong>。</p>
<h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h5><p>​       setter注入，是通过在通过构造器、静态工厂或实例工厂实例好Bean后，通过调用Bean类的setter方法进行注入依赖，如图3-3所示：</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/setter%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>图3-3 setter注入方式</p>
<p>​       </p>
<p> setter注入方式只有一种根据setter名字进行注入：</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/setter%E6%B3%A8%E5%85%A52.JPG?raw=true" alt=""></p>
<p>​       知道配置方式了，接下来先让我们来做个简单例子吧。</p>
<p> （1）准备测试类HelloImpl4，需要两个setter方法“setMessage”和“setIndex”：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld4</span> <span class="keyword">implements</span> <span class="title">HelloApi</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(index + <span class="string">":"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       （2）配置Bean定义，具体配置文件（resources/chapter3/setterDependencyInject.xml）片段如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过setter方式进行依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloWorld4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）该写测试进行测试一下是否满足能工作了，其实测试代码一点没变，变的是配置：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        HelloApi bean = beanFactory.getBean(<span class="string">"bean"</span>,HelloApi.class);</span><br><span class="line">        bean.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       知道如何配置了，但Spring如何知道setter方法？如何将值注入进去的呢？其实方法名是要遵守约定的，setter注入的方法名要遵循“JavaBean getter/setter 方法命名约定”：</p>
<p>​        JavaBean：是本质就是一个POJO类，但具有一下限制：</p>
<ul>
<li>该类必须要有公共的无参构造器，如public HelloImpl4(){};</li>
<li>属性为private访问级别，不建议public，如private String message；</li>
<li>属性必要时通过一组setter(修改器)和getter<strong>（访问器）方法来访问</strong> ;</li>
<li><strong>setter方法，以“set”开头，后跟首字母大写的属性名</strong>，如“setMesssage”,简单属性一般只有一个方法参数，方法返回值通常为“void”; </li>
<li><strong>getter方法，一般属性以“get”开头，对于boolean类型一般以“is”开头，后跟首字母大写的属性名</strong>，如“getMesssage”，“isOk”； </li>
<li>还有一些其他特殊情况，<strong>比如属性有连续两个大写字母开头，如“URL”,则setter/getter方法为：“setURL”和“getURL”</strong>，其他一些特殊情况请参看“Java Bean”命名规范。 </li>
</ul>
<h5 id="注入常量"><a href="#注入常量" class="headerlink" title="注入常量"></a>注入常量</h5><h5 id="注入常量是依赖注入中最简单的。配置方式如下所示："><a href="#注入常量是依赖注入中最简单的。配置方式如下所示：" class="headerlink" title="注入常量是依赖注入中最简单的。配置方式如下所示："></a>注入常量是依赖注入中最简单的。配置方式如下所示：</h5> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span>  </span><br><span class="line">或  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"Apple-style-span"</span> <span class="attr">style</span>=<span class="string">"font-size: 14px; white-space: normal; background-color: #ffffff;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       以上两种方式都可以，从配置来看第一种更简洁。注意此处“value”中指定的全是字符串，由Spring容器将此字符串转换成属性所需要的类型，如果转换出错，将抛出相应的异常。</p>
<p> Spring容器目前能对各种基本类型把配置的String参数转换为需要的类型。</p>
<p> 注：Spring类型转换系统对于boolean类型进行了容错处理，除了可以使用“true/false”标准的Java值进行注入，还能使用“yes/no”、“on/off”、“1/0”来代表“真/假”，所以大家在学习或工作中遇到这种类似问题不要觉得是人家配置错了，而是Spring容错做的非常好。</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">测试类  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanTestBean</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.success = success;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> success;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">配置文件（chapter3/booleanInject.xml）片段：  </span><br><span class="line">&lt;!-- <span class="keyword">boolean</span>参数值可以用on/off --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"bean2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter3.bean.BooleanTestBean"</span>&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"success"</span> value=<span class="string">"on"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;!-- <span class="keyword">boolean</span>参数值可以用yes/no --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"bean3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter3.bean.BooleanTestBean"</span>&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"success"</span> value=<span class="string">"yes"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;!-- <span class="keyword">boolean</span>参数值可以用<span class="number">1</span>/<span class="number">0</span> --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"bean4"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter3.bean.BooleanTestBean"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"success"</span> value=<span class="string">"1"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h5 id="注入Bean-ID"><a href="#注入Bean-ID" class="headerlink" title="注入Bean ID"></a>注入Bean ID</h5><p>用于注入Bean的ID，ID是一个常量不是引用，且类似于注入常量，但提供错误验证功能，配置方式如下所示：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"bean1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;<span class="name">idref</span> <span class="attr">local</span>=<span class="string">"bean2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>两种方式都可以，上述配置本质上在运行时等于如下方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"……"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idrefBean1"</span> <span class="attr">class</span>=<span class="string">"……"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span> =<span class="string">"bean1"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种方式（<idref bean="bean1">）可以在容器初始化时校验被引用的Bean是否存在，如果不存在将抛出异常，而第一种方式（<idref local="bean2">）只有在Bean实际使用时才能发现传入的Bean的ID是否正确，可能发生不可预料的错误。因此如果想注入Bean的ID，推荐使用第二种方式。</idref></idref></p>
<p> 接下来学习一下如何使用吧：</p>
<p> 首先定义测试Bean：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdRefTestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其次定义配置文件（chapter3/idRefInject.xml）：</strong></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idrefBean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.bean.IdRefTestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"bean1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idrefBean2"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.bean.IdRefTestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;<span class="name">idref</span> <span class="attr">local</span>=<span class="string">"bean2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       从配置中可以看出，注入的Bean的ID是一个java.lang.String类型，即字符串类型，因此注入的同样是常量，只是具有校验功能。</p>
<p> <idref bean="……">将在容器初始化时校验注入的ID对于的Bean是否存在，如果不存在将抛出异常。</idref></p>
<p> <idref local="……">将在XML解析时校验注入的ID对于的Bean在当前配置文件中是否存在，如果不存在将抛出异常，它不同于<idref bean="……">，<idref local="……">是校验发生在XML解析式而非容器初始化时，且只检查当前配置文件中是否存在相应的Bean。</idref></idref></idref></p>
<h5 id="注入集合、数组和字典"><a href="#注入集合、数组和字典" class="headerlink" title="注入集合、数组和字典"></a>注入集合、数组和字典</h5><p>​       Spring不仅能注入简单类型数据，还能注入集合（Collection、无序集合Set、有序集合List）类型、数组(Array)类型、字典(Map)类型数据、Properties类型数据，接下来就让我们一个个看看如何注入这些数据类型的数据。</p>
<p>​        <strong>一、注入集合类型：</strong>包括Collection类型、Set类型、List类型数据：</p>
<p>​        <strong>（1）List类型:需要使用<list>标签来配置注入，其具体配置如下：</list></strong></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E6%B3%A8%E5%85%A5list.JPG?raw=true" alt=""></p>
<p>​       让我们来写个测试来练习一下吧：</p>
<p>​              <strong>准备测试类：</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(List&lt;String&gt; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​              <strong>进行Bean定义，在配置文件（resources/chapter3/listInject.xml）中配置list注入：</strong></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"listBean"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.bean.ListTestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"values"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        ListTestBean listBean = beanFactory.getBean(<span class="string">"listBean"</span>,ListTestBean.class);</span><br><span class="line">        System.out.println(listBean.getValues().size());</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>,listBean.getValues().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）Set类型：需要使用<set>标签来配置注入，其配置参数及含义和<lsit>标签完全一样，在此就不阐述了： </lsit></set></strong></p>
<p>​              <strong>准备测试类：</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3.bean;  </span><br><span class="line"><span class="keyword">import</span> java.util.Collection;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTestBean</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Collection&lt;String&gt; values;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(Collection&lt;String&gt; values)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.values = values;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getValues</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> values;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​              <strong>进行Bean定义，在配置文件（resources/chapter3/listInject.xml）中配置list注入：</strong></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"setBean"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.SetTestBean"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"values"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​              具体测试代码就不写了，和listBean测试代码完全一样。</p>
<p> <strong>(2)Collection类型：</strong>因为Collection类型是Set和List类型的基类型，所以使用<set>或<list>标签都可以进行注入，配置方式完全和以上配置方式一样，只是将测试类属性改成“Collection”类型，如果配置有问题，可参考cn.javass.spring.chapter3.DependencyInjectTest测试类中的testCollectionInject测试方法中的代码。</list></set></p>
<p>二、<strong>注入数组类型</strong>：需要使用<array>标签来配置注入，其中标签属性“value-type”和“merge”和<list>标签含义完全一样，具体配置如下：</list></array></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E6%B3%A8%E5%85%A5%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B.JPG?raw=true" alt=""></p>
<p>​       <strong>三、注入字典（Map）类型：</strong>字典类型是包含键值对数据的数据结构，需要使用<map>标签来配置注入，其属性“key-type”和“value-type”分别指定“键”和“值”的数据类型，其含义和<list>标签的“value-type”含义一样，在此就不罗嗦了，并使用<key>子标签来指定键数据，<value>子标签来指定键对应的值数据，具体配置如下：</value></key></list></map></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E6%B3%A8%E5%85%A5%E5%AD%97%E5%85%B8.JPG?raw=true" alt=""></p>
<p>四、Properties注入：Spring能注入java.util.Properties类型数据，需要使用<props>标签来配置注入，键和值类型必须是String，不能变，子标签<prop key="”键”">值</prop>来指定键值对，具体配置如下：</props></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/properties%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/properties%E6%B3%A8%E5%85%A52.JPG?raw=true" alt=""></p>
<p>如果练习时遇到配置问题，可以参考cn.javass.spring.chapter3.DependencyInjectTest测试类中的testPropertiesInject测试方法中的代码。</p>
<p>​        到此我们已经把简单类型及集合类型介绍完了，大家可能会问怎么没见注入“Bean之间关系”的例子呢？接下来就让我们来讲解配置Bean之间依赖关系，也就是注入依赖Bean。</p>
<h5 id="引用其它Bean"><a href="#引用其它Bean" class="headerlink" title="引用其它Bean"></a>引用其它Bean</h5><p>​        上边章节已经介绍了注入常量、集合等基本数据类型和集合数据类型，本小节将介绍注入依赖Bean及注入内部Bean。</p>
<p>​        引用其他Bean的步骤与注入常量的步骤一样，可以通过构造器注入及setter注入引用其他Bean，只是引用其他Bean的注入配置稍微变化了一下：可以将“<constructor-arg index="0" value="Hello World!">”和“<property name="message" value="Hello World!">”中的value属性替换成bean属性，其中bean属性指定配置文件中的其他Bean的id或别名。另一种是把<value>标签替换为&lt;.ref bean=”beanName”&gt;，bean属性也是指定配置文件中的其他Bean的id或别名。那让我们看一下具体配置吧：</value></property></constructor-arg></p>
<p> <strong>一、构造器注入方式：</strong></p>
<p> （1）通过” <constructor-arg>”标签的ref属性来引用其他Bean，这是最简化的配置：</constructor-arg></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/bean-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5.JPG?raw=true" alt=""></p>
<p>（2）通过” <constructor-arg>”标签的子<ref>标签来引用其他Bean，使用bean属性来指定引用的Bean：</ref></constructor-arg></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/bean-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A52.JPG?raw=true" alt=""></p>
<p>   <strong>二、setter注入方式：</strong></p>
<p>（1）通过” <property>”标签的ref属性来引用其他Bean，这是最简化的配置：</property></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/bean-setter%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F.JPG?raw=true" alt=""></p>
<p>（2）通过” <property>”标签的子<ref>标签来引用其他Bean，使用bean属性来指定引用的Bean：</ref></property></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/bean-propertie%E5%AD%90%E6%A0%87%E7%AD%BE.JPG?raw=true" alt=""></p>
<p>三、接下来让我们用个具体例子来讲解一下具体使用吧：</p>
<p> （1）首先让我们定义测试引用Bean的类，在此我们可以使用原有的HelloApi实现，然后再定义一个装饰器来引用其他Bean，具体装饰类如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApiDecorator</span> <span class="keyword">implements</span> <span class="title">HelloApi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloApi helloApi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApiDecorator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApiDecorator</span><span class="params">(HelloApi helloApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloApi = helloApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloApi</span><span class="params">(HelloApi helloApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloApi = helloApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========装饰一下==========="</span>);</span><br><span class="line">        helloApi.sayHello();</span><br><span class="line">        System.out.println(<span class="string">"==========装饰一下==========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       （2）定义好了测试引用Bean接下来该在配置文件(resources/chapter3/beanInject.xml)进行配置Bean定义了，在此将演示通过构造器及setter方法方式注入依赖Bean：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义依赖Bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 通过构造器注入 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.HelloApiDecorator"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"helloApi"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 通过构造器注入 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.HelloApiDecorator"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">" helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）测试一下吧，测试代码(cn.javass.spring.chapter3.DependencyInjectTest)片段如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanInject</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    BeanFactory beanFactory =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter3/beanInject.xml"</span>);  </span><br><span class="line">    <span class="comment">//通过构造器方式注入  </span></span><br><span class="line">    HelloApi bean1 = beanFactory.getBean(<span class="string">"bean1"</span>, HelloApi.class);  </span><br><span class="line">    bean1.sayHello();  </span><br><span class="line">    <span class="comment">//通过setter方式注入  </span></span><br><span class="line">    HelloApi bean2 = beanFactory.getBean(<span class="string">"bean2"</span>, HelloApi.class);  </span><br><span class="line">    bean2.sayHello();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       <strong>四、其他引用方式：</strong>除了最基本配置方式以外，Spring还提供了另外两种更高级的配置方式，<ref local="””/">和<ref parent="””/"><strong>：</strong></ref></ref></p>
<p>​        （1）<ref local="””/">配置方式：用于引用通过<bean id="”beanName”">方式中通过id属性指定的Bean，它能利用XML解析器的验证功能在读取配置文件时来验证引用的Bean是否存在。因此如果在当前配置文件中有相互引用的Bean可以采用<ref local="">方式从而如果配置错误能在开发调试时就发现错误。</ref></bean></ref></p>
<p> 如果引用一个在当前配置文件中不存在的Bean将抛出如下异常：</p>
<p> org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line21 inXML document from class path resource [chapter3/beanInject2.xml] is invalid; nested exception is org.xml.sax.SAXParseException: cvc-id.1: There is no ID/IDREF binding for IDREF ‘helloApi’.</p>
<p> <ref local="">具体配置方式如下：</ref></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/ref%20local%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F.JPG?raw=true" alt=""></p>
<p>​       （2）<ref parent="””/">配置方式：用于引用父容器中的Bean，不会引用当前容器中的Bean，当然父容器中的Bean和当前容器的Bean是可以重名的，获取顺序是直接到父容器找。具体配置方式如下：</ref></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/ref%20parent.JPG?raw=true" alt=""></p>
<p>接下来让我们用个例子演示一下<ref local="">和<ref parent="">的配置过程：</ref></ref></p>
<p> 首先还是准备测试类，在此我们就使用以前写好的HelloApiDecorator和HelloImpl4类；其次进行Bean定义，其中当前容器bean1引用本地的”helloApi”，而”bean2”将引用父容器的”helloApi”，配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sources/chapter3/parentBeanInject.xml表示父容器配置--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--注意此处可能子容器也定义一个该Bean--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.HelloImpl4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello Parent!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sources/chapter3/localBeanInject.xml表示当前容器配置--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 注意父容器中也定义了id 为 helloApi的Bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.HelloImpl4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello Local!"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 通过local注入 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.HelloApiDecorator"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 通过parent注入 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.HelloApiDecorator"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">"helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）写测试类测试一下吧，具体代码片段如下： </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalAndparentBeanInject</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//初始化父容器  </span></span><br><span class="line">ApplicationContext parentBeanContext =  </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter3/parentBeanInject.xml"</span>);  </span><br><span class="line"><span class="comment">//初始化当前容器  </span></span><br><span class="line">ApplicationContext beanContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(  </span><br><span class="line"><span class="keyword">new</span> String[] &#123;<span class="string">"chapter3/localBeanInject.xml"</span>&#125;, parentBeanContext);  </span><br><span class="line">    HelloApi bean1 = beanContext.getBean(<span class="string">"bean1"</span>, HelloApi.class);  </span><br><span class="line">    bean1.sayHello();<span class="comment">//该Bean引用local bean  </span></span><br><span class="line">HelloApi bean2 = beanContext.getBean(<span class="string">"bean2"</span>, HelloApi.class);  </span><br><span class="line">bean2.sayHello();<span class="comment">//该Bean引用parent bean  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> “bean1”将输出“Hello Local!”表示引用当前容器的Bean，”bean2”将输出“Hello Paren!”，表示引用父容器的Bean，如配置有问题请参考cn.javass.spring.chapter3.DependencyInjectTest中的testLocalAndparentBeanInject测试方法。</p>
<h5 id="内部Bean定义"><a href="#内部Bean定义" class="headerlink" title="内部Bean定义"></a>内部Bean定义</h5><p>内部Bean就是在<property>或<constructor-arg>内通过<bean>标签定义的Bean，该Bean不管是否指定id或name，该Bean都会有唯一的匿名标识符，而且不能指定别名，该内部Bean对其他外部Bean不可见，具体配置如下：</bean></constructor-arg></property></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%86%85%E9%83%A8bean.JPG?raw=true" alt=""></p>
<p>（1）让我们写个例子测试一下吧，具体配置文件如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.bean.HelloApiDecorator"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"com.zero.spring.chapter.HelloImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> （2）测试代码（cn.javass.spring.chapter3.DependencyInjectTest.testInnerBeanInject）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        HelloApi bean = context.getBean(<span class="string">"bean"</span>, HelloApi.class);</span><br><span class="line">        bean.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h5><p>​        Spring通过<value>标签或value属性注入常量值，所有注入的数据都是字符串，那如何注入null值呢？通过“null”值吗？当然不是因为如果注入“null”则认为是字符串。Spring通过<null>标签注入null值。即可以采用如下配置方式：</null></value></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%A4%84%E7%90%86null.JPG?raw=true" alt=""></p>
<h5 id="配置简写"><a href="#配置简写" class="headerlink" title="配置简写"></a>配置简写</h5><p>让我们来总结一下依赖注入配置及简写形式，其实我们已经在以上部分穿插着进行简化配置了：</p>
<p> 1）常量值</p>
<p>简写：<constructor-arg index="0" value="常量"></constructor-arg></p>
<p>全写：<constructor-arg index="0"><value>常量</value></constructor-arg></p>
<p>2）引用</p>
<p>简写：<constructor-arg index="0" ref="引用"></constructor-arg></p>
<p>全写：<constructor-arg index="0"><ref bean="引用"></ref></constructor-arg></p>
<p><strong>二、setter**</strong>注入：**      </p>
<p>​       1）常量值</p>
<p>​        简写：<property name="message" value="常量"></property></p>
<p>​        全写：<property name="message"><value>常量</value>&lt;/ property&gt;</property></p>
<p>​       2）引用</p>
<p>​        简写：<property name="message" ref="引用"></property></p>
<p>​        全写：<property name="message"><ref bean="引用">&lt;/ property&gt;</ref></property></p>
<p>​       3）数组：<array>没有简写形式</array></p>
<p>​       4）列表：<list>没有简写形式</list></p>
<p>​       5）集合：<set>没有简写形式</set></p>
<p>​       6）字典</p>
<p>​          简写：<map></map></p>
<p>​             <entry key="键常量" value="值常量"></entry></p>
<p>​             <entry key-ref="键引用" value-ref="值引用"></entry></p>
<p>​            </p>
<p>​         全写：<map></map></p>
<p>​             <entry><key><value>键常量</value></key><value>值常量</value></entry></p>
<p>​             <entry><key><ref bean="键引用"></ref></key><ref bean="值引用"></ref></entry></p>
<p>​           </p>
<p>​       7）Properties：没有简写形式</p>
<p><strong>三、使用p命名空间简化setter注入：</strong></p>
<p>​       使用p命名空间来简化setter注入，具体使用如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idrefBean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.IdRefTestBean"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">p:id</span>=<span class="string">"value"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idrefBean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.IdRefTestBean"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">p:id-ref</span>=<span class="string">"bean1"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a></strong> <strong>：首先指定p命名空间；</strong></p>
<p>&lt;bean id=”</p>
</li>
</ul>
<p>……” class=”</p>
<p>……” p:id=”value”/&gt; </p>
<p>：</p>
<p>常量setter注入方式，其等价于<property name="id" value="value">；</property></p>
<p><strong><bean id="……" class="……" p:id-ref="bean1"></bean></strong> <strong>：</strong>引用setter注入方式，其等价于<property name="id" ref="bean1">。 </property></p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h5><p>循环依赖就是循环引用，就是两个或多个Bean相互之间的持有对方，比如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA，则它们最终反映为一个环。此处不是循环调用，循环调用是方法之间的环调用。如图3-5所示：</p>
<p>循环调用是无法解决的，除非有终结条件，否则就是死循环，最终导致内存溢出错误。 </p>
<p>Spring容器循环依赖包括构造器循环依赖和setter循环依赖，那Spring容器如何解决循环依赖呢？首先让我们来定义循环引用类： </p>
<h4 id="更多DI的知识"><a href="#更多DI的知识" class="headerlink" title="更多DI的知识"></a>更多DI的知识</h4><h5 id="延迟初始化Bean"><a href="#延迟初始化Bean" class="headerlink" title="延迟初始化Bean"></a>延迟初始化Bean</h5><p>延迟初始化也叫做惰性初始化，指不提前初始化Bean，而是只有在真正使用时才创建及初始化Bean。</p>
<p>配置方式很简单只需在<bean>标签上指定“lazy-init” 属性值为“true”即可延迟初始化Bean。<br>Spring容器会在创建容器时提前初始化”singleton”作用域的Bean，”singleton”就是单例的意思即这个容器每个Bean只有一个实例。。Spring容器预先初始化Bean通常能帮助我们提前发现配置错误，所以如果没有什么情况建议开启，除非有某个Bean可能需要加载很大资源，而且很可能在整个应用程序生命周期中很可能使用不到，可以设置为延迟初始化。延迟初始化的Bean通常会在第一次使用时被初始化；或者在被非延迟初始化Bean作为依赖对象注入时在会随着初始化该Bean时被初始化，因为在这时使用了延迟初始化Bean。</bean></p>
<p>容器管理初始化Bean消除了编程实现延迟初始化，完全由容器控制，只需在需要延迟初始化的Bean定义上配置即可，比编程方式更简单，而且是无侵入代码的。具体配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span></span></span><br><span class="line"><span class="tag"><span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用depends-on"><a href="#使用depends-on" class="headerlink" title="使用depends-on"></a>使用depends-on</h5><p>depends-on是指指定Bean初始化及销毁时的顺序，使用depends-on属性指定的Bean要先初始化完毕后才初始化当前Bean，由于只有“singleton”Bean能被Spring管理销毁，所以当指定的Bean都是“singleton”时，使用depends-on属性指定的Bean要在指定的Bean之后销毁.</p>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>自动装配就是指由Spring来自动地注入依赖对象，无需人工参与。</p>
<h5 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h5><p>所谓方法注入其实就是通过配置方式覆盖或拦截指定的方法，通常通过代理模式实现。Spring提供两种方法注入：查找方法注入和方法替换注入。</p>
<p>因为Spring是通过CGLIB动态代理方式实现方法注入，也就是通过动态修改类的字节码来实现的，本质就是生成需方法注入的类的子类方式实现。</p>
<p>在进行测试之前，我们需要确保将“com.springsource.cn.sf.cglib-2.2.0.jar”放到lib里并添加到“Java Build Path”中的Libararies中。否则报错，异常中包含“nested exception is java.lang.NoClassDefFoundError: cn/sf/cglib/proxy/CallbackFilter<br>”。</p>
<p>传统方式和Spring容器管理方式唯一不同的是不需要我们手动生成子类，而是通过配置方式来实现；其中如果要替换createPrinter()方法的返回值就使用查找方法注入；如果想完全替换sayHello()方法体就使用方法替换注入。接下来让我们看看具体实现吧。</p>
<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>什么是作用域呢？即“scope”，在面向对象程序设计中一般指对象或变量之间的可见范围。而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。<br>Spring提供“singleton”和“prototype”两种基本作用域，另外提供“request”、“session”、“global session”三种web作用域；Spring还允许用户定制自己的作用域。</p>
<h5 id="基本的作用域"><a href="#基本的作用域" class="headerlink" title="基本的作用域"></a>基本的作用域</h5><p>一、singleton：指“singleton”作用域的Bean只会在每个Spring IoC容器中存在一个实例，而且其完整生命周期完全由Spring容器管理。对于所有获取该Bean的操作Spring容器将只返回同一个Bean。</p>
<table>
<thead>
<tr>
<th>Gof单例设计模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>GoF单例设计模式指“保证一个类仅有一个实例，并提供一个访问它的全局访问点”，介绍了两种实现：通过在类上<strong>定义静态属性</strong>保持该实例和通过注册表方式。</td>
</tr>
</tbody>
</table>
<p><strong>(1)通过在类上定义静态属性保持该实例：</strong>一般指一个Java虚拟机 ClassLoader装载的类只有一个实例，一般通过类静态属性保持该实例，这样就造成需要单例的类都需要按照单例设计模式进行编码；Spring没采用这种方式，因为该方式属于侵入式设计；代码样例如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3.bean;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1.私有化构造器  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="comment">//2.单例缓存者，惰性初始化，第一次使用时初始化  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//3.提供全局访问点  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//4.提供一个计数器来验证一个ClassLoader一个实例  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上定义个了个单例类，首先要私有化类构造器；其次使用InstanceHolder静态内部类持有单例对象，这样可以得到惰性初始化好处；最后提供全局访问点getInstance，使得需要该单例实例的对象能获取到；我们在此还提供了一个counter计数器来验证一个ClassLoader一个实例。具体一个ClassLoader有一个单例实例测试请参考代码“cn.javass.spring.chapter3. SingletonTest”中的“testSingleton”测试方法，里边详细演示了一个ClassLoader有一个单例实例。</p>
<p> (2) <strong>通过注册表方式：</strong> 首先将需要单例的实例通过唯一键注册到注册表，然后通过键来获取单例，让我们直接看实现吧，注意本注册表实现了Spring接口“SingletonBeanRegistry”，该接口定义了操作共享的单例对象，Spring容器实现将实现此接口；所以共享单例对象通过“registerSingleton”方法注册，通过“getSingleton”方法获取，消除了编程方式单例，注意在实现中不考虑并发： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.SingletonBeanRegistry;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBeanRegister</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//单例Bean缓存池，此处不考虑并发  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; BEANS = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsSingleton</span><span class="params">(String beanName)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> BEANS.containsKey(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> BEANS.get(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSingletonCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> BEANS.size();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String[] getSingletonNames() &#123;  </span><br><span class="line">        <span class="keyword">return</span> BEANS.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object bean)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(BEANS.containsKey(beanName)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"["</span> + beanName + <span class="string">"] 已存在"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        BEANS.put(beanName, bean);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring是注册表单例设计模式的实现，消除了编程式单例，而且对代码是非入侵式。</p>
<p> 接下来让我们看看在Spring中如何配置单例Bean吧，在Spring容器中如果没指定作用域默认就是“singleton”，配置方式通过scope属性配置，具体配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.Printer"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       Spring管理单例对象在Spring容器中存储如图3-5所示，Spring不仅会缓存单例对象，Bean定义也是会缓存的，对于惰性初始化的对象是在首次使用时根据Bean定义创建并存放于单例缓存池。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%8D%95%E4%BE%8B%E5%A4%84%E7%90%86.JPG?raw=true" alt=""></p>
<p>图3-5 单例处理</p>
<p> <strong>二、prototype：</strong>即原型，指每次向Spring容器请求获取Bean都返回一个全新的Bean，相对于“singleton”来说就是不缓存Bean，每次都是一个根据Bean定义创建的全新Bean。</p>
<blockquote>
<p>GoF原型设计模式，指用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p> Spring中的原型和GoF中介绍的原型含义是不一样的：</p>
<p>​          GoF通过用原型实例指定创建对象的种类，而Spring容器用Bean定义指定创建对象的种类；</p>
<p>​          GoF通过拷贝这些原型创建新的对象，而Spring容器根据Bean定义创建新对象。</p>
<p> 其相同地方都是根据某些东西创建新东西，而且GoF原型必须显示实现克隆操作，属于侵入式，而Spring容器只需配置即可，属于非侵入式。</p>
<p> 接下来让我们看看Spring如何实现原型呢？</p>
<p> 1）首先让我们来定义Bean“原型”：Bean定义，所有对象将根据Bean定义创建；在此我们只是简单示例一下，不会涉及依赖注入等复杂实现：BeanDefinition类定义属性“class”表示原型类，“id”表示唯一标识，“scope”表示作用域，具体如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//单例  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCOPE_SINGLETON = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//原型  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCOPE_PROTOTYPE = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//唯一标识  </span></span><br><span class="line">    <span class="keyword">private</span> String id;  </span><br><span class="line">    <span class="comment">//class全限定名  </span></span><br><span class="line">    <span class="keyword">private</span> String clazz;  </span><br><span class="line">    <span class="comment">//作用域  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> scope = SCOPE_SINGLETON;  </span><br><span class="line">    <span class="comment">//鉴于篇幅，省略setter和getter方法；  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）接下来让我们看看Bean定义注册表，类似于单例注册表：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDifinitionRegister</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//bean定义缓存，此处不考虑并发问题  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; DEFINITIONS =  </span><br><span class="line"> <span class="keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//1.本实现不允许覆盖Bean定义  </span></span><br><span class="line">        <span class="keyword">if</span>(DEFINITIONS.containsKey(bd.getId())) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"已存在Bean定义，此实现不允许覆盖"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.将Bean定义放入Bean定义缓存池  </span></span><br><span class="line">        DEFINITIONS.put(bd.getId(), bd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> DEFINITIONS.get(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;        </span><br><span class="line"> <span class="keyword">return</span> DEFINITIONS.containsKey(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）接下来应该来定义BeanFactory了：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.SingletonBeanRegistry;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//Bean定义注册表  </span></span><br><span class="line">    <span class="keyword">private</span> BeanDifinitionRegister DEFINITIONS = <span class="keyword">new</span> BeanDifinitionRegister();  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//单例注册表  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SingletonBeanRegistry SINGLETONS = <span class="keyword">new</span> SingletonBeanRegister();  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//1.验证Bean定义是否存在  </span></span><br><span class="line">        <span class="keyword">if</span>(!DEFINITIONS.containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不存在["</span> + beanName + <span class="string">"]Bean定义"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.获取Bean定义  </span></span><br><span class="line">        BeanDefinition bd = DEFINITIONS.getBeanDefinition(beanName);  </span><br><span class="line">        <span class="comment">//3.是否该Bean定义是单例作用域  </span></span><br><span class="line">        <span class="keyword">if</span>(bd.getScope() == BeanDefinition.SCOPE_SINGLETON) &#123;  </span><br><span class="line">            <span class="comment">//3.1 如果单例注册表包含Bean，则直接返回该Bean  </span></span><br><span class="line">            <span class="keyword">if</span>(SINGLETONS.containsSingleton(beanName)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> SINGLETONS.getSingleton(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//3.2单例注册表不包含该Bean，  </span></span><br><span class="line">            <span class="comment">//则创建并注册到单例注册表，从而缓存  </span></span><br><span class="line">            SINGLETONS.registerSingleton(beanName, createBean(bd));  </span><br><span class="line">            <span class="keyword">return</span> SINGLETONS.getSingleton(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//4.如果是原型Bean定义,则直接返回根据Bean定义创建的新Bean，  </span></span><br><span class="line"><span class="comment">//每次都是新的，无缓存  </span></span><br><span class="line">        <span class="keyword">if</span>(bd.getScope() == BeanDefinition.SCOPE_PROTOTYPE) &#123;  </span><br><span class="line">            <span class="keyword">return</span> createBean(bd);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//5.其他情况错误的Bean定义  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"错误的Bean定义"</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">     DEFINITIONS.registerBeanDefinition(bd.getId(), bd);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//根据Bean定义创建Bean  </span></span><br><span class="line">     <span class="keyword">try</span> &#123;  </span><br><span class="line">         Class clazz = Class.forName(bd.getClazz());  </span><br><span class="line">         <span class="comment">//通过反射使用无参数构造器创建Bean  </span></span><br><span class="line">         <span class="keyword">return</span> clazz.getConstructor().newInstance();  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到Bean["</span> + bd.getId() + <span class="string">"]类"</span>);  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"创建Bean["</span> + bd.getId() + <span class="string">"]失败"</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>​       其中方法getBean用于获取根据beanName对于的Bean定义创建的对象，有单例和原型两类Bean；registerBeanDefinition方法用于注册Bean定义，私有方法createBean用于根据Bean定义中的类型信息创建Bean。</p>
<p> 3）测试一下吧，在此我们只测试原型作用域Bean，对于每次从Bean工厂中获取的Bean都是一个全新的对象，代码片段（BeanFatoryTest）如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPrototype</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"><span class="comment">//1.创建Bean工厂  </span></span><br><span class="line">DefaultBeanFactory bf = <span class="keyword">new</span> DefaultBeanFactory();  </span><br><span class="line"><span class="comment">//2.创建原型 Bean定义  </span></span><br><span class="line">BeanDefinition bd = <span class="keyword">new</span> BeanDefinition();  </span><br><span class="line">bd.setId(<span class="string">"bean"</span>);  </span><br><span class="line">bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);  </span><br><span class="line">bd.setClazz(HelloImpl2.class.getName());  </span><br><span class="line">bf.registerBeanDefinition(bd);  </span><br><span class="line"><span class="comment">//对于原型Bean每次应该返回一个全新的Bean  </span></span><br><span class="line">System.out.println(bf.getBean(<span class="string">"bean"</span>) != bf.getBean(<span class="string">"bean"</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后让我们看看如何在Spring中进行配置吧，只需指定<bean>标签属性“scope”属性为“prototype”即可：</bean></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.bean.Printer"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       Spring管理原型对象在Spring容器中存储如图3-6所示，Spring不会缓存原型对象，而是根据Bean定义每次请求返回一个全新的Bean：</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E5%8E%9F%E5%9E%8B%E5%A4%84%E7%90%86.JPG?raw=true" alt=""></p>
<p>图3-6 原型处理</p>
<p>​        单例和原型作用域我们已经讲完，接下来让我们学习一些在Web应用中有哪些作用域：</p>
<h5 id="Web应用中的作用域"><a href="#Web应用中的作用域" class="headerlink" title="Web应用中的作用域"></a>Web应用中的作用域</h5><p>在Web应用中，我们可能需要将数据存储到request、session、global session。因此Spring提供了三种Web作用域：request、session、globalSession。</p>
<p> <strong>一、request作用域：表示每个请求需要容器创建一个全新Bean</strong>。比如提交表单的数据必须是对每次请求新建一个Bean来保持这些表单数据，请求结束释放这些数据。</p>
<p> <strong>二、session作用域：表示每个会话需要容器创建一个全新Bean</strong>。比如对于每个用户一般会有一个会话，该用户的用户信息需要存储到会话中，此时可以将该Bean配置为web作用域。</p>
<p> <strong>三、globalSession：</strong>类似于session作用域，只是其用于portlet环境的web应用。如果在非portlet环境将视为session作用域。</p>
<p>配置方式和基本的作用域相同，只是必须要有web环境支持，并配置相应的容器监听器或拦截器从而能应用这些作用域，我们会在集成web时讲解具体使用，大家只需要知道有这些作用域就可以了。</p>
<h5 id="自定义作用域"><a href="#自定义作用域" class="headerlink" title="自定义作用域"></a>自定义作用域</h5><p> 在日常程序开发中，几乎用不到自定义作用域，除非又必要才进行自定义作用域。</p>
<p> 首先让我们看下Scope接口吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectFactory;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scope</span> </span>&#123;  </span><br><span class="line">       <span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span></span>;  </span><br><span class="line">       <span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span></span>;  </span><br><span class="line">       <span class="function">Object <span class="title">resolveContextualObject</span><span class="params">(String key)</span></span>;  </span><br><span class="line">       <span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）<strong>Object get(String name, ObjectFactory&lt;?&gt; objectFactory)：</strong>用于从作用域中获取Bean，其中参数objectFactory是当在当前作用域没找到合适Bean时使用它创建一个新的Bean；</p>
<p>2）<strong>void registerDestructionCallback(String name, Runnable callback)：</strong>用于注册销毁回调，如果想要销毁相应的对象则由Spring容器注册相应的销毁回调，而由自定义作用域选择是不是要销毁相应的对象；</p>
<p>3）<strong>Object resolveContextualObject(String key)</strong>：用于解析相应的上下文数据，比如request作用域将返回request中的属性。</p>
<p>4）<strong>String getConversationId()</strong>：作用域的会话标识，比如session作用域将是sessionId。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter3;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.Scope;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; THREAD_SCOPE =  </span><br><span class="line"><span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt;() &#123;  </span><br><span class="line">      <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="comment">//用于存放线程相关Bean  </span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>​       让我们来实现个简单的thread作用域，该作用域内创建的对象将绑定到ThreadLocal内。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//如果当前线程已经绑定了相应Bean，直接返回  </span></span><br><span class="line">        <span class="keyword">if</span>(THREAD_SCOPE.get().containsKey(name)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> THREAD_SCOPE.get().get(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//使用objectFactory创建Bean并绑定到当前线程上  </span></span><br><span class="line">        THREAD_SCOPE.get().put(name, objectFactory.getObject());  </span><br><span class="line">        <span class="keyword">return</span> THREAD_SCOPE.get().get(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConversationId</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//此处不实现就代表类似proytotype，容器返回给用户后就不管了  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> THREAD_SCOPE.get().remove(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveContextualObject</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scope已经实现了，让我们将其注册到Spring容器，使其发挥作用：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span>  </span><br><span class="line">                   <span class="comment">&lt;!-- 指定scope关键字 --&gt;</span><span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">                   <span class="comment">&lt;!-- scope实现 --&gt;</span>      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter3.ThreadScope"</span>/&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;/<span class="name">entry</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过CustomScopeConfigurer的scopes属性注册自定义作用域实现，在此需要指定使用作用域的关键字“thread”，并指定自定义作用域实现。来让我们来定义一个“thread”作用域的Bean，配置（chapter3/threadScope.xml）如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">scope</span>=<span class="string">"thread"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后测试（cn.javass.spring.chapter3.ThreadScopeTest）一下吧，首先在一个线程中测试，在同一线程中获取的Bean应该是一样的；再让我们开启两个线程，然后应该这两个线程创建的Bean是不一样：</p>
<p> 自定义作用域实现其实是非常简单的，其实复杂的是如果需要销毁Bean，自定义作用域如何正确的销毁Bean。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

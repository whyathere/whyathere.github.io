<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bill">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Bill">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bill">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Bill</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/Eclipse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/Eclipse/" itemprop="url">Eclipse</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T18:23:46+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发工具/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Eclipse-ini文件"><a href="#Eclipse-ini文件" class="headerlink" title="Eclipse.ini文件"></a>Eclipse.ini文件</h3><p>该文档中提及的以下警告信息需要重点注意。</p>
<ul>
<li>-vmargs 之后的所有行都被作为参数传递给JVM；Eclipse的所有参数和选项必须在 -vmargs之前指定(正如在命令行上使用参数一样)。</li>
</ul>
<p>这就是为什么要在文件开始处插入 -vm 选项的原因。</p>
<ul>
<li>在命令行中使用 -vmargs将覆盖所有在 .ini文件中的 -vmargs设置，除非在.ini文件中或命令行中指定了 –auncher.appendVmargs。</li>
</ul>
<p><strong>设置 -vm选项</strong></p>
<p>设置 -vm 选项用于确定Eclipse使用那个JVM实现。你可能会注意到我们已经选定了JVM作为一个库(<em>.dll /</em>.so)，这在启动时能提供更好的性能，还支持程序作为Eclipse可执行文件运行而并不是作为Java可执行文件。</p>
<p>如果没有设置-vm 选项时，Eclipse 使用那个JVM，请注意Eclipse不查询JAVA_HOME 环境变量(Eclipse wiki)。相反，Eclipse执行解析path环境变量的Java命令。</p>
<p><strong>自定义JVM参数</strong></p>
<p>推荐的JVM参数列表来自于Piotr Gabryanczyk 在Java内存管理模型方面的研究成果。最初用于JetBRAINS Intellij设置，这种配置对Eclipse环境也有用的。在一下场合中有帮助；</p>
<ul>
<li>防止垃圾回收器中断程序的运行超过10ms(-XX:MaxGCPauseMillis=10)</li>
<li>降低垃圾回收器启动的级别到30%的所占用内存(-XX:MaxHeapFreeRatio=70)</li>
<li>强制垃圾回收器作为一个并行线程运行，降低对应用程序的干扰(-XX:+UseConcMarkSweepGC)</li>
<li>为垃圾回收器选择增量模式，可以在GC工作中生成中断让应用程序明确地停止冻结(-XX:+CMSIncrementalPacing)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Java基础/" itemprop="url">Java Base</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Base/" itemprop="url" rel="index">
                    <span itemprop="name">Base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java中的参数"><a href="#Java中的参数" class="headerlink" title="Java中的参数"></a>Java中的参数</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p><strong>在实例化类的时候指明泛型的具体类型</strong></p>
<p><strong><code>类型的参数化，可以把类型像方法的参数那样传递。</code></strong></p>
<p>优点：<strong><code>泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。如果我们在对一个对象赋值不符合其泛型的规范，就会编译报错</code></strong></p>
<p>1、代码重用：我们可以编写一个方法/类/接口，并用于我们想要的任何类型。</p>
<p>2、类型安全：泛型使错误显示在编译时而不是在运行时</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Simple Java program to demonstrate that NOT using </span></span><br><span class="line"><span class="comment">// generics can cause run time exceptions </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creatinga an ArrayList without any type specified </span></span><br><span class="line">        ArrayList al = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">        al.add(<span class="number">10</span>); <span class="comment">// Compiler allows this </span></span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Causes Runtime Exception </span></span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只有在运行时才会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p><strong>类型转换异常</strong></p>
<p><strong>泛型如何解决这个问题？</strong></p>
<p>在定义ArrayList时，我们可以指定此列表只能使用String对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Creating a an ArrayList with String specified </span></span><br><span class="line">        ArrayList &lt;String&gt; al = <span class="keyword">new</span> ArrayList&lt;String&gt; (); </span><br><span class="line">  </span><br><span class="line">        al.add(<span class="string">"Sachin"</span>); </span><br><span class="line">        al.add(<span class="string">"Rahul"</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Now Compiler doesn't allow this </span></span><br><span class="line">        al.add(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        String s1 = (String)al.get(<span class="number">0</span>); </span><br><span class="line">        String s2 = (String)al.get(<span class="number">1</span>); </span><br><span class="line">        String s3 = (String)al.get(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、不需要单独类型转换：如果我们不使用泛型，那么，在上面的例子中，每次我们从ArrayList检索数据时，我们必须对它进行强制类型转换，而且还要自己检查是否是String类型，否则就会报错，因为从List中取出元素时，其类型会默认为Object。在每次检索操作中进行类型转换都是一个令人头痛的问 如果我们已经知道我们的列表只包含字符串数据，那么我们不需要每次都对它进行类型转换。</p>
<p>4、实现通用算法：通过使用泛型，我们可以实现适用于不同类型对象的算法，同时它们也是类型安全的。</p>
<p>5、有界泛型</p>
<p><strong><em>在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Animal&gt;<span class="comment">//限定T是Animal的子类</span></span><br><span class="line"></span><br><span class="line">&lt;T <span class="keyword">super</span> Dog &gt;<span class="comment">//限定T是Dog的超类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killAll</span><span class="params">(ArrayList&lt;T extends Animal&gt; animals)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>多个限定时我们可以使用&amp;来进行分割，这时关键词只能使用extends。与多重继承类似，这里只可以有一个类，其他都是接口。</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Object&amp;Comparable&amp;Serializable&gt;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p><strong>在调用方法的时候指明泛型的具体类型</strong></p>
<p><code>定义泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958544-ba9ac600-87d5-11e9-9473-ea75ecb5077f.png" alt=""></p>
<p><code>调用泛型方法语法格式如下</code></p>
<p><img src="https://user-images.githubusercontent.com/24977343/58958730-25e49800-87d6-11e9-9619-7774468f4e20.png" alt=""></p>
<p>​       <strong>说明一下，定义泛型方法时，必须在返回值前边加一个<t>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。</t></strong></p>
<p>​       Class<t>的作用就是指明泛型的具体类型，而Class<t>类型的变量c，可以用来创建泛型类的对象。</t></t></p>
<p>​       为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>​       泛型方法要求的参数是Class<t>类型，而Class.forName()方法的返回值也是Class<t>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<t>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<user>类型的对象，因此调用泛型方法时，变量c的类型就是Class<user>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</user></user></t></t></t></p>
<p>​       当然，泛型方法不是仅仅可以有一个参数Class<t>，可以根据需要添加其他参数。</t></p>
<p>​       为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h2 id="Java数据结构应用"><a href="#Java数据结构应用" class="headerlink" title="Java数据结构应用"></a>Java数据结构应用</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="subList-方法"><a href="#subList-方法" class="headerlink" title="subList()方法"></a>subList()方法</h4><p>截取list的一段，但是如果对这一段做了修改，那么原来的list也会发生相应的变化。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>定义：</strong>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p><strong>简单定义：</strong>有一个或多个抽象方法的类，必须声明为抽象类。不能创建实例</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="为啥用抽象类"><a href="#为啥用抽象类" class="headerlink" title="为啥用抽象类"></a>为啥用抽象类</h3><ol>
<li>父类中的方法确实没有必要写(通用方法)，当然可以用类的覆盖，但是没有必要</li>
<li>各个子类中的这个方法肯定会不同</li>
<li>抽象方法有提示作用</li>
<li>发现共性，向上抽取。方法功能声明相同，但是方法功能主体不同。</li>
</ol>
<p>总结：</p>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法(用static修饰的方法)不能声明为抽象方法</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li>
<li>具体派生类必须覆盖基类的抽象方法</li>
<li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</li>
</ol>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>线程不安全就意味着线程的调度顺序会影响最终结果</p>
</li>
<li><p>线程安全的优先级高于性能</p>
</li>
<li>进程是程序向操作系统申请资源的基本单位。线程(Thread)是进程中可独立执行的最小单位。</li>
<li>一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。进程与线程之间的关系，好比一个营业中的饭店与其正在工作的员工之间的关系。</li>
</ul>
<p><strong>总结涉及到多线程的内容：</strong></p>
<ul>
<li>扎好马步：线程的状态</li>
<li>内功心法：每个对象都有的方法（机制）</li>
<li>太祖长拳：基本线程类</li>
<li>九阴真经：高级多线程控制类</li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://user-images.githubusercontent.com/24977343/65651829-3b5e2600-e042-11e9-9cd3-b3c98492a75b.png" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/24977343/65651887-634d8980-e042-11e9-94d0-7170924c22e0.png" alt=""></p>
<ul>
<li>Runnable :可运行</li>
<li>Running：运行中</li>
<li>Blocked ： 阻塞</li>
<li>Dead ： 结束</li>
</ul>
<p>实现多线程的三种方式：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runable接口</li>
<li>实现Callable接口</li>
</ul>
<h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><h3 id="进程、线程与任务"><a href="#进程、线程与任务" class="headerlink" title="进程、线程与任务"></a>进程、线程与任务</h3><ul>
<li>进程是程序向操作系统申请资源(如内存空间和文件句柄)的基本单位，是程序运行的实例。线程(Thread)是进程中可独立执行的最小单位。运行一个Java程序的实质是启动一个Java虚拟机进程，也就是说一个运行的Java程序的实质是启动一个Java虚拟机进程。</li>
<li>可以运行一个以上线程的程序称为多线程程序(multithreaded)</li>
<li>多进程和多线程的本质区别：每个进程拥有自己的一整套变量，而线程则共享数据。有风险，但是线程通信比进程更有效、容易、更轻量级；创建、撤销一个线程比启动新进程的开销要小得多。</li>
</ul>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>使用线程给其他任务提供机会</p>
<p>Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或</p>
<h4 id="线程的层次关系"><a href="#线程的层次关系" class="headerlink" title="线程的层次关系"></a>线程的层次关系</h4><ul>
<li>一个线程是否是一个守护线程默认取决于其父线程；默认父线程是守护线程，则子线程也是守护线程。父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon方法，将相应的线程设置为守护线程(或者用户线程)。</li>
<li>程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。</li>
<li>如果没有设置一个线程的优先级，那么这个线程优先级默认与父线程的优先级值相等。</li>
<li>Java平台中并没有API用于获取一个线程的父线程或者一个线程的所有子线程。</li>
<li>父线程与子线程的生命周期没有必然联系。</li>
</ul>
<h4 id="线程的生命周期状态"><a href="#线程的生命周期状态" class="headerlink" title="线程的生命周期状态"></a>线程的生命周期状态</h4><p>​    一个线程从</p>
<p><img src="https://user-images.githubusercontent.com/24977343/67002732-1b84c400-f10f-11e9-8606-f1dd7c05ad72.png" alt=""></p>
<h2 id="多线程编程的目标与挑战"><a href="#多线程编程的目标与挑战" class="headerlink" title="多线程编程的目标与挑战"></a>多线程编程的目标与挑战</h2><h4 id="串行、并发与并行"><a href="#串行、并发与并行" class="headerlink" title="串行、并发与并行"></a>串行、并发与并行</h4><p>三个任务：</p>
<ul>
<li>A：实际执行5分钟，等待完成10分钟</li>
<li>B：实际执行2分钟，等待完成8分钟</li>
<li>C：实际执行10分钟，无等待时间</li>
</ul>
<p>串行：一个任务接一个任务的来完成(一个人完成)。15+10+10=35分钟。一个处理器就可以完成</p>
<p>并发：在任务的等待时间来执行其他任务(一个人完成)；5+2+10=17分钟。一个处理器就可以完成</p>
<p>并行：同时执行三个任务(三个人完成)；15分钟(以耗时时间最长的任务为准)。需要多个处理器</p>
<p>​    多线程编程的实质就是将任务的处理方式由串行改为并发，称为可并发化。但是有的任务处理方式必须是串行的，例如Java中的读取文件就是串行。</p>
<h4 id="竟态"><a href="#竟态" class="headerlink" title="竟态"></a>竟态</h4><p>​        多线程编程中经常遇到的问题就是同样的输入，程序的输出有时候是正确的而有时候确实错误的。这种一个计算结果的正确性与时间有关的现象称为<code>竟态</code>(Race Condition);</p>
<p>​        <code>synchronized</code>关键字会使其修饰的方法在任一时刻只能够被一个线程执行，这使得该方法涉及的共享变量在任一时刻只能够有一个线程访问(读、写)，从而避免了这个方法的交错执行而导致的干扰，这样就消除了竟态。</p>
<h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>​        如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是线程安全(Thread-safe)的，相应地问们称这个类具有线程安全性(Thread Safety)。反之，如果一个类在单线程环境下运作正常而在多线程环境下则无法正常运作，那么这个类就是非线程安全的。因此，如果一个类如果能够导致竟态，那么它就是非线程安全的；而一个类如果是线程安全的，那么它就不会导致竟态。        </p>
<p>​        使用一个类的时候我们必须先弄清楚这个类是否是线程安全的。因为这关系到我们如何正确使用这些类。这好比微波炉加热食物前我们必须先弄清所用的容器是否适宜进行微波加热。Java标准库种的一些类如ArrayList、HashMap和SimpleDateFormat，都是非线程安全的，在多线程环境下直接使用它们可能导致一些非预期的结果，甚至是一些灾难性的结果。</p>
<p>​        把一个类做成线程安全的往往是有额外代价的。</p>
<p>​        一个类如果不是线程安全的，我们就说它在多线程环境下直接使用存在线程安全问题。线程安全问题概括来说表现为3个方面:原子性、可见性和有序性。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>​        原子(Atomic)的字面意思是不可分割的(Indivisible)。    对于涉及共享变量访问的操作，若操作从执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有原子性。</p>
<p>​        所谓<code>不可分割</code>，其中一个含义是指访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会<code>看到</code>该操作执行了部分中间效果。</p>
<p>​        访问同一组共享变量(一个方法中的)的原子操作是不能够<strong>被交错的</strong>，这就排除了一个线程执行一个操作期间另外一个线程读取或者更新该操作所访问的共享变量而导致的干扰(读脏数据)和冲突(丢失更新)的可能性。</p>
<p>​        例子:        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHostInfo</span><span class="params">(String ip,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">      <span class="comment">//以下操作不是原子操作</span></span><br><span class="line">    hostInfo.setIp(ip);<span class="comment">//语句1</span></span><br><span class="line">    hostInfo.setPort(port);<span class="comment">//语句2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​     A线程执行了语句1,还未执行语句2，B线程读取了hostInfo。</p>
<ul>
<li>原子操作是针对共享变量的操作而言的。也就是说，仅涉及局部变量访问的操作无所谓是否是原子的，或者干脆把这一类操作都看出原子操作。</li>
<li>原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多线程环境下有意义。单线程无所谓是否具有原子性。</li>
</ul>
<p><strong>提示</strong></p>
<p>​        原子操作是多线程环境下的一个概念，它是针对访问共享变量的操作而言的。原子操作不可分割包含以下两层含义。</p>
<ul>
<li><p>访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会 <strong>看到</strong>该操作执行了部分的中间效果。</p>
</li>
<li><p>访问同一组共享变量的原子操作是不能够被交错的。</p>
<p>​    总的来说，Java中有两种方式来实现原子性。一种是使用锁(Lock)。锁具有排他性，即它能保证一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的CAS(Compare-and-Swap)指令，CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别是一个是软件层实现一个是硬件层(处理器和内存)，它可以被看作是硬件锁。</p>
<p>​        在Java语言中，long/double除外，仅包含byte、boolean、short、char、float、和int的变量和引用型变量的写操作都是原子的。这点由Java语言规范规定，由Java虚拟机具体实现。</p>
<p>​        long/double型变量会占用64位(8字节)的存储空间，而32位的java虚拟机对这种变量的写操作可能会被分解为两个步骤来实施，比如先写低32位再写高32位。那么多个线程试图共享一个这样的变量就可能出现一个线程在写高32位的时候，另外一个线程正在写低32位的情形。</p>
<p>​        volatile关键仅能够保障变量写操作的原子性，它并不能保障其他操作(比如 read-modify-write操作和check-then-act操作)的原子性。</p>
</li>
</ul>
<p>原子操作+原子操作 !=原子操作</p>
<p>例如：</p>
<p>​        共享型变量 int a、b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="comment">//语句1</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<p>​    线程A执行完语句1之后再执行语句2之前的这一刻，另外一个线程B可以读取变量a和变量b的值。那么B读到的变量a和b的值分别为1和0，也就是说它读到了A所执行操作的中间结果，这有悖于原子操作不可分割的特性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>​        在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新到结果，甚至永远也无法读取到这个更新的结果。这就是线程安全问题的另外一个表现形式:可见性(Visibility)。</p>
<p>​        如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么我们就称这个线程对共享变量的更新对其他线程可见，否则我们就称这个线程对该共享变量的更新对其他线程不可见。可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。多线程在可见性方面存在的问题意味着某些线程读取到了旧数据(Stale Data)，而这可能导致程序出现我们所不期望的结果。</p>
<p>​                </p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换就是看那个线程获取到了时间片。上一个线程的一些信息保存到内存</p>
<h2 id="Java线程同步机制"><a href="#Java线程同步机制" class="headerlink" title="Java线程同步机制"></a>Java线程同步机制</h2><p>Java线程同步机制是Java多线程编程的基础与核心内容。</p>
<h3 id="线程同步机制简介"><a href="#线程同步机制简介" class="headerlink" title="线程同步机制简介"></a>线程同步机制简介</h3><p>​        导致线程安全问题的因素更多的是侧重其根源，包括硬件(如写缓冲器)和软件(编译器)。但是从应用程序的角度来看，线程安全问题的产生是由于多线程应用程序缺乏某种东西—-线程同步机制。</p>
<p>​        线程同步机制是一套用于协调线程间的数据访问(Data acess)及活动(Activity)的机制，该机制用于保障线程安全以及实现这些线程的共同目标。如果把线程必做公路上行驶的汽车，那么线程同步机制就好比是任何车辆都需要遵循的交通规则。遵守才能够安全地到达目的地。</p>
<p>​        从广义上讲，Java平台提供的线程同步机制包括锁、volatile关键字、final关键字、static关键字以及一些相关API，如Object.wait()/Object.notify()等。本章介绍的是Java平台中用于协调线程间共享数据访问的相关关键字和API。</p>
<h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><p>​        锁的思路：将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问，该线程结束后其他线程才能对其进行访问。</p>
<p>​        锁可以理解为对共享数据进行保护的许可证。对于同一个许可证所保护的共享数据而言，任何线程访问这些共享数据前必须先持有该许可证。</p>
<p><strong>锁的特性</strong>：</p>
<ul>
<li>一个线程只有在持有许可证的情况下才能够对这些共享数据进行访问</li>
<li>一个许可证一次只能够被一个线程持有</li>
<li>许可证的持有线程在其结束对这些共享数据的访问后必须让出(释放)其持有的许可证，以便其他线程能够对这些共享数据进行访问。</li>
<li>锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区(Critical Section)。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。</li>
</ul>
<p><strong>约定</strong></p>
<p>​        如果有多个线程访问同一个锁锁保护的共享数据，那么我们就称这些线程同步在这个锁上，或者称为们对这些线程锁锁进行的共享数据访问进行加锁；相应地，这些线程所执行的临界区就被称为这个锁所引导的临界区。</p>
<p>​    <code>锁具有排他性</code>(Exclusive)，即一个锁一次只能被一个线程持有。因此，这种锁被称为排他锁或者互斥锁(Mutex)。这种锁的实现方式代表了锁的基本原理。读写锁—排他锁的一种相对改进。</p>
<p>​        按照Java虚拟机对锁的实现方式划分，Java平台中的锁包含内部锁(Intrinsic Lock)和显式锁(Explicit Lock)。内部锁是通过synchronized关键字实现的。</p>
<p>​                <img src="https://user-images.githubusercontent.com/24977343/68444179-08967880-0211-11ea-8d6d-62c534d51139.png" alt=""></p>
<h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>​        一个锁实例可以保护一个或者多个共享数据。一个锁实例所保护的共享数据的数量大小就被称为该锁的粒度(Granularity)。一个锁实例保护的共享数据的数量大，就称该锁的粒度粗，否则就称该锁的粒度细。锁的粒度的粗细是相对的。</p>
<h5 id="锁的开销及可能导致的问题"><a href="#锁的开销及可能导致的问题" class="headerlink" title="锁的开销及可能导致的问题"></a>锁的开销及可能导致的问题</h5><p>​    锁的开销包括锁的申请和释放所产生的开销，以及锁可能导致的上下文切换的开销。这些开销主要是处理器时间。</p>
<p>​    锁可能导致上下文切换。多个线程争用排他性资源可能导致上下文切换。一旦锁被争用就可能导致上下文切换，而没有被争用的锁则可能不会导致上下文切换，</p>
<p>​        锁的不正确使用也会导致如下一些活性故障：</p>
<ul>
<li>锁泄漏(Lock Leak)。指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。</li>
<li>死锁、锁死等活性故障。</li>
</ul>
<h3 id="内部锁：synchronized关键字"><a href="#内部锁：synchronized关键字" class="headerlink" title="内部锁：synchronized关键字"></a>内部锁：synchronized关键字</h3><p>​        Java平台中的任何一个对象都有唯一一个与之关联的锁。这种锁被称为监视器(Monitor)或者<code>内部锁</code>(Intrinsic Lock)。内部锁是一种排他锁，它能够保障原子性、可见性和有序性。</p>
<p>​        synchronized关键字修饰的方法就被称为<code>同步方法</code>(Synchronized Method)。</p>
<p>​        synchronized关键字修饰的代码块被称为同步块。引导的代码块就是临界区。        </p>
<p>​        synchronized会保证修饰的方法里面一次只能被一个方法执行，变成串行，整体并发中的局部串行。        </p>
<p>​        synchronized修饰的代码块被称为同步块。</p>
<p>​        synchronized也被称为内部锁。</p>
<p>​                synchronized(锁句柄){</p>
<p>​            //在此代码块中访问共享数据</p>
<p>​                }</p>
<p>​        synchronized关键字所引导的代码块就是临界区。<code>锁句柄</code>是一个对象的引用(或者能够返回对象的表达式)。习惯上我称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的引导锁。相应地，我们称呼相应地同步块为该锁引导的同步块。</p>
<p>​        同步实例方法相当于以”this”为引导锁的同步块。</p>
<p>​        作为锁句柄的变量通常采用final修饰。这是因为句柄锁变量的值一旦改变，会导致执行同一个同步块的多个线程实际上使用不同的锁，从而导致竞态。有鉴于此，通常使用private修饰作为锁句柄的变量。</p>
<p>​        作为锁句柄的变量通常采用private final修饰。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>​        同步静态方法相当于以当前类对象(Java中的类本身也是一个对象)为引导锁的同步块。</p>
<p>​        线程在执行临界区代码的时候必须持有该临界区的引导锁。一个线程执行到同步代码块(同步方法也可看作同步块)时必须先申请该同步块的引导锁，只有申请成功(获得)该锁的线程才能够执行相应的临界区。一个线程执行完临界区代码后引导该临界区的锁就会被自动释放。在这个过程中，<strong>线程对内部锁的申请与释放的动作由java虚拟机负责代为实施，这也正是synchronized实现的锁被称为内部锁的原因。</strong></p>
<p>​        内部锁并不会导致锁泄漏。这是因为Java编译器(javac)在将同步块代码编译为字节码的时候，对临界区中可能抛出的而程序没代码中又未捕获的异常进行了特殊(代为)处理，这使得临界区即使抛出异常也不会妨碍内部锁的释放。</p>
<p>​        synchronized可以修饰几种类型：</p>
<ul>
<li>类：作用对象是这个类的所有对象</li>
<li>方法：作用对象是调用这个方法的对象</li>
<li>静态方法：作用对象是这个类的所有对象</li>
<li>代码块：作用的对象是调用这个代码的对象</li>
</ul>
<h4 id="内部锁的调度"><a href="#内部锁的调度" class="headerlink" title="内部锁的调度"></a>内部锁的调度</h4><p>​        <img src="https://user-images.githubusercontent.com/24977343/68633983-d8abe580-052e-11ea-9a25-581cada0201f.png" alt=""></p>
<p>Java虚拟机会为每个内部锁分配一个入口集(Entry Set)，用于记录等待获得相应内部锁的线程。多个线程申请一个锁的时候，只有一个能申请成功。申请失败的会被暂停(生命周期状态变为BLOCKED)并被存入相应锁的入口集中等待再次申请锁的机会。入口集中的线程就被称为相应内部锁的等待线程。<strong>由于Java虚拟机仅支持非公平调度</strong>，被唤醒的等待线程占用处理器运行时间可能还有其他新的活跃线程处于(RUNNABLE状态，且未进入过入口集)。</p>
<p>​    Java选择线程是随机的，与Java虚拟机具体实现有关。可能是最长、最短或者随机的。</p>
<p>​    synchronized是非公平锁。</p>
<p>​    <strong>总结</strong></p>
<p>缺点：</p>
<ul>
<li>synchronized是内部锁，线程对内部锁的申请与释放的动作由java虚拟机负责代为实施。而Java虚拟机仅支持非公平调度。所以有可能有的线程永远得不到调用。</li>
<li>​                </li>
</ul>
<h3 id="显式锁：LOCK接口"><a href="#显式锁：LOCK接口" class="headerlink" title="显式锁：LOCK接口"></a>显式锁：LOCK接口</h3><p>​        显示锁是JDK开始引入的排他锁。作为一种线程同步机制，其作用与内部锁相同。它提供了一些内部锁锁不具备的特性，但并不是内部锁的替代品。</p>
<p>​                </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Spring-MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Spring-MVC/" itemprop="url">Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SpringMVC的注解"><a href="#SpringMVC的注解" class="headerlink" title="SpringMVC的注解"></a>SpringMVC的注解</h3><ol>
<li>@ModelAttribute</li>
</ol>
<p>大致有两种使用方式，一种是直接标记在方法上，一种是标记在方法的参数中，两种标记方法产生的效果也各不相同。</p>
<ul>
<li>注解放在方法上面</li>
</ul>
<p>当同一个controller中有任意一个方法被@ModelAttribute注解标记，页面请求只要进入这个控制器，不管请求那个方法，均会先执行被@ModelAttribute标记的方法，所以我们可以用@ModelAttribute注解的方法做一些初始化操作。当同一个controller中有多个方法被@ModelAttribute注解标记，所有被@ModelAttribute标记的方法均会被执行，按先后顺序执行，然后再进入请求的方法。</p>
<p>​    </p>
<p>下面方法做一些变形，变形为带有参数的返回，这样也是实际开发中经常会操作的 </p>
<p>首先创建一个pojo对象，对象包含name，sex两个属性。并对JSP及控制器代码做一些修改</p>
<p>页面首先使用EL表达式接收返回参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span> + request.getServerName() + <span class="string">":"</span> + request.getServerPort() + path + <span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>, function () &#123;</span><br><span class="line"></span><br><span class="line">                window.location.href = <span class="string">"&lt;%=basePath%&gt;model/modelTest.do"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.name &#125;"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>@ModelAtterbute方法无返回值情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="keyword">null</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问ModelTest.jsp页面并点击测试</p>
<p> <img src="https://img-blog.csdn.net/20170225235700722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从执行结果看出，当访问请求时，会首先访问init方法，然后再对modelTest方法进行访问，并且是同一个请求，因为model模型数据的作用域与request相同，所以可以用此标记直接标记在方法上对实际要访问的方法进行一些初始化操作</p>
<ul>
<li>@ModelAttribute标记方法有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入init方法"</span>);</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"model/befor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"befor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">befor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入befor方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里稍微做了点变形，可以看到在被@ModelAttribute方法中设值了返回路径为befor方法，但是在在代码运行的过程中并不会跳转befor方法，而是在代码执行完成return之前直接跳转了实际请求的方法。不执行return</p>
<p> 进入init方法<br>进入modelTest方法</p>
<ul>
<li><p>当@RequestMapping标记和@ModelAttribute同时标记在一个方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试页面发现进入控制器后返回，页面报404，这是因为当两个注解标记到同一个方法上时，逻辑视图名并不是返回值，而是返回请求的路径，根据model/modelTest.do生成逻辑视图。在这里我们修改下代码，把controller上的@RequestMapping标记去掉，并修改下页面的请求路径，让生成的视图路径和访问的页面路径相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(function()&#123;</span><br><span class="line">           $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">  </span><br><span class="line">               window.location.href=<span class="string">"&lt;%=basePath%&gt;modelTest.do"</span>;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo &#125;"</span>&gt;</span><br><span class="line">  </span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>点击测试页面，会发现当两个注解同时注解到一个方法上时，方法的返回值会变成model模型的返回值，key是标记的名</p>
<h4 id="ModelAttribute标记在参数前"><a href="#ModelAttribute标记在参数前" class="headerlink" title="@ModelAttribute标记在参数前"></a>@ModelAttribute标记在参数前</h4><p>从from表单或url地址中取值，这里就以url地址为例，为了避免url地址中文乱码问题，这里调用了encodeURL函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line"></span><br><span class="line">                window.location.href=<span class="string">"&lt;%=basePath%&gt;model/modelTest.do?userName="</span>+encodeURI(<span class="string">'小明'</span>)+<span class="string">"&amp;sex="</span>+encodeURI(<span class="string">'男'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.userName &#125;"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pojo.setUserName(<span class="keyword">new</span> String(pojo.getUserName().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">            pojo.setSex(<span class="keyword">new</span> String(pojo.getSex().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击页面测试，页面文本框会显示URL地址传递过来的参数，因为SpringMVC会自动匹匹配页面传递过来的参数的name属性和后台控制器中的方法中的参数名，如果参数名相同，会自动匹配，如果控制器中方法是封装的bean,会自动匹配bean中的属性，其实这种取值方式不需要用@ModelAttribute注解，只要满足匹配要求，也能拿得到值</p>
<p> <img src="https://img-blog.csdn.net/20170226011711946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从model对象中取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PojoTest <span class="title">init</span><span class="params">( PojoTest pojo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setSex(<span class="string">"男"</span>);</span><br><span class="line">        <span class="keyword">return</span> pojo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setUserName(<span class="string">"小明"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试发现，modelTest拿到inint方法中的pojo对象，合并两次set的参数后返回页面</p>
</li>
</ul>
<p>   <img src="https://img-blog.csdn.net/20170226023308348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/LeetCode/" itemprop="url">LeetCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>## </p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>206    反向链表</li>
</ul>
<p>141，21，19，876</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>20,155,232,844,224,682,496</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/FastDfs分布式文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/FastDfs分布式文件系统/" itemprop="url">FastDFS 分布式文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T10:40:45+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="FastDfs简介"><a href="#FastDfs简介" class="headerlink" title="FastDfs简介"></a>FastDfs简介</h3><ol>
<li>FastDfs是一个轻量级的开源分布式文件系统</li>
<li>FastDfs主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>
<li>FastDfs实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>
<li>支持存储服务器在线扩容</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>
<li><p>FastDFS特别适合大中型网站使用，用来存储资源文件(如：图片、文档、音频、视频等等)</p>
<p>  FastDFS是一个开源的轻量级分布式文件系统，她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。  </p>
</li>
</ol>
<p>FastDFS服务端有两个角色：<strong>跟踪器(tracker)</strong>和<strong>存储节点(storage)</strong>。跟踪器主要做调度工作，在访问上起负载均衡 的作用。</p>
<h4 id="Tracker"><a href="#Tracker" class="headerlink" title="Tracker"></a>Tracker</h4><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%BC%95%E5%85%A5Tracker.jpg?raw=true" alt=""></p>
<p>Group之间是相互独立的，Group内是相互备份的；Tracker之间也是相互独立的。</p>
<ul>
<li><p>Group之间 相互独立</p>
</li>
<li><p>同一Group内的Storage Server 之间需要互相备份</p>
<p>文件存放到一个Storage以后，需要备份到别的服务器</p>
</li>
<li><p>Tracker之间是不交互的</p>
<ul>
<li>每个storage server都需要向所有Tracker去主动报告信息</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ol>
<li>group内的server内容都是一致的</li>
<li>一个负责跟踪一个负责存储</li>
<li>group会向每个tracker都汇报，tracker存储的信息很少</li>
</ol>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg?raw=true" alt=""></p>
<h4 id="选定Tracker-Server"><a href="#选定Tracker-Server" class="headerlink" title="选定Tracker Server"></a>选定Tracker Server</h4><ul>
<li>Tracker Server不止一个，客户端选择哪一个做上传文件？</li>
</ul>
<p>Client是如何知道上传到那个Tracker Server</p>
<p>Client可以维护一个Tracker列表</p>
<ul>
<li>Tracker如何选择Group？(三种策略)<ul>
<li>round robin(轮询)</li>
<li>load balance(选择最大剩余空间的组上传文件)</li>
<li>specify group(指定group上传)</li>
</ul>
</li>
</ul>
<h4 id="选定Storage-Server"><a href="#选定Storage-Server" class="headerlink" title="选定Storage Server"></a>选定Storage Server</h4><ul>
<li>一个组内有多个Storage Server ，选择哪一个？<ul>
<li><ol>
<li>Round robin，所有server轮询使用(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>根据IP地址进行排序选择第一个服务器(IP地址最小者)</li>
</ol>
</li>
<li><ol start="3">
<li>根据优先级进行排序(上传优先级由storage server来设置，参数为upload_priority)</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%20%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" alt=""></p>
<h4 id="选择storage-path"><a href="#选择storage-path" class="headerlink" title="选择storage path"></a>选择storage path</h4><ul>
<li>如何选择storage path(虚拟磁盘目录M00，M01路径)<ul>
<li><ol>
<li>round robin ，轮询(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>load balance，选择使用剩余空间最大的存储路径</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>目录和文件</p>
<ul>
<li>选定存放目录？<ul>
<li>storage会生成一个file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg)，采用Base64编码，file_id包含字段包括：storage server_ip(文件的源服务器)、文件创建时间、文件大小、文件CRC32校验码和随机数、；(这个时候文件名已经和最早的文件名是两回事儿了)</li>
<li>每个存储目录下有两个256*256个子目录，storage 会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为文件名存储到该子目录下</li>
</ul>
</li>
</ul>
<p>Group1/M00/00/OC/wKjGgVgbV2-ABdo-AAAAHw.jpg   </p>
<p>tracker可以通过上面的东西迅速的找到文件</p>
<p><strong>要点：</strong></p>
<ul>
<li>server之间不分主从，每个目录可以不止放一个文件</li>
<li>存储服务器启动的时候就会把两个256*256个目录一次创建出来</li>
<li>file_id必须由client来保存。</li>
</ul>
<p>怎么确定存放在那个目录</p>
<p>storage会按照文件的file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg   )做两次hash算法，路由到其中一个子目录中。</p>
<h4 id="Storage-Server之间的文件同步"><a href="#Storage-Server之间的文件同步" class="headerlink" title="Storage Server之间的文件同步"></a>Storage Server之间的文件同步</h4><ul>
<li>同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；</li>
<li>文件同步只在组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器；</li>
<li>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</li>
<li>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一套storage server将已有的所有数据(包括源头数据和备份数据)同步给新增服务器</li>
</ul>
<p>client是FastDFS提供的客户端</p>
<p>FastDFS有覆盖方法，可以修改某个已经上传的文件，甚至是追加操作。</p>
<p>例子：</p>
<p>A，B，C三个服务器在同一个组中</p>
<ul>
<li>9:30用户向服务器A上传了一个文件X(文件创建时间9:30)</li>
<li>9:31用户向服务器B上传了一个文件Y(文件创建时间9:31)</li>
<li>9:32用户向服务器A上传了一个文件Z(文件创建时间9:32)</li>
</ul>
<p>A向B，C同步文件X，并且向Tracker Server汇报</p>
<ul>
<li>我向B同步了X(文件创建时间9:30)</li>
<li>我向C同步了X(文件创建时间9:30)</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A52.jpg?raw=true" alt=""></p>
<p>通过文件名都可以取到创建时间和源服务器地址</p>
<p>这个时候下载文件Y，tracker会去那个服务器上面寻找呢?</p>
<p>这个时候可以直接从B中下载，如果这个时候B宕机了，只有和A或C中找，查tracker中的表时，B–&gt;A在9：31前的都同步了，就去A中找。如果A也宕机了，就去C中找，看这个时间前的是否同步。</p>
<p>tracker不需要保存左侧的信息，根据文件名就可以了。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A53.jpg?raw=true" alt=""></p>
<p>这个时候假设用户想下载文件Z，就去源服务器下载，如果源服务器宕机，就去其他服务器下载。根据时间判断是否在这个时间前的同步了，如果同步了就下载，如果没有就下载。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A54.jpg?raw=true" alt=""></p>
<p>当试图下载文件的时候，根据文件名拿到创建时间和服务器，根据时间来判断是否可以下载。</p>
<p>FastDFS文件同步方式</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F.jpg?raw=true" alt=""></p>
<p>最后最早同步时间，</p>
<p>对于服务器A来讲，服务器B向他同步的时间是9:31,服务器C是9:33.计算最后的时间，那么根据上图。</p>
<p>对服务器A，它的最早同步时间是9:31</p>
<p>对服务器B，它的最早同步时间是9:32</p>
<p><strong>取最小值，然后直接和最小值进行比对。</strong></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%9C%80%E5%90%8E%E6%9C%80%E6%97%A9%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4.jpg?raw=true" alt=""></p>
<p>X可以从三个服务器下载</p>
<p>Y可以从A和B服务器下载，C不行。</p>
<p>Z可以从源服务器A下载，或者服务器B下载,C不行</p>
<p>W只能从服务器C这个源服务器下载，虽然根据时间判断C已经将9:33前的同步到了A和B这两个服务器，但是根据规则，它不能去A和B下载。</p>
<p>虽然简单，但是会牺牲一下。</p>
<p>选择一个可供下载的Storage Server策略</p>
<ul>
<li>该文件上传到源Storage server(文件直接上传到该服务器上的)</li>
<li>文件创建时间戳&lt;Storage server被同步到的文件时间戳，这意味着当前文件已经被同步过来了；</li>
<li>文件创建时间戳=Storage server被同步到的文件时间戳，且(当前时间-文件创建时间戳)&gt;一个文件同步完成需要的最大时间(如5分钟);</li>
<li>(当前时间-文件创建时间戳)&gt;文件同步延迟阈值，比如我们把阈值设置为1天，表示文件同步在一天内肯定可以完成</li>
</ul>
<p>当走到第四个的时候可能已经出问题了。</p>
<p>tracker定位一个组中的server</p>
<h3 id="FastDFS的使用"><a href="#FastDFS的使用" class="headerlink" title="FastDFS的使用"></a>FastDFS的使用</h3><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8.jpg?raw=true" alt=""></p>
<p>这里的FastDFSAPI可以当做client</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8Cnagix%E9%9B%86%E6%88%90.jpg?raw=true" alt=""></p>
<p>上图这种就是</p>
<p>如果上传的话还是走Nginx，到应用服务器</p>
<p>如果下载的时候，直接通过Nginx，直接到FastDFS，模块和Nginx集成。绕过应用服务器</p>
<p>要点：</p>
<ul>
<li>Tracker server内部没有数据库，要么是内存要么是纯文件，文件格式自己定义</li>
</ul>
<h3 id="防止盗链"><a href="#防止盗链" class="headerlink" title="防止盗链"></a>防止盗链</h3><ul>
<li>辛苦上传的文件不想被人盗取</li>
<li>给URL增加token<ul>
<li>Token只有自己的网站才能生成</li>
<li>Token会过期</li>
</ul>
</li>
</ul>
<p>refer</p>
<h4 id="防止盗链的配置"><a href="#防止盗链的配置" class="headerlink" title="防止盗链的配置"></a>防止盗链的配置</h4><p>是否做token检查，缺省为false</p>
<p>http.anti_steal.check_token=true</p>
<p>即生成token的有效时长 秒</p>
<p>http.anti_steal.token_ttl=900</p>
<p>生成token的密钥，尽量设置得长一些</p>
<p>http.anti_steal.secret<em>key=@#%*&amp;$)87)</em>+$%!~</p>
<p>Token = md5(文件名，密钥，时间戳)</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E9%98%B2%E6%AD%A2%E7%9B%97%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE.jpg?raw=true" alt=""></p>
<p>将文件名、密钥和时间戳的组合通过md5加密传给token</p>
<p>token是在服务器端生成</p>
<p>客户端下载文件的时候，除了传fileid以外还需要token</p>
<p>客户端发送的是fileid，服务器端返回的是一个token</p>
<h4 id="合并存储"><a href="#合并存储" class="headerlink" title="合并存储"></a>合并存储</h4><ul>
<li>海量小文件的缺点<ul>
<li>元数据管理低效，磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上</li>
<li>数据存储分散</li>
<li>磁盘的大量随机访问降低效率</li>
</ul>
</li>
<li>FastDFS提供的合并存储功能<ul>
<li>默认大文件64M</li>
<li>每个文件空间称为slot(256bytes&lt;=slot&lt;=16MB)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%B2%A1%E6%9C%89%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6ID.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6.jpg?raw=true" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>FastDFS是穷人的解决方案</li>
<li>FastDFS把简洁和高效做到了极致，非常节约资源，中小网站完全用的起</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-集成Hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-集成Hibernate3/" itemprop="url">Spring--集成Hibernate3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T17:26:07+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E9%95%BF%E9%A2%88%E9%B9%BF.jpg?raw=true" alt=""></p>
<h3 id="集成Hibernate3"><a href="#集成Hibernate3" class="headerlink" title="集成Hibernate3"></a>集成Hibernate3</h3><p>​       Hibernate是全自动的ORM框架，能自动为对象生成相应SQL并透明的持久化对象到数据库。</p>
<p> <strong>Spring2.5+版本支持Hibernate 3.1+版本，不支持低版本，Spring3.0.5版本提供对Hibernate 3.6.0 Final版本支持。</strong></p>
<h4 id="如何集成"><a href="#如何集成" class="headerlink" title="如何集成"></a>如何集成</h4><p>Spring通过使用如下Bean进行集成Hibernate：</p>
<ul>
<li>LocalSessionFactoryBean ：用于支持XML映射定义读取：</li>
<li>configLocation和configLocations：用于定义Hibernate配置文件位置，一般使用classpath:hibernate.cfg.xml形式指定；</li>
<li>mappingLocations：用于指定Hibernate映射文件位置，如chapter8/hbm/user.hbm.xml;</li>
<li>hibernateProperties：用于定义Hibernate属性，即Hibernate配置文件中的属性；</li>
<li>dataSource：定义数据源；</li>
<li>hibernateProperties、dataSource用于消除Hibernate配置文件，因此如果使用configLocations指定配置文件，就不要设置这两个属性了，否则会产生重复配置。推荐使用dataSource来指定数据源，而使用hibernateProperties指定Hibernate属性。</li>
<li>AnnotationSessionFactoryBean：用于支持注解风格映射定义读取，该类继承LocalSessionFactoryBean并额外提供自动查找注解风格配置模型的能力；</li>
<li>AnnotatedClasses：设置注解了模型类，通过注解指定映射元数据。</li>
<li>packagesToScan：通过扫码指定的包获取注解模型类，而不是手工指定，如”com.zero.**.model”将扫码com.zero包及子包下的model包下所有注解模型类。</li>
</ul>
<p>接下来学习一下Spring如何继承Hibernate吧；</p>
<p><strong>1、准备jar包：</strong></p>
<p>首先准备Spring对ORM框架支持的jar包：</p>
<p>org.springframework.orm-3.0.5.RELEASE.jar      //提供对ORM框架集成</p>
<p>下载hibernate-distribution-3.6.0.Final包，获取如下Hibernate需要的jar包：</p>
<p>hibernate3.jar        //核心包</p>
<p>lib\required\antlr-2.7.6.jar        //HQL解析时使用的包</p>
<p>lib\required\javassist-3.9.0.GA.jar        //字节码类库，类似与cglib</p>
<p>lib\required\commons-collections-3.1.jar  //对集合类型支持包，前边测试时已经提供过了，无需再拷贝该包了</p>
<p>lib\required\dom4j-1.6.1.jar            //xml解析包，用于解析配置使用</p>
<p>lib\required\jta-1.1.jar                 //JTA事务支持包</p>
<p>lib\jpa\hibernate-jpa-2.0-api-1.0.0.Final.jar //用于支持JPA</p>
<p> 下载slf4j-1.6.1.zip（<a href="http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple" target="_blank" rel="noopener">http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple</a> Logging Facade for Java），用于对各种日志框架提供给一致的日志访问接口，从而能随时替换日志框架（如log4j、java.util.logging）：</p>
<p>将这些jar包添加到类路径中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-JDBC/" itemprop="url">Spring-JDBC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T15:02:23+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E8%A9%B9%E5%A7%86%E6%96%AF.jpg?raw=true" alt=""></p>
<p>抄自开涛博客   <a href="http://jinnianshilongnian.iteye.com/blog/1423896" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1423896</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h4><p>​       传统应用程序开发中，进行JDBC编程是相当痛苦的，如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cn.javass.spring.chapter7. TraditionalJdbcTest  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">    PreparedStatement pstmt = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      conn = getConnection();              <span class="comment">//1.获取JDBC连接  </span></span><br><span class="line">                                       <span class="comment">//2.声明SQL  </span></span><br><span class="line">      String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;  </span><br><span class="line">      pstmt = conn.prepareStatement(sql);    <span class="comment">//3.预编译SQL  </span></span><br><span class="line">      ResultSet rs = pstmt.executeQuery();   <span class="comment">//4.执行SQL  </span></span><br><span class="line">      process(rs);                       <span class="comment">//5.处理结果集  </span></span><br><span class="line">      closeResultSet(rs);                 <span class="comment">//5.释放结果集  </span></span><br><span class="line">      closeStatement(pstmt);              <span class="comment">//6.释放Statement  </span></span><br><span class="line">      conn.commit();                    <span class="comment">//8.提交事务  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">      <span class="comment">//9.处理异常并回滚事务  </span></span><br><span class="line">      conn.rollback();  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      <span class="comment">//10.释放JDBC连接，防止JDBC连接不关闭造成的内存泄漏  </span></span><br><span class="line">      closeConnection(conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       以上代码片段具有冗长、重复、容易忘记某一步骤从而导致出错、显示控制事务、显示处理受检查异常等等。</p>
<p>​        有朋友可能重构出自己的一套JDBC模板，从而能简化日常开发，但自己开发的JDBC模板不够通用，而且对于每一套JDBC模板实现都差不多，从而导致开发人员必须掌握每一套模板。</p>
<p>​        Spring JDBC提供了一套JDBC抽象框架，用于简化JDBC开发，而且如果各个公司都使用该抽象框架，开发人员首先减少了学习成本，直接上手开发，如图7-1所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JDBC.JPG?raw=true" alt=""></p>
<p>图7-1 Spring JDBC与传统JDBC编程对比</p>
<h4 id="Spring对JDBC的支持"><a href="#Spring对JDBC的支持" class="headerlink" title="Spring对JDBC的支持"></a>Spring对JDBC的支持</h4><p>​       Spring通过抽象JDBC访问并提供一致的API来简化JDBC编程的工作量。我们只需要<strong>声明SQL、调用合适的Spring JDBC框架API、处理结果集</strong>即可。事务由Spring管理，并将JDBC受查异常转换为Spring一致的非受查异常，从而简化开发。</p>
<p>​        Spring主要提供<strong>JDBC模板方式、关系数据库对象化方式和SimpleJdbc</strong>方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p>
<ul>
<li><strong>JDBC模板方式：</strong>Spring JDBC 框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如Jdbc Template、NamedParameterJdbcTemplate、SimpleJdbcTemplate。 </li>
<li><strong>关系数据库对象化方式：</strong>Spring JDBC 框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoreProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li>
<li><strong>SimpleJdbc 方式</strong>：Spring JDBC框架还提供了<strong>SimpleJdbc 方式</strong>来简化JDBC编程，SimpleJdbcInsert、SimpleJdbcCall用来简化数据库表插入、存储过程或函数访问；</li>
</ul>
<p>Spring JDBC还提供了一些强大的工具类，如DataSourceUtils来在必要的时候手工获取数据库连接等。</p>
<h4 id="Spring的JDBC架构"><a href="#Spring的JDBC架构" class="headerlink" title="Spring的JDBC架构"></a>Spring的JDBC架构</h4><p>Spring JDBC抽象框架由四部分组成：datasource、support、core、object。如图7-2所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20JDBC%20%E6%9E%B6%E6%9E%84%E5%9B%BE.JPG?raw=true" alt=""></p>
<p>图7-2 Spring JDBC架构图</p>
<pre><code>**support包：**提供将JDBC异常转化为DAO非检查异常转换类、一些工具类如JdbcUtils等。
</code></pre><p>​    <strong>dataSource包：</strong>提供简化访问JDBC数据源(javax.sql.DataSource实现)工具类，并提供了一些    DataSource简单实现类从而能使从这些DataSource获取的连接能自动得到Spring管理事务支持。</p>
<p>​    <strong>coe包：</strong>提供JDBC模板类实现及可变部分的回调接口，还提供SimpleJdbcInsert等辅助类。</p>
<p>​    <strong>object包：</strong>提供关系数据库的对象表示形式，如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类，该包是基于core包JDBC模板类实现。</p>
<h3 id="JDBC模板类"><a href="#JDBC模板类" class="headerlink" title="JDBC模板类"></a>JDBC模板类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​       Spring JDBC抽象框架core包提供了JDBC模板类，其中JdbcTemplate是core包的核心类，所以其他模板类都是基于它封装完成的，JDBC模板类是第一种工作模式。</p>
<p>​        JdbcTemplate类通过模板设计模式帮助我们消除了冗长的代码，只做需要做的事情（即可变部分），并且帮我们做哪些固定部分，如连接的创建及关闭。</p>
<p>​        JdbcTemplate类对可变部分采用回调接口方式实现，如ConnectionCallback通过回调接口返回给用户一个连接，从而可以使用该连接做任何事情、StatementCallback通过回调接口返回给用户一个Statement，从而可以使用该Statement做任何事情等等，还有其他一些回调接口如图7-3所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JdbcTemplate%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3.JPG?raw=true" alt=""></p>
<p>图7-3 JdbcTemplate支持的回调接口</p>
<p> Spring除了提供JdbcTemplate核心类，还提供了基于JdbcTemplate实现的NamedParameterJdbcTemplate类用于支持命名参数绑定、 SimpleJdbcTemplate类用于支持Java5+的可变参数及自动装箱拆箱等特性。</p>
<h4 id="传统JDBC编程替代方案"><a href="#传统JDBC编程替代方案" class="headerlink" title="传统JDBC编程替代方案"></a>传统JDBC编程替代方案</h4><p>前边我们已经使用过传统JDBC编程方式，接下来让我们看下Spring JDBC框架提供的更好的解决方案。</p>
<p> 1）准备需要的jar包并添加到类路径中：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.springframework.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）传统JDBC编程替代方案：</p>
<p> 在使用JdbcTemplate模板类时必须通过DataSource获取数据库连接，Spring JDBC提供了DriverManagerDataSource实现，它通过包装“DriverManager.getConnection”获取数据库连接，具体DataSource相关请参考【7.5.1控制数据库连接】。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url=<span class="string">"jdbc:hsqldb:mem:test"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"123"</span>;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource(url,username,password);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"org.hsqldb.jdbcDriver"</span>);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、声明SQL</span></span><br><span class="line">        String sql=<span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//2.处理结果集</span></span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们具体分析一下：</p>
<p>1）  <strong>jdbc:hsqldb:mem:test：</strong>表示使用hsqldb内存数据库，数据库名为“test”。</p>
<p>2）  <strong>public static void setUpClass()：</strong>使用junit的@BeforeClass注解，表示在所以测试方法之前执行，且只执行一次。在此方法中定义了DataSource并使用DataSource对象创建了JdbcTemplate对象。JdbcTemplate对象是线程安全的。</p>
<p>3）  <strong>JdbcTemplate执行流程：</strong>首先定义SQL，其次调用JdbcTemplate方法执行SQL，最后通过RowCallbackHandler回调处理ResultSet结果集。</p>
<p>Spring JDBC解决方法相比传统JDBC编程方式是不是简单多了，是不是只有可变部分需要我们来做，其他的都由Spring JDBC框架来实现了。</p>
<p>接下来让我们深入JdbcTemplate及其扩展吧。</p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>​       首先让我们来看下如何使用JdbcTemplate来实现增删改查。</p>
<p> 一、首先创建表结构：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String createTableSql = <span class="string">"create memory table test"</span> + <span class="string">"(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "</span> + <span class="string">"name varchar(100))"</span>;</span><br><span class="line">    jdbcTemplate.update(createTableSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dropTableSql = <span class="string">"drop table test"</span>;</span><br><span class="line">    jdbcTemplate.execute(dropTableSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  org.junit包下的<strong>@Before和@After</strong>分别表示在测试方法之前和之后执行的方法，对于每个测试方法都将执行一次； </p>
<p>2）  <strong>create memory table test</strong>表示创建hsqldb内存表，包含两个字段id和name，其中id是具有自增功能的主键，如果有朋友对此不熟悉hsqldb可以换成熟悉的数据库。 </p>
<p>二、定义测试骨架，该测试方法将用于实现增删改查测试：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring-AOP/" itemprop="url">Spring--AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T16:21:43+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/4.jpg?raw=true" alt=""></p>
<h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>​       在进行AOP开发前，先熟悉几个概念：</p>
<ul>
<li><strong>连接点（Jointpoint）：</strong>表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，<strong>在AOP中表示为“在哪里干”</strong>；</li>
<li><strong>切入点（Pointcut）：</strong>选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，<strong>在AOP中表示为“在哪里干的集合”</strong>；</li>
<li><strong>通知（Advice）：</strong>在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；<strong>在AOP中表示为“干什么”；</strong></li>
<li><strong>方面/切面（Aspect）：</strong>横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；<strong>在AOP中表示为“在哪干和干什么集合”；</strong></li>
<li><strong>引入（inter-type declaration）：</strong>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, <strong>在AOP中表示为“干什么（引入什么）”</strong>；</li>
<li><strong>目标对象（Target Object）：</strong>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，<strong>在AOP中表示为“对谁干”</strong>；</li>
<li><strong>AOP代理（AOP Proxy）：</strong>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是<strong>通过代理来对目标对象应用切面</strong>。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li>
<li><p><strong>织入（Weaving）：</strong>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</p>
<p>在AOP中，通过切入点选择目标对象的连接点，然后在目标对象的相应连接点处织入通知，而切入点和通知就是切面（横切关注点），而在目标对象连接点处应用切面的实现方式是通过AOP代理对象，如图6-2所示。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/AOP%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.JPG?raw=true" alt=""></p>
</li>
</ul>
<p>图6-2 概念关系</p>
<p> 接下来再让我们具体看看Spring有哪些通知类型：</p>
<ul>
<li><strong>前置通知（Before Advice）:</strong>在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li>
<li><strong>后置通知（After Advice）:</strong>在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li>
<li><strong>后置返回通知(After returning Advice)：</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置异常通知(After throwing Advice):</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置最终通知(After finally Advice):</strong>在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java的finally块。</li>
<li><strong>环绕通知(Around Advice):</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li>
</ul>
<p>各种通知类型在UML序列图中的位置如图6-3所示:<br>   <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.JPG?raw=true" alt=""></p>
<p>图6-3 通知类型</p>
<h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>​       AOP代理就是AOP框架通过代理模式创建的对象，Spring使用JDK动态代理或CGLIB代理来实现，Spring缺省使用JDK动态代理来实现，从而任何接口都可别代理，如果被代理的对象实现不是接口将默认使用CGLIB代理，不过CGLIB代理当然也可应用到接口。</p>
<p>​        <strong>AOP代理的目的就是将切面织入到目标对象。</strong></p>
<p>​        概念都将完了，接下来让我们看一下AOP的 HelloWorld!吧。</p>
<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>​       首先准备开发需要的jar包，请到spring-framework-3.0.5.RELEASE-dependencies.zip和spring-framework-3.0.5.RELEASE-with-docs中查找如下jar包：</p>
<p>  org.springframework.aop-3.0.5.RELEASE.jar</p>
<p>  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</p>
<p>  com.springsource.org.aopalliance-1.0.0.jar</p>
<p>   com.springsource.net.sf.cglib-2.2.0.jar </p>
<h4 id="定义目标类"><a href="#定义目标类" class="headerlink" title="定义目标类"></a>定义目标类</h4><p>​       1）定义目标接口：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）定义目标接口实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注：在日常开发中最后将业务逻辑定义在一个专门的service包下，而实现定义在service包下的impl包中，服务接口以IXXXService形式，而服务实现就是XXXService，这就是规约设计，见名知义。当然可以使用公司内部更好的形式，只要大家都好理解就可以了。</p>
<h4 id="定义切面支持类"><a href="#定义切面支持类" class="headerlink" title="定义切面支持类"></a>定义切面支持类</h4><p>​       有了目标类，该定义切面了，切面就是通知和切入点的组合，而切面是通过配置方式定义的，因此这定义切面前，我们需要定义切面支持类，切面支持类提供了通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========after finally advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       此处HelloWorldAspect类不是真正的切面实现，只是定义了通知实现的类，在此我们可以把它看作就是缺少了切入点的切面。</p>
<p>​        注：对于AOP相关类最后专门放到一个包下，如“aop”包，因为AOP是动态织入的，所以如果某个目标类被AOP拦截了并应用了通知，可能很难发现这个通知实现在哪个包里，因此推荐使用规约命名，方便以后维护人员查找相应的AOP实现。</p>
<h4 id="在XML中进行配置"><a href="#在XML中进行配置" class="headerlink" title="在XML中进行配置"></a>在XML中进行配置</h4><p>有了通知实现，那就让我们来配置切面吧：</p>
<p>​       1）首先配置AOP需要aop命名空间，配置头如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       2）配置目标类：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       3）配置切面：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"helloWorldService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"aspect"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldAspect"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* com.zero.aop.*.*(..))"</span>/&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">"aspect"</span>&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"beforeAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">        &lt;aop:after pointcut=<span class="string">"execution(* com.zero.aop.*.*(..))"</span> method=<span class="string">"afterFinallyAdvice"</span>/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>​       切入点使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>配置，expression属性用于定义切入点模式，默认是AspectJ语法，“execution(<em> cn.javass..</em>.*(..))”表示匹配cn.javass包及子包下的任何方法执行。</p>
<p> 切面使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签配置，其中“ref”用来引用切面支持类的方法。</p>
<p> 前置通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签来定义，pointcut-ref属性用于引用切入点Bean，而method用来引用切面通知实现类中的方法，该方法就是通知实现，即在目标类方法执行之前调用的方法。</p>
<p> 最终通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签来定义，切入点除了使用pointcut-ref属性来引用已经存在的切入点，也可以使用pointcut属性来定义，如pointcut=”execution(<em> cn.javass..</em>.*(..))”，method属性同样是指定通知实现，即在目标类方法执行之后调用的方法。</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>测试类非常简单，调用被代理Bean跟调用普通Bean完全一样，Spring AOP将为目标对象创建AOP代理，具体测试代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop.xml"</span>);</span><br><span class="line">        IHelloWorldService helloworldService =</span><br><span class="line">                ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);</span><br><span class="line">        helloworldService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       该测试将输出如下如下内容：</p>
<p> ===========before advice<br>============Hello World!<br>===========after finally advice</p>
<p>​        从输出我们可以看出：前置通知在切入点选择的连接点（方法）之前允许，而后置通知将在连接点（方法）之后执行，具体生成AOP代理及执行过程如图6-4所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20AOP%E6%A1%86%E6%9E%B6%E7%94%9F%E6%88%90AOP%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.JPG?raw=true" alt=""></p>
<p> 图6-4 Spring AOP框架生成AOP代理过程</p>
<h3 id="基于Schema的AOP"><a href="#基于Schema的AOP" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h3><h4 id="基于Schema的AOP-1"><a href="#基于Schema的AOP-1" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h4><p>​     基于Schema的AOP从Spring2.0之后通过“aop”命名空间来定义切面、切入点及声明通知。</p>
<p> 在Spring配置文件中，所有AOP相关定义必须放在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，该标签下可以有<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>、<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>、<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签，配置顺序不可变。 </p>
<ul>
<li><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>：用来定义切入点，该切入点可以重用；</li>
<li><a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>：用来定义只有一个通知和一个切入点的切面；</li>
<li><p><a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，advisor只包含一个通知和一个切入点。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/aop-schema.JPG?raw=true" alt=""></p>
</li>
</ul>
<h4 id="声明切面"><a href="#声明切面" class="headerlink" title="声明切面"></a>声明切面</h4><p>​    切面就是包含切入点和通知的对象，在Spring容器中将被定义为一个Bean，Schema方式的切面需要一个切面支持Bean，该支持Bean的字段和方法提供了切面的状态和行为信息，并通过配置方式来指定切入点和通知实现。</p>
<p>​      切面使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签指定，ref属性用来引用切面支持Bean。</p>
<p>​     切面支持Bean“aspectSupportBean”跟普通Bean完全一样使用，切面使用“ref”属性引用它。</p>
<h4 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​    切入点在Spring中也是一个Bean，Bean定义方式可以有很三种方式：</p>
<p>​     <strong>1）在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>，该切入点可以被多个切面使用，对于需要共享使用的切入点最好使用该方式，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>**2）在&lt;aop:aspect&gt;*标签下使用&lt;aop:pointcut&gt;声明一个切入点Bean**，该切入点可以被多个切面使用，但一般该切入点只被该切面使用，当然也可以被其他切面使用，但最好不要那样使用，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式： 
</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">" pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>3）匿名切入点Bean，</strong>可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h4><p> 基于Schema方式支持前边介绍的5中通知类型：</p>
<p> <strong>一、前置通知：</strong>在切入点选择的方法之前执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">"前置通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">arg-names</span>=<span class="string">"前置通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>二者选一，指定切入点；</p>
<p>​         <strong>method：</strong>指定前置通知实现方法名，如果是多态需要加上参数类型，多个用“，”隔开，如beforeAdvice(java.lang.String)；</p>
<p>​         <strong>arg-names：</strong>指定通知实现方法的参数名字，多个用“，”分隔，可选，类似于【3.1.2 构造器注入】中的参数名注入限制：<strong>在class文件中没生成变量调试信息是获取不到方法参数名字的，因此只有在类没生成变量调试信息时才需要使用arg-names属性来指定参数名，如</strong>arg-names=”param”表示通知实现方法的参数列表的第一个参数名字为“param”。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayBefore(..)) and args(param)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">method</span>=<span class="string">"beforeAdvice(java.lang.String)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">arg-names</span>=<span class="string">"param"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaBeforeAdvice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">     ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">     IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">     helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=====================================================before advice param:before============say before==========================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayBefore(..)) ”匹配目标方法sayBefore，且使用“args(param)”匹配目标方法只有一个参数且传入的参数类型为通知实现方法中同名的参数类型；</p>
<p><strong>2）目标方法定义：</strong>使用method=” beforeAdvice(java.lang.String) “指定前置通知实现方法，且该通知有一个参数类型为java.lang.String参数；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=” param “指定通知实现方法参数名为“param”，切入点中使用“args(param)”匹配的目标方法参数将自动传递给通知实现方法同名参数。</p>
<p>   <strong>二、后置返回通知：</strong>在切入点选择的方法正常返回时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-returning" target="_blank" rel="noopener">aop:after-returning</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">"后置返回通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">"后置返回通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">returning</span>=<span class="string">"返回值对应的后置返回通知实现方法参数名"</span>  </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>returning：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法执行正常返回后，将把目标方法返回值传给通知方法；returning限定了只有目标方法返回值匹配与通知方法相应参数类型时才能执行后置返回通知，否则不执行，对于returning对应的通知方法参数为Object类型将匹配任何目标返回值。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============after returning"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterReturningAdvice"</span>  </span></span><br><span class="line"><span class="tag">                               <span class="attr">arg-names</span>=<span class="string">"retVal"</span>    </span></span><br><span class="line"><span class="tag">                               <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterReturningAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterReturning();      </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================after returning===========after returning advice retVal:true======================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterReturning(..)) ”匹配目标方法sayAfterReturning，该方法返回true；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterReturningAdvice”指定后置返回通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”retVal”指定通知实现方法参数名为“retVal”；</p>
<p><strong>4）返回值命名：</strong>returning=”retVal”用于将目标返回值赋值给通知实现方法参数名为“retVal”的参数上。</p>
<p> <strong>三、后置异常通知：</strong>在切入点选择的方法抛出异常时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-throwing" target="_blank" rel="noopener">aop:after-throwing</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"后置异常通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"后置异常通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"将抛出的异常赋值给的通知实现方法参数名"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>   <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>throwing：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；throwing限定了只有目标方法抛出的异常匹配与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，对于throwing对应的通知方法参数为Throwable类型将匹配任何异常。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============before throwing"</span>);  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterThrowingAdvice"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"exception"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"exception"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException.class)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterThrowingAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterThrowing();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================before throwing===========after throwing advice exception:java.lang.RuntimeException======================================</td>
</tr>
</tbody>
</table>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterThrowing(..))”匹配目标方法sayAfterThrowing，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterThrowingAdvice”指定后置异常通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”exception”指定通知实现方法参数名为“exception”；</p>
<p><strong>4）异常命名：</strong>returning=”exception”用于将目标方法抛出的异常赋值给通知实现方法参数名为“exception”的参数上。</p>
<p> <strong>四、后置最终通知：</strong>在切入点选择的方法返回时执行，不管是正常返回还是抛出异常都执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterFinally</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterFinally(..))”匹配目标方法sayAfterFinally，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=” afterFinallyAdvice “指定后置最终通知实现方法。</p>
<p> <strong>五、环绕通知：</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值，可通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:around &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型，在通知实现方法内部使用ProceedingJoinPoint的proceed()方法使目标方法执行，proceed 方法可以传入可选的Object[]数组，该数组的值将被作为目标方法执行时的参数。</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"============around param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.zero..*.sayAround(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">"aroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAroundAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAround(<span class="string">"haha"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ===========================</p>
<p>======================around before advice</p>
<p>============around param:replace</p>
<p>===========around after advice</p>
<p>====================================== </p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAround(..))”匹配目标方法sayAround；</p>
<p><strong>2）目标方法定义：</strong>使用method=”aroundAdvice”指定环绕通知实现方法，在该实现中，第一个方法参数为pjp，类型为ProceedingJoinPoint，其中“Object retVal = pjp.proceed(new Object[] {“replace”});”，用于执行目标方法，且目标方法参数被“new Object[] {“replace”}”替换，最后返回“retVal ”返回值。</p>
<p><strong>3）测试：</strong>我们使用“helloworldService.sayAround(“haha”);”传入参数为“haha”，但最终输出为“replace”，说明参数被替换了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);</span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);</span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​     Spring引入允许为目标对象引入新的接口，通过在&lt; aop:aspect&gt;标签内使用&lt; aop:declare-parents&gt;标签进行引入，定义方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">types-matching</span>=<span class="string">"AspectJ语法类型表达式"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">implement-interface</span>=<span class="string">引入的接口</span>"               </span></span><br><span class="line"><span class="tag">          <span class="attr">default-impl</span>=<span class="string">"引入接口的默认实现"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">delegate-ref</span>=<span class="string">"引入接口的默认实现Bean引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>types-matching：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；</p>
<p>​         <strong>implement-interface：</strong>定义需要引入的接口；</p>
<p>​         <strong>default-impl和delegate-ref：</strong>定义引入接口的默认实现，二者选一，default-impl是接口的默认实现类全限定名，而delegate-ref是默认的实现的委托Bean名；</p>
<p>接下来让我们练习一下吧：</p>
<p>​    首先定义引入的接口及默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroductiondService</span> <span class="keyword">implements</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========introduction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">"com.zero..*.IHelloWorldService+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">"com.zero.iin.IIntroductionService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">"com.zero.iin.IntroductiondService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后测试一下吧，测试代码cn.javass.spring.chapter6.AopTest：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaIntroduction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IIntroductionService introductionService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IIntroductionService.class);  </span><br><span class="line">    introductionService.induct();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> =========introduction</p>
<p> ======================================  </p>
<p> 分析一下吧：</p>
<p><strong>1）目标对象类型匹配：</strong>使用types-matching=”cn.javass..*.IHelloWorldService+”匹配IHelloWorldService接口的子类型，如HelloWorldService实现；</p>
<p><strong>2）引入接口定义：</strong>通过implement-interface属性表示引入的接口，如“cn.javass.spring.chapter6.service.IIntroductionService”。</p>
<p><strong>3）引入接口的实现：</strong>通过default-impl属性指定，如“cn.javass.spring.chapter6.service.impl.IntroductiondService”，也可以使用“delegate-ref”来指定实现的Bean。</p>
<p><strong>4）获取引入接口：</strong>如使用“ctx.getBean(“helloWorldService”, IIntroductionService.class);”可直接获取到引入的接口。</p>
<h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p> Advisor表示只有一个通知和一个切入点的切面，由于Spring AOP都是基于AOP联盟的拦截器模型的环绕通知的，所以引入Advisor来支持各种通知类型（如前置通知等5种），Advisor概念来自于Spring1.2对AOP的支持，在AspectJ中没有相应的概念对应。</p>
<p> Advisor可以使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>标签定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span> <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"通知API实现引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**二者选一，指定切入点表达式；</p>
<p>​         <strong>advice-ref：</strong>引用通知API实现Bean，如前置通知接口为MethodBeforeAdvice；</p>
<p> 接下来让我们看一下示例吧：</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三定义前置通知API实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceImpl</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在chapter6/advice.xml配置文件中先添加通知实现Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeAdvice"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.BeforeAdviceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，添加Advisor定义，添加时注意顺序：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..))"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAdvisor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">   IHelloWorldService helloworldService =  </span><br><span class="line">   ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">   helloworldService.sayAdvisorBefore(<span class="string">"haha"</span>);  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> ===========before advice</p>
<p> ============say haha</p>
<p> ======================================  </p>
<h3 id="基于-AspectJ的AOP"><a href="#基于-AspectJ的AOP" class="headerlink" title="基于@AspectJ的AOP"></a>基于@AspectJ的AOP</h3><p>​       Spring除了支持Schema方式配置AOP，还支持注解方式：使用@AspectJ风格的切面声明。</p>
<h4 id="启用对-AspectJ的支持"><a href="#启用对-AspectJ的支持" class="headerlink" title="启用对@AspectJ的支持"></a>启用对@AspectJ的支持</h4><p>Spring默认不支持@AspectJ风格的切面声明，为了支持需要使用如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样Spring就能发现@AspectJ风格的切面并且将切面应用到目标对象。</p>
<h4 id="声明切面-1"><a href="#声明切面-1" class="headerlink" title="声明切面"></a>声明切面</h4><p>​       @AspectJ风格的声明切面非常简单，使用@Aspect注解进行声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>()  </span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span></span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       然后将该切面在配置文件中声明为Bean后，Spring就能自动识别并进行AOP方面的配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"……Aspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       该切面就是一个POJO，可以在该切面中进行切入点及通知定义，接着往下看吧。</p>
<h4 id="声明切入点-1"><a href="#声明切入点-1" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​       @AspectJ风格的命名切入点使用org.aspectj.lang.annotation包下的@Pointcut+方法（方法必须是返回void类型）实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"切入点表达式"</span>, argNames = <span class="string">"参数名列表"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutName</span><span class="params">(……)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式；</p>
<p>​       <strong>argNames：</strong>指定命名切入点方法参数列表参数名字，可以有多个用“，”分隔，这些参数将传递给通知方法同名的参数，同时比如切入点表达式“args(param)”将匹配参数类型为命名切入点方法同名参数指定的参数类型。</p>
<p>​       <strong>pointcutName：</strong>切入点名字，可以使用该名字进行引用该切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个切入点，名字为“beforePointcut”，该切入点将匹配目标方法的第一个参数类型为通知方法实现中参数名为“param”的参数类型。</p>
<h4 id="声明通知-1"><a href="#声明通知-1" class="headerlink" title="声明通知"></a>声明通知</h4><p>​       @AspectJ风格的声明通知也支持5种通知类型：</p>
<p> <strong>一、前置通知：</strong>使用org.aspectj.lang.annotation 包下的@Before注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"切入点表达式或命名切入点"</span>, argNames = <span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义。</p>
<p>接下来示例一下吧：</p>
<p>1、定义接口和实现，在此我们就使用Schema风格时的定义；</p>
<p>2、定义切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;  </span><br><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect2</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义切入点：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义通知：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"beforePointcut(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在chapter6/advice2.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">            </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span>  </span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect2"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6、测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationBeforeAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice2.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<p> ==========================================</p>
<p> ===========before advice param:before</p>
<p> ============say before</p>
<p> ==========================================  </p>
<p>切面、切入点、通知全部使用注解完成：</p>
<p>​       1）使用@Aspect将POJO声明为切面；</p>
<p>​       2）使用@Pointcut进行命名切入点声明，同时指定目标方法第一个参数类型必须是java.lang.String，对于其他匹配的方法但参数类型不一致的将也是不匹配的，通过argNames = “param”指定了将把该匹配的目标方法参数传递给通知同名的参数上；</p>
<p>​       3）使用@Before进行前置通知声明，其中value用于定义切入点表达式或引用命名切入点；</p>
<p>​       4）配置文件需要使用<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>来开启注解风格的@AspectJ支持；</p>
<p>​       5）需要将切面注册为Bean，如“aspect”Bean；</p>
<p>​       6）测试代码完全一样。</p>
<p><strong>二、后置返回通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterReturning注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">returning=<span class="string">"返回值对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argName：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>returning：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayBefore(..))"</span>,  </span><br><span class="line">    pointcut=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"retVal"</span>, returning=<span class="string">"retVal"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterReturningAdvice测试方法。</p>
<p> <strong>三、后置异常通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterThrowing注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">throwing=<span class="string">"异常对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>throwing：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"exception"</span>, throwing=<span class="string">"exception"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterThrowingAdvice测试方法。</p>
<p> <strong>四、后置最终通知：</strong>使用org.aspectj.lang.annotation 包下的@After注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* cn.javass..*.sayAfterFinally(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after finally advice"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterFinallyAdvice测试方法。 </p>
<p><strong>五、环绕通知：</strong>使用org.aspectj.lang.annotation 包下的@Around注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value=<span class="string">"execution(* cn.javass..*.sayAround(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的annotationAroundAdviceTest测试方法。 </p>
<h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>​       @AspectJ风格的引入声明在切面中使用org.aspectj.lang.annotation包下的@DeclareParents声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">value=<span class="string">" AspectJ语法类型表达式"</span>,  </span><br><span class="line">defaultImpl=引入接口的默认实现类)  </span><br><span class="line"><span class="keyword">private</span> Interface <span class="class"><span class="keyword">interface</span></span>;</span><br></pre></td></tr></table></figure>
<p> <strong>value：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；与Schema方式中的types-matching属性同义；</p>
<p>​       private Interface interface<strong>：</strong>指定需要引入的接口；</p>
<p>​       defaultImpl<strong>：</strong>指定引入接口的默认实现类，没有与Schema方式中的delegate-ref属性同义的定义方式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">    value=<span class="string">"cn.javass..*.IHelloWorldService+"</span>, defaultImpl=cn.javass.spring.chapter6.service.impl.IntroductiondService.class)  </span><br><span class="line"><span class="keyword">private</span> IIntroductionService introductionService;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationIntroduction测试方法。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring之资源与表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring之资源与表达式/" itemprop="url">Spring之资源与表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T11:27:18+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E6%9C%88%E5%85%89%E4%B8%8B%E7%9A%84%E7%A5%81%E8%BF%9E%E5%B1%B1%E6%9C%80%E9%AB%98%E5%B3%B0.jpg?raw=true" alt=""></p>
<p>抄自：开涛  <a href="http://jinnianshilongnian.iteye.com/blog/1416319" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1416319</a></p>
<p>### </p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="资源基础知识"><a href="#资源基础知识" class="headerlink" title="资源基础知识"></a>资源基础知识</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在日常程序开发中，处理外部资源是很繁琐的事情，我们可能需要处理URL资源、File资源、ClassPath相关资源、服务器相关资源(JBoss AS 5.x 上的VFS资源)等等很多资源。因此处理这些资源需要使用不同的接口，这就增加了我们系统的复杂性；而且处理这些资源步骤都是类似的(打开资源、读取资源、关闭资源)，因此如果能抽象出一个统一的接口来对这些底层资源进行统一访问，是不是很方便，而且使我们系统更加简洁，都是对不同的底层资源使用同一个接口进行访问。</p>
<p>Spring提供了一个Resource接口来统一这些底层资源一直的访问，而且提供了一些便利的接口，从而能提供我们的生产力。</p>
<h4 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h4><p>Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;  </span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)InputStreamSource接口解析： </p>
<p><strong>getInputStream：</strong>每次调用都将返回一个新鲜的资源对应的java.io.InputStream字节流，调用者在使用完毕后必须关闭该资源。</p>
<p>2）Resource接口继承InputStreamSource接口，并提供一些便利方法：</p>
<ul>
<li><p><strong>exists：</strong>返回当前Resource代表的底层资源是否可读，true表示可读</p>
</li>
<li><p><strong>isReadable</strong>：返回当前Resource代表的底层资源是否可读，true表示可读。</p>
</li>
<li><p><strong>isOpen</strong>：返回当前Resource代表的底层资源是否已经打开，如果返回true，则只能被读取一次然后关闭以避免资源泄露；常见的Resource实现一般返回false。 </p>
</li>
<li><p><strong>getURL</strong>：如果当前Resource代表的底层资源能由java.util.URL代表，则返回该URL，否则抛出IOException。</p>
</li>
<li><p><strong>getURI</strong>：如果当前Resource代表的底层资源能由java.util.URI代表，则返回该URI，否则抛出IOException。 </p>
</li>
<li><p><strong>getFile</strong>：如果当前Resource代表的底层资源能由java.io.File代表，则返回该File，否则抛出IOException。 </p>
</li>
<li><p><strong>contentLength</strong>：返回当前Resource代表的底层文件资源的长度，一般是值代表的文件资源的长度。</p>
</li>
<li><p><strong>lastModified</strong> ：返回当前Resource代表的底层资源的最后修改时间。 </p>
</li>
<li><p><strong>createRelative</strong>：用于创建相对于当前Resource代表的底层资源的资源，比如当前Resource代表文件资源“d:/test/”则createRelative（“test.txt”）将返回表文件资源“d:/test/test.txt”Resource资源。 </p>
</li>
<li><p><strong>getFilename</strong>：返回当前Resource代表的底层文件资源的文件路径，比如File资源“file://d:/test.txt”将返回“d:/test.txt”，而URL资源<a href="http://www.javass.cn将返回“”，因为只返回文件路径。" target="_blank" rel="noopener">http://www.javass.cn将返回“”，因为只返回文件路径。</a> </p>
</li>
<li><p><strong>getDescription</strong>：返回当前Resource代表的底层资源的描述符，通常就是资源的全路径（实际文件名或实际URL地址）。</p>
<p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p>
</li>
</ul>
<h3 id="内置Resource实现"><a href="#内置Resource实现" class="headerlink" title="内置Resource实现"></a>内置Resource实现</h3><h4 id="ByteArrayResource"><a href="#ByteArrayResource" class="headerlink" title="ByteArrayResource"></a>ByteArrayResource</h4><p>ByteArrayResource代表byte[]数组资源对于“getInputStream”操作将返回一个ByteArrayInputStream。</p>
<p>首先让我们看下使用ByteArrayResource如何处理byte数组资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByteArrayResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ByteArrayResource(<span class="string">"Hello World !"</span>.getBytes()); <span class="comment">//得到一个操作系统默认的编码格式的字节数组。</span></span><br><span class="line">        <span class="keyword">if</span> (resource.exists())&#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，让我们看下“dumpStream”实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpStream</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取文件资源</span></span><br><span class="line">            is = resource.getInputStream();</span><br><span class="line">            <span class="comment">//2.读取资源</span></span><br><span class="line">            <span class="keyword">byte</span>[] descBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(descBytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(descBytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3.关闭资源</span></span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    让我们来仔细看一下代码，dumpStream方法很抽象定义了访问流的三部曲：打开资源、读取资源、关闭资源，所以dunpStrean可以再进行抽象从而能在自己项目中使用；byteArrayResourceTest测试方法，也定义了基本步骤：定义资源、验证资源存在、访问资源。</p>
<p>​        ByteArrayResource可多次读取数组资源，即isOpen ()永远返回false。</p>
<h4 id="InputStreamResource"><a href="#InputStreamResource" class="headerlink" title="InputStreamResource"></a>InputStreamResource</h4><p>​       InputStreamResource代表java.io.InputStream字节流，对于“getInputStream ”操作将直接返回该字节流，因此只能读取一次该字节流，即“isOpen”永远返回true。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInputStreamResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"Hello World!"</span>.getBytes());</span><br><span class="line">    Resource resource = <span class="keyword">new</span> InputStreamResource(bis);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h4><p>​       FileSystemResource代表java.io.File资源，对于“getInputStream ”操作将返回底层文件的字节流，“isOpen”将永远返回false，从而表示可多次读取底层文件的字节流。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意由于“isOpen”将永远返回false，所以可以多次调用dumpStream(resource)。</p>
<h4 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h4><p>​       ClassPathResource代表classpath路径的资源，将使用ClassLoader进行加载资源。classpath 资源存在于类路径中的文件系统中或jar包里，且“isOpen”永远返回false，表示可多次读取资源。</p>
<pre><code>ClassPathResource加载资源替代了Class类和ClassLoader类的“getResource(String name)”和“getResourceAsStream(String name)”两个加载类路径资源方法，提供一致的访问方式。
</code></pre><p> ClassPathResource提供了三个构造器：</p>
<p>​          <strong>public ClassPathResource(String path)</strong>：使用默认的ClassLoader加载“path”类路径资源；</p>
<p>​          <strong>public ClassPathResource(String path, ClassLoader classLoader)</strong>：使用指定的ClassLoader加载“path”类路径资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/test1.properties”；</p>
<p>​          <strong>public ClassPathResource(String path, Class&lt;?&gt; clazz)</strong>：使用指定的类加载“path”类路径资源，将加载相对于当前类的路径的资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties”；</p>
<p>​        而如果需要 加载的资源路径为“test1.properties”，将加载的资源为“cn/javass/spring/chapter4/test1.properties”。</p>
<p>​        让我们直接看测试代码吧：</p>
<p> 1）使用默认的加载器加载资源，将加载当前ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByDefaultClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）使用指定的ClassLoader进行加载资源，将加载指定的ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , cl);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）使用指定的类进行加载资源，将尝试加载相对于当前类的路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">    Resource resource1 = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , clazz);</span><br><span class="line">    <span class="keyword">if</span>(resource1.exists()) &#123;</span><br><span class="line">        dumpStream(resource1);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource1.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource1.isOpen());</span><br><span class="line"></span><br><span class="line">    Resource resource2 = <span class="keyword">new</span> ClassPathResource(<span class="string">"test1.properties"</span> , <span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">if</span>(resource2.exists()) &#123;</span><br><span class="line">        dumpStream(resource2);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource2.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource2.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       “resource1”将加载cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties资源；“resource2”将加载“cn/javass/spring/chapter4/test1.properties”；</p>
<p> 4）加载jar包里的资源，首先在当前类路径下找不到，最后才到Jar包里找，而且在第一个Jar包里找到的将被返回：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classpathResourceTestFromJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"overview.html"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getURL().getPath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前类路径包含“overview.html”，在项目的“resources”目录下，将加载该资源，否则将加载Jar包里的“overview.html”，而且不能使用“resource.getFile()”，应该使用“resource.getURL()”，因为资源不存在于文件系统而是存在于jar包里，URL类似于“file:/C:/…/***.jar!/overview.html”。</p>
<p> 类路径一般都是相对路径，即相对于类路径或相对于当前类的路径，因此如果使用“/test1.properties”带前缀“/”的路径，将自动删除“/”得到“test1.properties”。</p>
<h4 id="UrlResource"><a href="#UrlResource" class="headerlink" title="UrlResource"></a>UrlResource</h4><p>​       UrlResource代表URL资源，用于简化URL资源访问。“isOpen”永远返回false，表示可多次读取资源。</p>
<p>​        UrlResource一般支持如下资源访问：</p>
<p>​      UrlResource一般支持如下资源访问：</p>
<p>​         <strong>http：</strong>通过标准的http协议访问web资源，如new UrlResource(“http://地址”)；</p>
<p>​         <strong>ftp：</strong>通过ftp协议访问资源，如new UrlResource(“ftp://地址”)；</p>
<p>​         <strong>file：</strong>通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”)；</p>
<p>具体使用方法在此就不演示了，可以参考cn.javass.spring.chapter4.ResourceTest中urlResourceTest测试方法。</p>
<h4 id="ServletContextResource"><a href="#ServletContextResource" class="headerlink" title="ServletContextResource"></a>ServletContextResource</h4><p>​       ServletContextResource代表web应用资源，用于简化servlet容器的ServletContext接口的getResource操作和getResourceAsStream操作；在此就不具体演示了。</p>
<h4 id="VfsResource"><a href="#VfsResource" class="headerlink" title="VfsResource"></a>VfsResource</h4><p>VfsResource代表Jboss 虚拟文件系统资源。</p>
<p> Jboss VFS(Virtual File System)框架是一个文件系统资源访问的抽象层，它能一致的访问物理文件系统、jar资源、zip资源、war资源等，VFS能把这些资源一致的映射到一个目录上，访问它们就像访问物理文件资源一样，而其实这些资源不存在于物理文件系统。</p>
<p> 在示例之前需要准备一些jar包，在此我们使用的是Jboss VFS3版本，可以下载最新的Jboss AS 6x，拷贝lib目录下的“jboss-logging.jar”和“jboss-vfs.jar”两个jar包拷贝到我们项目的lib目录中并添加到“Java Build Path”中的“Libaries”中。</p>
<p> 让我们看下示例（cn.javass.spring.chapter4.ResourceTest）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForRealFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home"</span>);</span><br><span class="line"><span class="comment">//2.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mount(home, <span class="keyword">new</span> RealFileSystem(<span class="keyword">new</span> File(<span class="string">"d:"</span>)));</span><br><span class="line"><span class="comment">//3.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//4.通过一致的接口访问</span></span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.首先获取jar包路径</span></span><br><span class="line">        File realFile = <span class="keyword">new</span> File(<span class="string">"lib/org.springframework.beans-3.0.5.RELEASE.jar"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home2"</span>);</span><br><span class="line">        <span class="comment">//3.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mountZipExpanded(realFile, home,</span><br><span class="line">                TempFileProvider.create(<span class="string">"tmp"</span>, Executors.newScheduledThreadPool(<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//4.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"META-INF/spring.handlers"</span>);</span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​       通过VFS，对于jar里的资源和物理文件系统访问都具有一致性，此处只是简单示例，如果需要请到Jboss官网深入学习。</p>
<h3 id="访问Resource"><a href="#访问Resource" class="headerlink" title="访问Resource"></a>访问Resource</h3><h4 id="ResourceLoader接口"><a href="#ResourceLoader接口" class="headerlink" title="ResourceLoader接口"></a>ResourceLoader接口</h4><p>ResourceLoader接口用于返回Resource对象；其实现可以看作是一个生产Resource的工厂类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       getResource接口用于根据提供的location参数返回相应的Resource对象；而getClassLoader则返回加载这些Resource的ClassLoader。</p>
<p>​        Spring提供了一个适用于所有环境的DefaultResourceLoader实现，可以返回ClassPathResource、UrlResource；还提供一个用于web环境的ServletContextResourceLoader，它继承了DefaultResourceLoader的所有功能，又额外提供了获取ServletContextResource的支持。</p>
<p>​        ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：“classpath:path”表示返回ClasspathResource，“<a href="http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：" target="_blank" rel="noopener">http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testResourceLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader loader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">    Resource resource = loader.getResource(<span class="string">"classpath:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(ClassPathResource.class, resource.getClass());</span><br><span class="line">    Resource resource2 = loader.getResource(<span class="string">"file:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(UrlResource.class, resource2.getClass());</span><br><span class="line">    Resource resource3 = loader.getResource(<span class="string">"cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返默认可以加载ClasspathResource</span></span><br><span class="line">    Assert.assertTrue(resource3 <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于目前所有ApplicationContext都实现了ResourceLoader，因此可以使用其来加载资源。</p>
<p>​         <strong>ClassPathXmlApplicationContext：</strong>不指定前缀将返回默认的ClassPathResource资源，否则将根据前缀来加载资源；</p>
<p>​         <strong>FileSystemXmlApplicationContext：</strong>不指定前缀将返回FileSystemResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>WebApplicationContext：</strong>不指定前缀将返回ServletContextResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>其他：</strong>不指定前缀根据当前上下文返回Resource实现，否则将根据前缀来加载资源。</p>
<h4 id="ResourceLoaderAware接口"><a href="#ResourceLoaderAware接口" class="headerlink" title="ResourceLoaderAware接口"></a>ResourceLoaderAware接口</h4><p>​       ResourceLoaderAware是一个标记接口，用于通过ApplicationContext上下文注入ResourceLoader。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  首先准备测试Bean，我们的测试Bean还简单只需实现ResourceLoaderAware接口，然后通过回调将ResourceLoader保存下来就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）  配置Bean定义（chapter4/resourceLoaderAware.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）测试(cn.javass.spring.chapter4.ResoureLoaderAwareTest)：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        ResourceBean resourceBean = ctx.getBean(ResourceBean.class);</span><br><span class="line">        ResourceLoader loader = resourceBean.getResourceLoader();</span><br><span class="line">        Assert.assertTrue(loader <span class="keyword">instanceof</span> ApplicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意此处“loader instanceof ApplicationContext”，说明了ApplicationContext就是个ResoureLoader。</p>
<p>​        由于上述实现回调接口注入ResourceLoader的方式属于侵入式，所以不推荐上述方法，可以采用更好的自动注入方式，如“byType”和“constructor”，此处就不演示了。   </p>
<h4 id="注入Resource"><a href="#注入Resource" class="headerlink" title="注入Resource"></a>注入Resource</h4><p>​       通过回调或注入方式注入“ResourceLoader”，然后再通过“ResourceLoader”再来加载需要的资源对于只需要加载某个固定的资源是不是很麻烦，有没有更好的方法类似于前边实例中注入“java.io.File”类似方式呢？</p>
<p>​        Spring提供了一个PropertyEditor “ResourceEditor”用于在注入的字符串和Resource之间进行转换。因此可以使用注入方式注入Resource。</p>
<p>​        ResourceEditor完全使用ApplicationContext根据注入的路径字符串获取相应的Resource，说白了还是自己做还是容器帮你做的问题。</p>
<p> 接下让我们看下示例：</p>
<p>​        1）准备Bean：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）准备配置文件（chapter4/ resourceInject.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span> <span class="attr">value</span>=<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">"classpath:cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       注意此处“resourceBean1”注入的路径没有前缀表示根据使用的ApplicationContext实现进行选择Resource实现。</p>
<p>​        3）让我们来看下测试代码（cn.javass.spring.chapter4.ResourceInjectTest）吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter4/resourceInject.xml"</span>);</span><br><span class="line">    ResourceBean3 resourceBean1 = ctx.getBean(<span class="string">"resourceBean1"</span>, ResourceBean3.class);</span><br><span class="line">    ResourceBean3 resourceBean2 = ctx.getBean(<span class="string">"resourceBean2"</span>, ResourceBean3.class);</span><br><span class="line">    Assert.assertTrue(resourceBean1.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">    Assert.assertTrue(resourceBean2.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       接下来一节让我们深入ApplicationContext对各种Resource的支持，及如何使用更便利的资源加载方式。</p>
<h3 id="Resource通配符路径"><a href="#Resource通配符路径" class="headerlink" title="Resource通配符路径"></a>Resource通配符路径</h3><h4 id="使用路径通配符加载Resource"><a href="#使用路径通配符加载Resource" class="headerlink" title="使用路径通配符加载Resource"></a>使用路径通配符加载Resource</h4><p>​        前面介绍的资源路径都是非常简单的一个路径匹配一个资源，Spring还提供了一种更强大的Ant模式通配符匹配，从能一个路径匹配一批资源。</p>
<p>​        Ant路径通配符支持“？”、“*”、“**”，注意通配符匹配不包括目录分隔符“/”：</p>
<p> <strong>“?**</strong>”：匹配一个字符**，如“config?.xml”将匹配“config1.xml”；</p>
<p>​         <strong>“***</strong>”：匹配零个或多个字符串*<em>，如“cn/</em>/config.xml”将匹配“cn/javass/config.xml”，但不匹配匹配“cn/config.xml”；而“cn/config-*.xml”将匹配“cn/config-dao.xml”；</p>
<p>​         <strong>“****</strong>”：匹配路径中的零个或多个目录<strong>，如“cn/</strong>/config.xml”将匹配“cn /config.xml”，也匹配“cn/javass/spring/config.xml”；而“cn/javass/config-<strong>.xml”将匹配“cn/javass/config-dao.xml”，即把“</strong>”当做两个“*”处理。</p>
<p>Spring提供AntPathMatcher来进行Ant风格的路径匹配。具体测试请参考cn.javass.spring.chapter4. AntPathMatcherTest。</p>
<p>Spring在加载类路径资源时除了提供前缀“classpath:”的来支持加载一个Resource，还提供一个前缀“classpath*:”来支持加载所有匹配的类路径Resource。</p>
<p>Spring提供ResourcePatternResolver接口来加载多个Resource，该接口继承了ResourceLoader并添加了“Resource[] getResources(String locationPattern)”用来加载多个Resource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;  </span><br><span class="line">       String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;  </span><br><span class="line">       Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring提供了一个ResourcePatternResolver实现PathMatchingResourcePatternResolver，它是基于模式匹配的，默认使用AntPathMatcher进行路径匹配，它除了支持ResourceLoader支持的前缀外，还额外支持“classpath<em>:”用于加载所有匹配的类路径Resource，ResourceLoader不支持前缀“classpath</em>:”：</p>
<p> 首先做下准备工作，在项目的“resources”创建“META-INF”目录，然后在其下创建一个“INDEX.LIST”文件。同时在“org.springframework.beans-3.0.5.RELEASE.jar”和“org.springframework.context-3.0.5.RELEASE.jar”两个jar包里也存在相同目录和文件。然后创建一个“LICENSE”文件，该文件存在于“com.springsource.cn.sf.cglib-2.2.0.jar”里。</p>
<p> <strong>一、“classpath</strong>”：*<em> 用于加载类路径（包括jar包）中的一个且仅一个资源；对于多个匹配的也只返回一个，所以如果需要多个匹配的请考虑“classpath</em>:”前缀；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathPrefix</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();  </span><br><span class="line">    <span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, resources.length);  </span><br><span class="line">    <span class="comment">//只加载一个匹配的Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二、“classpath*”：</strong> 用于加载类路径（包括jar包）中的所有匹配的资源。带通配符的classpath使用“ClassLoader”的“Enumeration<url> getResources(String name)”方法来查找通配符之前的资源，然后通过模式匹配来获取匹配的资源。如“classpath:META-INF/*.LIST”将首先加载通配符之前的目录“META-INF”，然后再遍历路径进行子路径匹配从而获取匹配的资源。 </url></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefix</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">     ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();        </span><br><span class="line">     <span class="comment">//将加载多个绝对匹配的所有Resource  </span></span><br><span class="line">    <span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);      </span><br><span class="line">    <span class="comment">//将加载多个模式匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意“resources.length &gt;1”说明返回多个Resource。不管模式匹配还是非模式匹配只要匹配的都将返回。</p>
<pre><code>在“com.springsource.cn.sf.cglib-2.2.0.jar”里包含“asm-license.txt”文件，对于使用“classpath*: asm-*.txt”进行通配符方式加载资源将什么也加载不了“asm-license.txt”文件，注意一定是模式路径匹配才会遇到这种问题。这是由于“ClassLoader”的“getResources(String name)”方法的限制，对于name为“”的情况将只返回文件系统的类路径，不会包换jar包根路径。 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefixLimit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();      <span class="comment">//将首先通过ClassLoader.getResources("")加载目录，  </span></span><br><span class="line">    <span class="comment">//将只返回文件系统的类路径不返回jar的跟路径  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources = resolver.getResources(<span class="string">"classpath*:asm-*.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//将通过ClassLoader.getResources("asm-license.txt")加载  </span></span><br><span class="line">    <span class="comment">//asm-license.txt存在于com.springsource.net.sf.cglib-2.2.0.jar  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:asm-license.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">0</span>);       </span><br><span class="line">    <span class="comment">//将只加载文件系统类路径匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:LICENS*"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于“resolver.getResources(“classpath<em>:asm-</em>.txt”);”，由于在项目“resources”目录下没有所以应该返回0个资源；“resolver.getResources(“classpath<em>:asm-license.txt”);”将返回jar包里的Resource；“resolver.getResources(“classpath</em>:LICENS*”);”，因为将只返回文件系统类路径资源，所以返回1个资源。</p>
<p> 因此加载通配符路径时（即路径中包含通配符），必须包含一个根目录才能保证加载的资源是所有的，而不是部分。</p>
<p> <strong>三、“file”：</strong>加载一个或多个文件系统中的Resource。如“file:D:/*.txt”将返回D盘下的所有txt文件；      </p>
<p><strong>四、无前缀</strong>：通过ResourceLoader实现加载一个资源。</p>
<p>AppliacationContext提供的getResources方法将获取资源委托给ResourcePatternResolver实现，默认使用PathMatchingResourcePatternResolver。所有在此就无需介绍其使用方法了。</p>
<h4 id="注入Resource数组"><a href="#注入Resource数组" class="headerlink" title="注入Resource数组"></a>注入Resource数组</h4><p>​       Spring还支持注入Resource数组，直接看配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>log4j.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span> <span class="attr">value</span>=<span class="string">"classpath*:META-INF/INDEX.LIST"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean3"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath*:META-INF/INDEX.LIST<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       “resourceBean1”就不用多介绍了，传统实现方式；对于“resourceBean2”则使用前缀“classpath*”，看到这大家应该懂的，加载匹配多个资源；“resourceBean3”是混合使用的；测试代码在“cn.javass.spring.chapter4.ResourceInjectTest.testResourceArrayInject”。</p>
<p>​        Spring通过ResourceArrayPropertyEditor来进行类型转换的，而它又默认使用“PathMatchingResourcePatternResolver”来进行把路径解析为Resource对象。所有大家只要会使用“PathMatchingResourcePatternResolver”，其它一些实现都是委托给它的，比如AppliacationContext的“getResources”方法等。</p>
<h4 id="AppliacationContext实现对各种Resource的支持"><a href="#AppliacationContext实现对各种Resource的支持" class="headerlink" title="AppliacationContext实现对各种Resource的支持"></a>AppliacationContext实现对各种Resource的支持</h4><p>​       <strong>一、ClassPathXmlApplicationContext：</strong>默认将通过classpath进行加载返回ClassPathResource，提供两类构造器方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1）通过ResourcePatternResolver实现根据configLocation获取资源  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span>；  </span></span><br><span class="line"><span class="function">       <span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, ……)</span></span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//2）通过直接根据path直接返回ClasspathResource  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String path, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz, ……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       第一类构造器是根据提供的配置文件路径使用“ResourcePatternResolver ”的“getResources()”接口通过匹配获取资源；即如“classpath:config.xml”</p>
<p>​        第二类构造器则是根据提供的路径和clazz来构造ClassResource资源。即采用“public ClassPathResource(String path, Class&lt;?&gt; clazz)”构造器获取资源。</p>
<p>​        <strong>二、FileSystemXmlApplicationContext：</strong>将加载相对于当前工作目录的“configLocation”位置的资源，注意在linux系统上不管“configLocation”是否带“/”，都作为相对路径；而在window系统上如“D:/resourceInject.xml”是绝对路径。因此在除非很必要的情况下，不建议使用该ApplicationContext。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span></span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String... configLocations,……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       此处还需要注意：在linux系统上，构造器使用的是相对路径，而ctx.getResource()方法如果以“/”开头则表示获取绝对路径资源，而不带前导“/”将返回相对路径资源。如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"/root/confg.xml"</span>);  </span><br><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       因此如果需要加载绝对路径资源最好选择前缀“file”方式，将全部根据绝对路径加载。如在linux系统“ctx.getResource (“file:/root/confg.xml”);”    </p>
<h2 id="Spring表达式语言"><a href="#Spring表达式语言" class="headerlink" title="Spring表达式语言"></a>Spring表达式语言</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​       Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>​        表达式语言给静态Java语言增加了动态功能。</p>
<p>​        SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h4 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h4><p> 表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>​       SpEL支持如下表达式：</p>
<p><strong>一、基本表达式：</strong>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p><strong>二、类相关表达式：</strong>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p><strong>三、集合相关表达式：</strong>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p><strong>四、其他表达式</strong>：模板表达式。</p>
<p><strong>注：SpEL表达式中的关键字是不区分大小写的。</strong></p>
<h3 id="SpEL基础"><a href="#SpEL基础" class="headerlink" title="SpEL基础"></a>SpEL基础</h3><h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>​       首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>​        SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>​        让我们看下代码片段吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression =</span><br><span class="line">                parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<p>1）创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</p>
<p>2）解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</p>
<p>3）构造上下文：准备比如变量定义等等表达式需要的上下文数据。</p>
<p>4）求值：通过Expression接口的getValue方法根据上下文获得表达式值。</p>
<p>是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h4 id="SpEL原理及接口"><a href="#SpEL原理及接口" class="headerlink" title="SpEL原理及接口"></a>SpEL原理及接口</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/日志相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/日志相关/" itemprop="url">日志相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T15:39:35+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日志/" itemprop="url" rel="index">
                    <span itemprop="name">日志</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="日志相关的类"><a href="#日志相关的类" class="headerlink" title="日志相关的类"></a>日志相关的类</h4><h4 id="Logger-getLogger和-LogFactory-getLog"><a href="#Logger-getLogger和-LogFactory-getLog" class="headerlink" title="Logger.getLogger和 LogFactory.getLog"></a>Logger.getLogger和 LogFactory.getLog</h4><p>Logger来自log4j自己的包。如果用Logger.getLogger，需要一个log4j的jar包，用此方式你只能依靠log4；</p>
<p>而LogFactory来自common-logging包。如果用LogFactory.getLog，你可以用任何实现了通用日志接口的日志记录器替换log4j，而程序不受影响。apache的common-logging包是通用日志接口，通过这个中间层，你可以随便指定到底用哪个日志系统。增加系统的灵活性。若log4j它不存在, commons-logging 会另行选择其它的日志实现类。 这样保证了程序中不一定要使用log4j这个日志文件了 </p>
<p>增强灵活性的理由：   </p>
<ol>
<li>首先在classpath下寻找自己的配置文件commons-logging.properties，如果找到，则使用其中定义的Log实现类；</li>
<li>如果找不到commons-logging.properties  文件，则再查找是否已定义系统环境变量  org.apache.commons.logging.Log ，找到则使用其定义的 Log 实现类；  </li>
<li>否则，查看 classpath 中是否有 Log4j 的包，如果发现，则自动使用 Log4j 作为日志实现类；  </li>
<li>否则，使用 JDK 自身的日志实现类（ JDK1.4 以后才有日志实现类）；  </li>
<li>否则，使用 commons-logging 自己提供的一个简单的日志实现类 SimpleLog ；  </li>
</ol>
<p>为了简化配置 commons-logging ，一般不使用 commons-logging 的配置文件，也不设置与 commons-logging 相关的系统环境变量，而只需将 Log4j 的 Jar 包放置到 classpash 中就可以了。这样就很简单地完成了 commons-logging 与 Log4j 的融合。   </p>
<p>根据不同的性质，日志信息通常被分成不同的级别，从低到高依次是：“调试（ DEBUG ）”“信息（ INFO ）”“警告（ WARN ）”“错误（ERROR ）”“致命错误（ FATAL ）”。   </p>
<p>commons-logging 仅仅对 Log4j( 当然还包括其它 LOG 实现 ) 作了一层包装，具体的日志输出还是在内部转交给身后的 Log4j 来处理，还有log4j会默认的去classes目录下去寻找log4j.properties 文件</p>
<p>apache common logging是一种log的框架接口,它本身并不实现log记录的功能,而是在运行时动态查找目前存在的日志库,调用相关的日志函数,从而隐藏具体的日志实现  </p>
<p>log4j是具体的日志实现,真正负责”写”日志的这个功能  </p>
<p>common logging本身不是log,你可以把它看做是一个日志的接口  </p>
<p>而log4j就是日志的实现  </p>
<p>使用common logging方式实现日志,主要的原因在于可以忽略底层的日志实现,或者说为以后的日志实现库的更换提供透明界面  </p>
<p>你可以考虑下,假设从log4j更换为logback,势必要重写所有原本使用log4j的源代码,而使用common logging的情况下,只需要更换jar包,而不需要对源代码做任何改动</p>
<p>做日志的时候一般是两者一起用，commons-logging工作原理做接口，log4j做实现，应用起来比单独的使用log4j要简单  </p>
<p>commons-logging工作原理:  </p>
<ol>
<li>首先在classpath下寻找自己的配置文件commons-logging.properties,如果找到,则使用其中定义的Log实现类  </li>
<li>如果找不到commons-logging.properties文件,则在查找是否已定义系统环境变量org.apache.commons.logging.Log,找到则使用其定义的Log实现类 </li>
<li>查看classpath中是否有Log4j的包,如果发现,则自动使用Log4j作为日志实现类 </li>
<li>使用JDK自身的日志实现类(JDK1.4以后才有日志实现类) </li>
<li>使用commons-logging自己提供的一个简单的日志实现类SimpleLog (以上顺序不保证完全准确,请参考官方文档) commons-logging总是能找到一个日志实现类,并且尽可能找到一个”最合适”的日志实现类. </li>
</ol>
<h3 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h3><h4 id="commons-logging和slf4j两种日志门面的使用"><a href="#commons-logging和slf4j两种日志门面的使用" class="headerlink" title="commons-logging和slf4j两种日志门面的使用"></a>commons-logging和slf4j两种日志门面的使用</h4><p>　　早期<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>项目使用最多的日志门面是commons-logging，log4j是推荐的日志实现库，需要的jar包为commons-logging.jar、log4j.jar。   </p>
<p>　　现今java项目推荐的日志门面是slf4j，log4j仍是推荐的日志实现库，需要的jar包为slf4j-api.jar、slf4j-log4j12.jar、log4j.jar，其中绑定包slf4j-log4j12.jar指定了要使用的实现库。   </p>
<p>　　commons-logging存在osgi问题，但早期项目多使用其作为日志门面，为保证兼容仍使用其作为日志门面，但通过slf4j的静态绑定技术来加载具体的日志库log4j，需要的jar包为commons-logging.jar、jcl-over-slf4j.jar、slf4j-api.jar、slf4j-log4j12.jar、log4j.jar，其中jcl-over-slf4j.jar将日志的接口重定向到slf4j。</p>
<pre><code> 　　使用log4j需先将日志的相关信息在属性文件properties或xml文件配置好，剩下的事情就是在项目中的适当位置打日志。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bill">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Bill">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bill">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Bill</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/BOS-第六天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/BOS-第六天/" itemprop="url">BOS 第六天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T16:30:00+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定区"><a href="#定区" class="headerlink" title="定区"></a>定区</h3><p>目前接触到了三张表，区域，定区，分区</p>
<p>region<br>        定区<br>staff    取派员<br>subarea 分区上有可能定区的，但肯定有区域</p>
<p>​        </p>
<p>region分为多个subarea<br>那么去派员隶属于分区，那么去派员就应该和分区subare有关系。</p>
<p>受理业务：<br>        客户下单<br>        自动分单  给对应的取派员</p>
<p>取派员与定区相关联，定区和分区有关系。</p>
<p>模拟客户：客户端   都是有固定的地址  根据地址就可以判断是属于哪个定区的（有定区ID）<br>客户表里有  id name decidedzone </p>
<pre><code>在这里定区指向取派员表
</code></pre><h4 id="定区添加业务分析"><a href="#定区添加业务分析" class="headerlink" title="定区添加业务分析"></a>定区添加业务分析</h4><ol>
<li>定区添加  获取取派员的ID  下拉框选取  显示</li>
<li>循环更新  分区表  显示未被定区关联分区显示  checkbox显示<br>服务器端：action  接受表单信息</li>
<li>checkbox分区信息  能否提交给后台？  可以接收</li>
</ol>
<p>定区的主键ID是uuid<br>业务层：<br>    svae（decidezone（瞬时态，没有id，但是需要））<br>    更新分区的时候<br>    定区的主键策略  assigend 需要加ajax校验</p>
<h4 id="定区添加取派员下拉框显示"><a href="#定区添加取派员下拉框显示" class="headerlink" title="定区添加取派员下拉框显示"></a>定区添加取派员下拉框显示</h4><p>在这里由于之前设置了取派员的作废标识<br>所以这里不能用默认的findAll<br>前端代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;选择负责人&lt;/td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">	&lt;input class=<span class="string">"easyui-combobox"</span> name=<span class="string">"staff.id"</span></span><br><span class="line">					data-options=<span class="string">"valueField:'id',textField:'name',url:'<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/staffAction_ajaxList'"</span> /&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<p>action<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定区关联取派员</span><br><span class="line">@Action(value = <span class="string">"staffAction_ajaxList"</span>,results = &#123;@Result(name = <span class="string">"ajaxList"</span>,<span class="built_in">type</span> = <span class="string">"json"</span>)&#125;)</span><br><span class="line">public String <span class="function"><span class="title">ajaxList</span></span>() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		List&lt;Staff&gt; staffs=serviceFacade.getStaffService().findStaffInUse();</span><br><span class="line">		push(staffs);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		push(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"ajaxList"</span>;  //走全局结果集</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dao<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(<span class="string">"from Staff where deltag = '0' "</span>)</span><br><span class="line">public List&lt;Staff&gt; findStaffInUse();</span><br></pre></td></tr></table></figure></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>前端会发送多个ID往后端<br>分区的Update中的DecidedZone是一个对象。<br><img src="http://whyathere.github.io/images/bos/day05/定区添加截图.jpg" alt=""><br>从图可以看出<br>关联分区的时候，是一个对象。<br>创建DecidedZoneService相关的类<br>DecidedZoneServiceImpl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class DecidedZoneServiceImpl implements DecidedZoneService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DecidedZoneDao decidedZoneDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SubAreaDao subAreaDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save(DecidedZone model, String[] subareaIds) &#123;</span><br><span class="line">        //定区表添加 分区表外键更新</span><br><span class="line">        decidedZoneDao.save(model);</span><br><span class="line">        <span class="keyword">if</span> (subareaIds != null &amp;&amp; subareaIds.length != 0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String sid: subareaIds) &#123;</span><br><span class="line">                subAreaDao.assignSubareaToDecidedzone(model,sid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将DecidedZoneService添加到门面类FacadeService<br>DecidedZoneAction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 区域添加</span><br><span class="line">@Action(value = <span class="string">"decidedZoneAction_save"</span>, results = &#123;</span><br><span class="line">        @Result(name = <span class="string">"save"</span>, location = <span class="string">"/WEB-INF/pages/base/decidedzone.jsp"</span>)&#125;)</span><br><span class="line">public String <span class="function"><span class="title">save</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        String[] subAreaIds = getRequest().getParameterValues(<span class="string">"subAreaId"</span>);</span><br><span class="line">        serviceFacade.getDecidedZoneService().save(model,subAreaIds);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"save"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dao<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface SubAreaDao extends JpaRepository&lt;Subarea, String&gt;, JpaSpecificationExecutor&lt;Subarea&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Query(<span class="string">"from Subarea where decidedZone is null "</span>)</span><br><span class="line">    public List&lt;Subarea&gt; findnoassociation();</span><br><span class="line"></span><br><span class="line">    @Modifying</span><br><span class="line">    @Query(<span class="string">"update Subarea set decidedZone=?1 where id=?2"</span>)</span><br><span class="line">    public  void assignSubareaToDecidedzone(DecidedZone model,String sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关联分区选中的是<br>这里查找的是 Subarea的 decidedZone_id 不为空的<br>一旦被选中就会将 Subarea的 decidedZone_id 标记为1</p>
<h4 id="定区条件分页查询"><a href="#定区条件分页查询" class="headerlink" title="定区条件分页查询"></a>定区条件分页查询</h4><ol>
<li>给查询定区的窗口设置一个id<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"searchDecidedZoneForm"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>是否关联分区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;是否关联分区&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;select id=<span class="string">"cc"</span> class=<span class="string">"easyui-combobox"</span> name=<span class="string">"isAssociationSubarea"</span> style=<span class="string">"width:170px;"</span>&gt;</span><br><span class="line">                        &lt;option value=<span class="string">""</span>&gt;===请选择===&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">"1"</span>&gt;是&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">"0"</span>&gt;否&lt;/option&gt;</span><br><span class="line">                    &lt;/select&gt;</span><br><span class="line">                &lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<p>条件查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//条件查询定区</span><br><span class="line">  $(<span class="string">"#btn"</span>).click(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      //from序列化</span><br><span class="line">      var jsonObj = $(<span class="string">"#searchDecidedZoneForm"</span>).serializeJson();</span><br><span class="line">      //调用datagrid load 方法 form序列化</span><br><span class="line">      $(<span class="string">"#grid"</span>).datagrid(<span class="string">"load"</span>, jsonObj);</span><br><span class="line">      //3：关闭窗口</span><br><span class="line">      $(<span class="string">"#searchWindow"</span>).window(<span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>datagrid<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 收派标准数据表格</span><br><span class="line">$(<span class="string">'#grid'</span>).datagrid(&#123;</span><br><span class="line">    iconCls: <span class="string">'icon-forward'</span>,</span><br><span class="line">    fit: <span class="literal">true</span>,</span><br><span class="line">    border: <span class="literal">true</span>,</span><br><span class="line">    rownumbers: <span class="literal">true</span>,</span><br><span class="line">    striped: <span class="literal">true</span>,</span><br><span class="line">    pageList: [3, 5, 10],</span><br><span class="line">    pagination: <span class="literal">true</span>,</span><br><span class="line">    toolbar: toolbar,</span><br><span class="line">    url: <span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/decidedZoneAction_pageQuery"</span>,</span><br><span class="line">    idField: <span class="string">'id'</span>,</span><br><span class="line">    columns: columns,</span><br><span class="line">    onDblClickRow: doDblClickRow</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>条件分页查询Action<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 区域的分页查询</span><br><span class="line">@Action(value = <span class="string">"decidedZoneAction_pageQuery"</span>)</span><br><span class="line">public String <span class="function"><span class="title">pageQuery</span></span>() &#123;</span><br><span class="line">    //PageRequest pageable = new PageRequest(page - 1, rows);</span><br><span class="line">    //dao 参数 Pageable pageable 自动完成分页查询 将分页结果数据 自动封装到Page&lt;T&gt;</span><br><span class="line">    //从Page 对象获取总记录数 和 每页分页记录数List&lt;Staff&gt;</span><br><span class="line">    Page&lt;DecidedZone&gt; pageData = serviceFacade.getDecidedZoneService().pageQuery(getPageRequest(), getSpecification());</span><br><span class="line">    setPageData(pageData);</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"pageQuery"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CRM"><a href="#CRM" class="headerlink" title="CRM"></a>CRM</h3><h4 id="关联客户业务分析"><a href="#关联客户业务分析" class="headerlink" title="关联客户业务分析"></a>关联客户业务分析</h4><pre><code>要把所有的级联删除，否则可能删除全部的数据内容
</code></pre><ol>
<li>首先要将定区和客户关联起来，以便于通过客户信息找到定区，然后通过定区找到可以分配的取派员。</li>
<li>左边显示当前定区未关联的客户信息，右侧是显示已经关联的客户信息，而且可以左右移动<br> . 直观感觉是右侧的是提交    ，左右移动后要做关联，表内数据要更改。客户表内添加一个decidedzone_id</li>
<li>CRM是一个单独的系统，提供web服务。 </li>
<li>搭建新的系统 crm客户关系系统  customer</li>
<li>塔尖环境：ssh</li>
<li>为bos系统提供客户表的 crud 操作</li>
<li>restful 最典型的</li>
<li>@POST（保存） @PUT（修改） @GET（查询） @DELETE（删除） 四种注解表示类型</li>
<li>@Product 生产者 服务器响应客户端数据类型 CRM回送给BOS数据类型<br>@Customer  消费者 Bos发送给CRM系统数据类型 xml/json<br>@Path  客户端请求路径编写<br>@PathParam  获取请求路径的参数信息<br><a href="http://whyathere.github.io/images/bos/day05/RestFul示例.jpg" target="_blank" rel="noopener"></a>    </li>
</ol>
<p>本地测试OK之后再放业务</p>
<p>过程：ajax–&gt;bos–&gt;action–&gt;service–&gt;restful(crm)–&gt;WebClient(crud)</p>
<h4 id="定区关联客户之CRM系统环境搭建"><a href="#定区关联客户之CRM系统环境搭建" class="headerlink" title="定区关联客户之CRM系统环境搭建"></a>定区关联客户之CRM系统环境搭建</h4><p>hibernate.properties 用于自动建表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = <span class="string">"t_customer"</span>,catalog = <span class="string">"zero_bos"</span>)</span><br><span class="line">@XmlRootElement(name = <span class="string">"Customer"</span>)  //使用restful的时候要添加，网络传输序列化所需要的注解</span><br><span class="line">public class Customer implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    @GenericGenerator(name = <span class="string">"generator"</span>, strategy = <span class="string">"uuid"</span>)</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(generator = <span class="string">"generator"</span>)</span><br><span class="line">    private String id;</span><br></pre></td></tr></table></figure></p>
<p>CRM-SERVICE<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Produces(<span class="string">"*/*"</span>)</span><br><span class="line">public interface CustomerService &#123;</span><br><span class="line">    @GET</span><br><span class="line">    @Path(<span class="string">"/customer"</span>)</span><br><span class="line">    @Produces(&#123; <span class="string">"application/xml"</span>, <span class="string">"application/json"</span> &#125;)</span><br><span class="line">    public List&lt;Customer&gt; getNoAssociations();</span><br></pre></td></tr></table></figure></p>
<p>讲解：查询有@GET方法，路径”/customer”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/BOS-第七天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/BOS-第七天/" itemprop="url">BOS-第七天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T16:30:00+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="业务受理"><a href="#业务受理" class="headerlink" title="业务受理"></a>业务受理</h3><h4 id="取派业务业务分析说明"><a href="#取派业务业务分析说明" class="headerlink" title="取派业务业务分析说明"></a>取派业务业务分析说明</h4><p>当用户打电话来的时候，录入用户信息的时候，录入完之后。业务通知单就要生成，录入系统之后发生了什么呢？<br>这种物业通知单应该隶属于哪一个取派员，将这个通知单自动分配给取派员。<br>那么这里就是根据用户的地址自动分配给取派员，要自动分解是属于哪一个区域的取派员。</p>
<p>业务通知单自动分拣 说明  如下图</p>
<ol>
<li>系统自动根据委托发件人的详细地址CRM中的地址库进行完全匹配，获取对应的分拣<br> 编码：bos根据用户地址<br> webservice—-&gt;CRM<br> CRM提供根据地址查询客户信息的服务<br> findCustomerByAddress—&gt;Customer–&gt;decidezoneID–&gt;DecideZone–&gt;Staff<br> 业务通知单  给予  指定 取派员!<br> 总结：根据地址找到定区，以分配取派员</li>
<li>管理分区 匹配方法<br> 地址有误、客户找不到的时候第一个方法就不适用了<br> 通过分区中的属性，解析出详细地址，省市区。<br> 如果关键字相同就通过辅助关键字匹配。<br>例子：用户输入的取件地址<br> 规则：根据省市区查找区域，查询Region。通过级联查询找到这个区域的所有分区(subarea)<br> –&gt;循环筛选关键字–&gt;通过分区去找定区–&gt;Staff</li>
</ol>
<p>今天主要要实现的是自动分拣（自动分单）<br>两种方法的目的是一致的，最终都是分拣到取派员。</p>
<pre><code>有两种情况： 1.已经录入过客户，输入手机号以后会回显客户的其他信息。
           2.客户直接打电话过来，没有注册就需要通过bos添加到CRM里面
</code></pre><h4 id="通知单和工单设计说明"><a href="#通知单和工单设计说明" class="headerlink" title="通知单和工单设计说明"></a>通知单和工单设计说明</h4><pre><code>如果自动分拣成功，就有取派员的编号。
如果没有的话就是一个空值。自动分单也分类型：自动 人工  可以根据类型来查询
受理人：操作员    

业务通知单和工单：
业务通知单的：描述客户订单具体信息
工单：描述取派员任务
业务通知单一旦生成   对应一个工单（描述取派员任务）
工单的生成时机：自动分拣成功，系统自动生成工单；如果业务通知单自动分拣，人工--&gt;工单生成时机是在人工调度的时候生成。
</code></pre><h4 id="省市区三级联动"><a href="#省市区三级联动" class="headerlink" title="省市区三级联动"></a>省市区三级联动</h4><p>用户选择省 发送ajax请求  获取对应的市<br><img src="http://whyathere.github.io/images/bos/day07/取件省市区三级联动.jpg" alt=""><br>页面加载完成，立刻发送ajax请求，访问省信息<br>            //加载省<br>            $.post(“${pageContext.request.contextPath}/bc/regionAction_ajaxListProvinces”, function (data) {<br>                $(data).each(function () {<br>                    $(“#province”).append(“<option value="" + this + "">“ + this + “</option>“);<br>                });<br>            });<br>            //用户统计省  发送ajax  获取到对应的市<br>            $(“#province”).change(function () {<br>                $.post(‘${pageContext.request.contextPath}/bc/regionAction_ajaxListCitys’, {“province”: this.value}, function (data) {<br>                    //List<string><br>                    $(data).each(function () {<br>                        $(‘#city’).append(“<option value="" + this + "">“ + this + “</option>“);<br>                    });<br>                });<br>            });<br>Action<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    //省</span><br><span class="line">    @Action(value = <span class="string">"regionAction_ajaxListProvinces"</span>, results = &#123;@Result(name = <span class="string">"ajaxListProvinces"</span>, <span class="built_in">type</span> = <span class="string">"json"</span>)&#125;)</span><br><span class="line">    public String <span class="function"><span class="title">ajaxListProvinces</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; regions = serviceFacade.getRegionService().ajaxListProvinces();</span><br><span class="line">            push(regions);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"ajaxListProvinces"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">//当  省改变时，自动查询市</span><br><span class="line">    //City</span><br><span class="line">    @Action(value = <span class="string">"regionAction_ajaxListCitys"</span>, results = &#123;@Result(name = <span class="string">"ajaxListCitys"</span>, <span class="built_in">type</span> = <span class="string">"json"</span>)&#125;)</span><br><span class="line">    public String <span class="function"><span class="title">ajaxListCitys</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;String&gt; citys = serviceFacade.getRegionService().ajaxListCitys(model.getProvince());</span><br><span class="line">            push(citys);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"ajaxListCitys"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></string></p>
<p>但是这个时候多切换几次省市，就会发现问题。如下图：<br><img src="http://whyathere.github.io/images/bos/day07/省市区三级联动异常.jpg" alt=""><br>切换省以后，后面的市会将上次查找的也叠加进来。</p>
<p>优化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//加载省</span><br><span class="line">$.post(<span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/regionAction_ajaxListProvinces"</span>, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">    $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        $(<span class="string">"#province"</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//用户统计省  发送ajax  获取到对应的市</span><br><span class="line">$(<span class="string">"#province"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    $(<span class="string">"#city"</span>)[0].length=1;</span><br><span class="line">    $.post(<span class="string">'$&#123;pageContext.request.contextPath&#125;/bc/regionAction_ajaxListCitys'</span>, &#123;<span class="string">"province"</span>: this.value&#125;, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">        //List&lt;String&gt;</span><br><span class="line">        $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            $(<span class="string">'#city'</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//用户选择市  发送ajax  获取到对应的区</span><br><span class="line">$(<span class="string">"#city"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    $(<span class="string">"#district"</span>)[0].length=1;</span><br><span class="line">    $.post(<span class="string">'$&#123;pageContext.request.contextPath&#125;/bc/regionAction_ajaxListDistricts'</span>, &#123;<span class="string">"city"</span>: this.value&#125;, <span class="keyword">function</span> (data) &#123;</span><br><span class="line">        //List&lt;String&gt;</span><br><span class="line">        $(data).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            $(<span class="string">'#district'</span>).append(<span class="string">"&lt;option value='"</span> + this + <span class="string">"'&gt;"</span> + this + <span class="string">"&lt;/option&gt;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是这个时候又出问题了。在上次点击了省和市之后，然后再取消省和市的选择。单点击区会出现下面的情况：<br><img src="http://whyathere.github.io/images/bos/day07/省市区三级联动异常2.jpg" alt=""><br>这就很尴尬了，所以还是需要优化。在JS页面中，在city的联动中添加代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用户统计省  发送ajax  获取到对应的市</span><br><span class="line">         $(<span class="string">"#province"</span>).change(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">             $(<span class="string">"#city"</span>)[0].length=1;</span><br><span class="line">             $(<span class="string">"#district"</span>)[0].length=1;</span><br></pre></td></tr></table></figure></p>
<p>搞定！！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/BOS-第五天/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/BOS-第五天/" itemprop="url">BOS 第五天</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T16:30:00+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="分区之下拉框"><a href="#分区之下拉框" class="headerlink" title="分区之下拉框"></a>分区之下拉框</h3><hr>
<h4 id="分区添加业务分析"><a href="#分区添加业务分析" class="headerlink" title="分区添加业务分析"></a>分区添加业务分析</h4><p>城市region，国家地理区域<br>区域：需要划分成多个分区，区域过大。<br>分区：地理位置   明细信息  门牌号  单双号   路名 关键字 辅助关键字</p>
<p>分区添加：闵行区</p>
<p>分区信息更改：  bc subarea<br>subarea有一个外键：region id</p>
<p>Struts2表单数据封装<br>三种方式：</p>
<ul>
<li>1、modelDriven</li>
<li>2、set属性</li>
<li>3、对象 ognl表达式</li>
</ul>
<p>页面标签：region.id</p>
<hr>
<h4 id="分区添加之下拉框显示说明"><a href="#分区添加之下拉框显示说明" class="headerlink" title="分区添加之下拉框显示说明"></a>分区添加之下拉框显示说明</h4><p>subarea.jsp前端页面编辑<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"addSubareaForm"</span> method=<span class="string">"post"</span> action=<span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/subAreaAction_save"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在做分区添加的时候主键是怎么做的？<br>easyui的下拉框<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;</span><br><span class="line">    &lt;%--下拉框--%&gt;</span><br><span class="line">    &lt;input class=<span class="string">"easyui-combobox"</span> name=<span class="string">"region.id"</span></span><br><span class="line">    data-options=<span class="string">"valueField:'id',textField:'name',url:'json/standard.json'"</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>valueField:&apos;id&apos;:json格式数据返回的&apos;id&apos;的内容
textField：下拉框显示的内容。是id=&apos;id&apos;的name的值
</code></pre><p>后台是返回的是List<region></region></p>
<hr>
<h5 id="分区添加之区域列表回显实现"><a href="#分区添加之区域列表回显实现" class="headerlink" title="分区添加之区域列表回显实现"></a>分区添加之区域列表回显实现</h5><p>首先regionAction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//分区添加业务  区域全部查询  ajaxList形式返回</span><br><span class="line">@Action(value = <span class="string">"regionAction_ajaxList"</span>,results = &#123; @Result(name = <span class="string">"ajaxList"</span>, <span class="built_in">type</span> =<span class="string">"json"</span>)&#125;)</span><br><span class="line">public String <span class="function"><span class="title">ajaxList</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">       List&lt;Region&gt; regions=serviceFacade.getRegionService().ajaxList();</span><br><span class="line">       push(regions);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"ajaxList"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现层<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Region&gt; <span class="function"><span class="title">ajaxList</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> regionDao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样后端数据就完成了<br>然后前端想显示省市区的话需要在Region类内添加一个getName方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> province + city + district;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样前端就可以显示如下的格式<br>    山西省太原市小店区<br>但是由于get方法默认注解为@Column：在自动建表的时候，数据库里就会添加一个name的字段出来<br>由于这个字段跟Region表无关，因此必须要让这个字段不要在表里建立字段<br>需要添加注解：  @Transient<br>作用：瞬时，声明这个字段不会在表里创建出来，不要在表中建立name字段</p>
<hr>
<h4 id="分区添加之区域下拉框自动补全效果"><a href="#分区添加之区域下拉框自动补全效果" class="headerlink" title="分区添加之区域下拉框自动补全效果"></a>分区添加之区域下拉框自动补全效果</h4><pre><code>在前端添加参数
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data-options=<span class="string">"mode:'remote',valueField:'id'</span></span><br></pre></td></tr></table></figure>
<p>mode:’remote’ ：它会在你输入的时候到服务器获取数据<br>例如我输入一个’天’，那么它就会往后台添加一个p：天<br>那么就可以在后台添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//分区添加业务  区域全部查询  ajaxList形式返回</span><br><span class="line">@Action(value = <span class="string">"regionAction_ajaxList"</span>,results = &#123; @Result(name = <span class="string">"ajaxList"</span>, <span class="built_in">type</span> =<span class="string">"json"</span>)&#125;)</span><br><span class="line">public String <span class="function"><span class="title">ajaxList</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        String q=getParameter(<span class="string">"q"</span>);</span><br><span class="line">        //q如果没有值   就所有的都差  如果有值就模糊查询</span><br><span class="line">       List&lt;Region&gt; regions=serviceFacade.getRegionService().ajaxList(q);</span><br><span class="line">       push(regions);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"ajaxList"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实现层添加重载方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Region&gt; ajaxList(String q) &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(q))&#123;</span><br><span class="line">        //模糊查询</span><br><span class="line">      <span class="built_in">return</span>  regionDao.ajaxListRegionByProviceOrCityDistrict(<span class="string">"%"</span>+q+<span class="string">"%"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> regionDao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在DAO层添加方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> @Query(<span class="string">"from Region where province like ?1 or  city like ?1 or district like ?1"</span>)</span><br><span class="line">public List&lt;Region&gt; ajaxListRegionByProviceOrCityDistrict(String s);</span><br></pre></td></tr></table></figure></p>
<p>完成！！！注意返回值类型</p>
<hr>
<h4 id="分区添加业务功能"><a href="#分区添加业务功能" class="headerlink" title="分区添加业务功能"></a>分区添加业务功能</h4><p>1、首先在前端页面添加分区按钮点击事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//添加分区保存按钮点击事件</span><br><span class="line">$(<span class="string">"#save"</span>).click(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    //提交表单</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="string">"#addSubareaForm"</span>).form(<span class="string">"validate"</span>)) &#123;</span><br><span class="line">        $(<span class="string">"#addSubareaForm"</span>).submit();</span><br><span class="line">        $(<span class="string">"#addSubareaWindow"</span>).window(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2、创建subAreaAction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(<span class="string">"all"</span>)</span><br><span class="line">@Controller(<span class="string">"subareaAction"</span>)</span><br><span class="line">@Scope(<span class="string">"prototype"</span>)</span><br><span class="line">@Namespace(<span class="string">"/bc"</span>) // 根据页码的/user而来，不能乱写</span><br><span class="line">@ParentPackage(<span class="string">"bos"</span>) // 要进行扩展struts.xml中的</span><br><span class="line">public class SubareaAction extends BaseAction&lt;Subarea&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 区域添加</span><br><span class="line">    @Action(value = <span class="string">"subAreaAction_save"</span>, results = </span><br><span class="line">	&#123;@Result(name = <span class="string">"save"</span>, location = <span class="string">"/WEB-INF/pages/base/subarea.jsp"</span>)&#125;)</span><br><span class="line">    public String <span class="function"><span class="title">save</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            serviceFacade.getSubAreaService().save(model);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            push(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"save"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、依次创建 SubAreaService 和 SubAreaServiceImpl 以及 SubAreaDao<br>SubAreaService<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SubAreaService &#123;</span><br><span class="line">    public void save(Subarea model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SubAreaServiceImpl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class SubAreaServiceImpl implements SubAreaService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SubAreaDao subAreaDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save(Subarea model) &#123;</span><br><span class="line">    subAreaDao.save(model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SubAreaDao<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SubAreaDao extends JpaRepository&lt;Subarea, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="分区分页查询编码以及延迟加载问题说明"><a href="#分区分页查询编码以及延迟加载问题说明" class="headerlink" title="分区分页查询编码以及延迟加载问题说明"></a>分区分页查询编码以及延迟加载问题说明</h4><p><img src="http://whyathere.github.io/images/bos/day05/分区分析图.jpg" alt=""><br>依照其他action操作即可，但是肯定会有延迟加载的问题。<br>原因：事务管理在业务层有效，但是web没有延迟加载的 DecidedZone 和 Region 的数据。<br>DecidedZone在它的get方法上面添加 @JSON(serialize = false)<br>但是Region是需要的在页面上显示的<br>解决方法有两种：</p>
<ol>
<li>业务层   配置region立刻查询数据库  将数据封装到对象中</li>
<li>将entityManager对象生命周期延伸到web  可以被json plugin序列化的时候查询数据库</li>
<li>报错信息：<br>Caused by: org.hibernate.LazyInitializationException: could not initialize proxy - no Session<br> at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:167)<br> at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:215)<br> at org.hibernate.proxy.pojo.javassist.JavassistLazyInitializer.invoke(JavassistLazyInitializer.java:190)<br> at com.zero.bos.domain.bc.Region_$$_javassist_4.getCity(Region_$$_javassist_4.java)<br> … 90 more<br>原因是：Region数据拿不到<br>第一种 做法：在代码中，进行region的查询。查询后就会默认进行数据的封装，而不会在需要的时候再去查询。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;Subarea&gt; pageQuery(PageRequest pageable) &#123;</span><br><span class="line">    //拿到数据 但是没有region数据，要让它立即查询 需要调取数据</span><br><span class="line">    Page&lt;Subarea&gt; data = subAreaDao.findAll(pageable);</span><br><span class="line">    //目标数据</span><br><span class="line">    List&lt;Subarea&gt; list = data.getContent();</span><br><span class="line">    //拿到每一个数据</span><br><span class="line">    <span class="keyword">for</span> (Subarea s: list)&#123;</span><br><span class="line">        Hibernate.initialize(s.getRegion()); //立刻进行Region的查询  那么数据就都封装到data中了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每个进行查询，会向region表发语句，查询后就会默认封装到data中。</p>
<p>第二种：将EntityManager的生命周期放大<br>在web.xml中添加过滤器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--将EntityManager生命周期延伸到web--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;OpenEntityManagerInViewFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;OpenEntityManagerInViewFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="多表条件查询客户端实现"><a href="#多表条件查询客户端实现" class="headerlink" title="多表条件查询客户端实现"></a>多表条件查询客户端实现</h4><p>综合查询分析图：<br><img src="http://whyathere.github.io/images/bos/day05/综合查询分析.jpg" alt=""><br>这是一个多表、分页、条件的综合查询。<br>多条件查询，点击下一页的时候：客户端需要将用户输入表单的条件参数携带传给服务器<br>问题1：客户端每次分页查询的条件，是否可以不需要服务器提供<br>分页查询每次都是往：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: <span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/subAreaAction_pageQuery"</span>,</span><br></pre></td></tr></table></figure></p>
<p>这个地址发<br>由于条件参数是在from表单中的，但是我们需要带有分页的功能，那么就需要在点击分页的时候还带着之前的查询条件。<br>那么可以将form发送给datagrid插件，这个插件有功能可以将请求发送到它的url中<br>并且将条件发送给后台，而且点击就分页的时候也会带着这些条件。<br>datagrid插件 方法…向 url 地址发送请求  并且可以 携带参数？</p>
<p>那么点击查询按钮的时候，触发datagrid的load方法，将表单里的参数，转换成{}<br>测试load方法能否传递给后台：<br>页面添加代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">   //调用datagrid load 方法</span><br><span class="line">    $(<span class="string">"#grid"</span>).datagrid(<span class="string">"load"</span>,&#123;</span><br><span class="line">        name:<span class="string">'lisi'</span>,</span><br><span class="line">        age:23</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://whyathere.github.io/images/bos/day05/测试load方法的请求.jpg" alt=""><br>可以看到会往后台查询action发送，两个参数而且还有页面。<br>而且刷新之后，会再次往服务器发送请求，并且带着之前的参数。<br>服务器不需要将条件回送</p>
<p>查询是调用的datagrid的load方法，将参数json给load方法参数<br>解决：每一次分页查询，客户端都会将条件参数自动的发送给datagrid的url<br>每次调用dagagrid的load方法都会向datagrid的url发送请求，发送条件和页码</p>
<p>那么form表单如何将input数据  转换json对象<br>{region.privince：’江苏省’,…}—-&gt;load  pageQuery Model:Subarea<br>那么form对象如何序列化：<br>jquery表单 序列号json<br>searileze()—&gt;name=list&amp;age=23<br>searlizeArra()  是一个数组<br>那么就需要自己拼接出来<br>$.fn.来扩展jquery的方法,将对象转换为json对象发送给后台<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//封装js方法，基于jquery</span><br><span class="line">$.fn.serializeJson = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var serializeObj = &#123;&#125;;</span><br><span class="line">    var array = this.serializeArray();</span><br><span class="line">    var str = this.serialize();</span><br><span class="line">    $(array).each(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="keyword">if</span> (serializeObj[this.name]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($.isArray(serializeObj[this.name])) &#123;</span><br><span class="line">                serializeObj[this.name].push(this.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serializeObj[this.name] = [serializeObj[this.name], this.value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serializeObj[this.name] = this.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> serializeObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样前端的页面就完成了。</p>
<hr>
<h4 id="分区条件查询之单表查询代码实现"><a href="#分区条件查询之单表查询代码实现" class="headerlink" title="分区条件查询之单表查询代码实现"></a>分区条件查询之单表查询代码实现</h4><p>分析：客户端 提交参数  条件参数  可变  page+rows—&gt;action–&gt;pageQuery方法<br>那么就要考虑model能不能接收这些条件参数<br>page和rows  是BaseAction接收的，可以接收<br>条件参数 –&gt;封装Model 也就是 SubArea对象中<br>由于是使用ognl表达式，所以前端页面上面的要加上region.province</p>
<p>JpaRepository&lt;Subarea, String&gt;无法完成复杂的查询</p>
<p>JpaSpecificationExecutor<subarea>帮助我们完成复杂条件的查询<br>接口可以继承多个接口，用，隔开即可<br>这样Impl类就有<br>findAll（specal，pageable）;<br>action调用实现类<br>那么action就需要提供给它2个参数<br>参数1：Specification<br>参数2：PageRequest  page rows<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Specification&lt;T&gt; &#123;</span><br><span class="line">    Predicate toPredicate(Root&lt;T&gt; var1, CriteriaQuery&lt;?&gt; var2, CriteriaBuilder var3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></subarea></p>
<p>参数1是一个接口，我们需要在action编写一个该接口的实现类。<br>接口的方法，实现类实现该方法，将请求参数  封装到Predicate<br>那么就是model里面取数据，然后往接口的实现类里面封<br>难度就是怎么写出来实现类；</p>
<p>spring data jpa如果做复杂的单表查询或者多表的复杂查询，全部采用<br>将条件封装到接口  Specification接口的实现类中<br>然后直接传递给DAO  即可，dao只需要继承JpaSpecificationExcecutor<t><br>首先进行无条件的测试：<br>SubareaAction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Action(value = <span class="string">"subAreaAction_pageQuery"</span>)</span><br><span class="line">public String <span class="function"><span class="title">pageQuery</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //将条件从Model中取出来  封装到Specification接口实现方法中</span><br><span class="line">        Specification&lt;Subarea&gt; spec=new Specification&lt;Subarea&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;Subarea&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                <span class="built_in">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></t></p>
<p>service<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;Subarea&gt; pageQuery(PageRequest pageRequest, Specification&lt;Subarea&gt; spec);</span><br></pre></td></tr></table></figure></p>
<p>serviceImpl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;Subarea&gt; pageQuery(PageRequest pageRequest, Specification&lt;Subarea&gt; spec) &#123;</span><br><span class="line">    <span class="built_in">return</span> subAreaDao.findAll(spec,pageRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动后查询正常</p>
<hr>
<p>下面进行条件查询<br>所以的查询关系都是and条件<br>数组不好声明，因为不确定条件有几个。但是可以用集合，然后转换成数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 区域的分页查询 分区分页查询 无条件分页+无条件分页查询</span><br><span class="line">//Subarea封装所有的请求参数条件 mysql <span class="built_in">limit</span> oracle rownum 动态的sql ，条件不一样</span><br><span class="line">@Action(value = <span class="string">"subAreaAction_pageQuery"</span>)</span><br><span class="line">public String <span class="function"><span class="title">pageQuery</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //将条件从Model中取出来  封装到Specification接口实现方法中</span><br><span class="line">        Specification&lt;Subarea&gt; spec=new Specification&lt;Subarea&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;Subarea&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) &#123;</span><br><span class="line">                List&lt;Predicate&gt; list=new ArrayList&lt;Predicate&gt;();  //存放多个对象条件</span><br><span class="line">                //条件封装实现  root（查询的主表对象实体类） query  <span class="built_in">cd</span>（连接对象条件 类似 hibernate Critira Restrictions.）三个关键字</span><br><span class="line">                //1：关键字查询  查询自己的表就可以了 不需要多表连接的</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(model.getAddresskey()))&#123;</span><br><span class="line">                    //用户要进行关键字查询   前面是需要匹配的字段 后面是匹配的值  进行模糊查询</span><br><span class="line">                   Predicate p1= cb.like(root.get(<span class="string">"addresskey"</span>).as(String.class),<span class="string">"%"</span>+model.getAddresskey()+<span class="string">"%"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                //2:多表查询   分区连接区域</span><br><span class="line"></span><br><span class="line">                Predicate[] p=new Predicate[list.size()];</span><br><span class="line">                <span class="built_in">return</span> cb.and(list.toArray(p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //2：</span><br><span class="line">        //PageRequest pageable = new PageRequest(page - 1, rows);</span><br><span class="line">        //dao 参数 Pageable pageable 自动完成分页查询 将分页结果数据 自动封装到Page&lt;T&gt;</span><br><span class="line">        //从Page 对象获取总记录数 和 每页分页记录数List&lt;Staff&gt;</span><br><span class="line">        Page&lt;Subarea&gt; pageData = serviceFacade.getSubAreaService().pageQuery(getPageRequest(),spec);</span><br><span class="line">        setPageData(pageData);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        push(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"pageQuery"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>创建接口的实现类</li>
<li>将model取出来放到实现类的方法中</li>
<li>通过model取条件</li>
</ol>
<h4 id="分区条件查询多表查询实现"><a href="#分区条件查询多表查询实现" class="headerlink" title="分区条件查询多表查询实现"></a>分区条件查询多表查询实现</h4><p>root参数代表的是主表<br>root–&gt;Subarea—&gt;Region<br>它会在判断到model.getRegion不为null的时候去连接Region表，那么怎么连接呢？<br>在一方当中，多方是一个set集合<br>在这里 root n: 1 region 多方连接一方<br>一方连接一方<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.join(root.getModel().getSingularAttribute(<span class="string">"region"</span>, Region.class), JoinType.LEFT);</span><br></pre></td></tr></table></figure></p>
<p>如果是多方的话就是getSet<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//2:多表查询   分区连接区域</span><br><span class="line"> <span class="keyword">if</span> (model.getRegion() != null) &#123;</span><br><span class="line">     //连接区域表</span><br><span class="line">     Join&lt;Subarea, Region&gt; regionJoin = root.join(root.getModel().getSingularAttribute(<span class="string">"region"</span>, Region.class), JoinType.LEFT);</span><br><span class="line">     //regionJoin 操作 区域表</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getProvince())) &#123;</span><br><span class="line">         Predicate p2 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"province"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getProvince() + <span class="string">"%"</span>);</span><br><span class="line">         list.add(p2);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getCity())) &#123;</span><br><span class="line">         Predicate p3 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"city"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getCity() + <span class="string">"%"</span>);</span><br><span class="line">         list.add(p3);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getDistrict())) &#123;</span><br><span class="line">         Predicate p4 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"district"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getDistrict() + <span class="string">"%"</span>);</span><br><span class="line">         list.add(p4);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>定区编号只要oid==相等就会被当成一个对象，所以比较的不是内存地址。除去了内存编号的地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3:定区的编号查询  root subarea --decidezone</span><br><span class="line">                    <span class="keyword">if</span> (model.getDecidedZone()!=null&amp;&amp;StringUtils.isNotBlank(model.getDecidedZone().getId()))&#123;</span><br><span class="line">                   Predicate p5=     cb.equal(root.get(<span class="string">"decidedZone"</span>).as(DecidedZone.class),model.getDecidedZone());</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只要model.getDecidedZone()不为null，它就有OID<br>cb.equal(root.get(“decidedZone”).as(DecidedZone.class) 如果和model.getDecidedZone()<br>是相等的对象，那就有OID了。<br>完整代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 区域的分页查询 分区分页查询 无条件分页+无条件分页查询</span><br><span class="line">//Subarea封装所有的请求参数条件 mysql <span class="built_in">limit</span> oracle rownum 动态的sql ，条件不一样</span><br><span class="line">@Action(value = <span class="string">"subAreaAction_pageQuery"</span>)</span><br><span class="line">public String <span class="function"><span class="title">pageQuery</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //将条件从Model中取出来  封装到Specification接口实现方法中</span><br><span class="line">        Specification&lt;Subarea&gt; spec = new Specification&lt;Subarea&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;Subarea&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) &#123;</span><br><span class="line">                List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;();  //存放多个对象条件</span><br><span class="line">                //条件封装实现  root（查询的主表对象实体类） query  <span class="built_in">cd</span>（连接对象条件 类似 hibernate Critira Restrictions.）三个关键字</span><br><span class="line">                //1：关键字查询  查询自己的表就可以了 不需要多表连接的</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(model.getAddresskey())) &#123;</span><br><span class="line">                    //用户要进行关键字查询   前面是需要匹配的字段 后面是匹配的值  进行模糊查询</span><br><span class="line">                    Predicate p1 = cb.like(root.get(<span class="string">"addresskey"</span>).as(String.class), <span class="string">"%"</span> + model.getAddresskey() + <span class="string">"%"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                //2:多表查询   分区连接区域</span><br><span class="line">                <span class="keyword">if</span> (model.getRegion() != null) &#123;</span><br><span class="line">                    //连接区域表</span><br><span class="line">                    Join&lt;Subarea, Region&gt; regionJoin = root.join(root.getModel().getSingularAttribute(<span class="string">"region"</span>, Region.class), JoinType.LEFT);</span><br><span class="line">                    //regionJoin 操作 区域表</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getProvince())) &#123;</span><br><span class="line">                        Predicate p2 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"province"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getProvince() + <span class="string">"%"</span>);</span><br><span class="line">                        list.add(p2);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getCity())) &#123;</span><br><span class="line">                        Predicate p3 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"city"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getCity() + <span class="string">"%"</span>);</span><br><span class="line">                        list.add(p3);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getDistrict())) &#123;</span><br><span class="line">                        Predicate p4 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"district"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getDistrict() + <span class="string">"%"</span>);</span><br><span class="line">                        list.add(p4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //3:定区的编号查询  root subarea --decidezone</span><br><span class="line">                <span class="keyword">if</span> (model.getDecidedZone() != null &amp;&amp; StringUtils.isNotBlank(model.getDecidedZone().getId())) &#123;</span><br><span class="line">                    Predicate p5 = cb.equal(root.get(<span class="string">"decidedZone"</span>).as(DecidedZone.class), model.getDecidedZone());</span><br><span class="line">                    list.add(p5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //集合转换成数组</span><br><span class="line">                Predicate[] p = new Predicate[list.size()];</span><br><span class="line">                <span class="built_in">return</span> cb.and(list.toArray(p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //2：</span><br><span class="line">        //PageRequest pageable = new PageRequest(page - 1, rows);</span><br><span class="line">        //dao 参数 Pageable pageable 自动完成分页查询 将分页结果数据 自动封装到Page&lt;T&gt;</span><br><span class="line">        //从Page 对象获取总记录数 和 每页分页记录数List&lt;Staff&gt;</span><br><span class="line">        Page&lt;Subarea&gt; pageData = serviceFacade.getSubAreaService().pageQuery(getPageRequest(), spec);</span><br><span class="line">        setPageData(pageData);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        push(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"pageQuery"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CriteriaBuilder就相当于连接条件<br>Root代表着我们的泛型</p>
<hr>
<h3 id="分区数据导出"><a href="#分区数据导出" class="headerlink" title="分区数据导出"></a>分区数据导出</h3><p>将满足条件的数据  通过  导出…<br>浏览器   采用下载的形式  将数据  生成Excel文档<br>1、满足条件数据如何查询到</p>
<p>2、满足数据List<t>  27条记录<br>下载….Poi 生成工作簿  才能下载<br>读的时候也是读到内存里，然后存到数据库。<br>—&gt;List<t>—-&gt;WorkBook(sheet row cell)<br>3、workbook.write(response.getOutputStream())<br>添加两个头  附件形式下载</t></t></p>
<p><img src="http://whyathere.github.io/images/bos/day05/分区数据导出功能.jpg" alt=""></p>
<p>首先点击前端页面的导出按钮：<br>浏览器导出（下载形式） 生成Excel 直接发请求的时候把满足的条件找到，条件可能有0到N个，那么条件要<br>怎么传递给后端呢？<br>解决：直接提交表单   把条件都带过去  到后端去验证<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"searchSubareaForm"</span> action=<span class="string">"<span class="variable">$&#123;pageContext.request.contextPath&#125;</span>/bc/subAreaAction_download"</span> method=<span class="string">"post"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>后端代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">//subAreaAction_download  接收表单的提交的参数信息  对多条件查询</span><br><span class="line">    @Action(value = <span class="string">"subAreaAction_download"</span>)</span><br><span class="line">    public String <span class="function"><span class="title">download</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将条件从Model中取出来  封装到Specification接口实现方法中</span><br><span class="line">            Specification&lt;Subarea&gt; spec = new Specification&lt;Subarea&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Predicate toPredicate(Root&lt;Subarea&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) &#123;</span><br><span class="line">                    List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;();  //存放多个对象条件</span><br><span class="line">                    //条件封装实现  root（查询的主表对象实体类） query  <span class="built_in">cd</span>（连接对象条件 类似 hibernate Critira Restrictions.）三个关键字</span><br><span class="line">                    //1：关键字查询  查询自己的表就可以了 不需要多表连接的</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(model.getAddresskey())) &#123;</span><br><span class="line">                        //用户要进行关键字查询   前面是需要匹配的字段 后面是匹配的值  进行模糊查询</span><br><span class="line">                        Predicate p1 = cb.like(root.get(<span class="string">"addresskey"</span>).as(String.class), <span class="string">"%"</span> + model.getAddresskey() + <span class="string">"%"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //2:多表查询   分区连接区域</span><br><span class="line">                    <span class="keyword">if</span> (model.getRegion() != null) &#123;</span><br><span class="line">                        //连接区域表</span><br><span class="line">                        Join&lt;Subarea, Region&gt; regionJoin = root.join(root.getModel().getSingularAttribute(<span class="string">"region"</span>, Region.class), JoinType.LEFT);</span><br><span class="line">                        //regionJoin 操作 区域表</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getProvince())) &#123;</span><br><span class="line">                            Predicate p2 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"province"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getProvince() + <span class="string">"%"</span>);</span><br><span class="line">                            list.add(p2);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getCity())) &#123;</span><br><span class="line">                            Predicate p3 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"city"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getCity() + <span class="string">"%"</span>);</span><br><span class="line">                            list.add(p3);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotBlank(model.getRegion().getDistrict())) &#123;</span><br><span class="line">                            Predicate p4 = cb.like(regionJoin.&lt;String&gt;get(<span class="string">"district"</span>).as(String.class), <span class="string">"%"</span> + model.getRegion().getDistrict() + <span class="string">"%"</span>);</span><br><span class="line">                            list.add(p4);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //3:定区的编号查询  root subarea --decidezone</span><br><span class="line">                    <span class="keyword">if</span> (model.getDecidedZone() != null &amp;&amp; StringUtils.isNotBlank(model.getDecidedZone().getId())) &#123;</span><br><span class="line">                        Predicate p5 = cb.equal(root.get(<span class="string">"decidedZone"</span>).as(DecidedZone.class), model.getDecidedZone());</span><br><span class="line">                        list.add(p5);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //集合转换成数组</span><br><span class="line">                    Predicate[] p = new Predicate[list.size()];</span><br><span class="line">                    <span class="built_in">return</span> cb.and(list.toArray(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            //2：</span><br><span class="line">            //PageRequest pageable = new PageRequest(page - 1, rows);</span><br><span class="line">            //dao 参数 Pageable pageable 自动完成分页查询 将分页结果数据 自动封装到Page&lt;T&gt;</span><br><span class="line">            //从Page 对象获取总记录数 和 每页分页记录数List&lt;Staff&gt;</span><br><span class="line">            //Page&lt;Subarea&gt; pageData = serviceFacade.getSubAreaService().pageQuery(getPageRequest(), spec);</span><br><span class="line">            //2：dao已经实现了多条件查询</span><br><span class="line">            List&lt;Subarea&gt; subs = serviceFacade.getSubAreaService().findSubareaBySpecification(spec);</span><br><span class="line">            //setPageData(pageData);</span><br><span class="line">            //3: 将集合数据写入到工作簿当中   POI加上下载知识点</span><br><span class="line">            //先写到工作簿中去</span><br><span class="line">            //创建Excel工作簿</span><br><span class="line">            HSSFWorkbook workbook = new HSSFWorkbook();</span><br><span class="line">            //在excel中建一个工作表，其名为缺省值</span><br><span class="line">            HSSFSheet sheet = workbook.createSheet(<span class="string">"铁"</span>);</span><br><span class="line">            //在索引0的位置创建行（最顶端的行）</span><br><span class="line">            HSSFRow row = sheet.createRow(0);</span><br><span class="line">            //在索引0的位置创建单元格(左上端)</span><br><span class="line">            //标题</span><br><span class="line">            row.createCell(0).setCellValue(<span class="string">"分区编号"</span>);</span><br><span class="line">            row.createCell(1).setCellValue(<span class="string">"区域编号"</span>);</span><br><span class="line">            row.createCell(2).setCellValue(<span class="string">"关键字"</span>);</span><br><span class="line">            row.createCell(3).setCellValue(<span class="string">"起始号"</span>);</span><br><span class="line">            row.createCell(4).setCellValue(<span class="string">"结束号"</span>);</span><br><span class="line">            row.createCell(5).setCellValue(<span class="string">"位置信息"</span>);</span><br><span class="line">            //循环放入行中</span><br><span class="line">            <span class="keyword">if</span> (subs != null &amp;&amp; subs.size() != 0) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Subarea s : subs) &#123;</span><br><span class="line">                    int lastRowNum = sheet.getLastRowNum();//当前sheet  最后一行的 角标 0</span><br><span class="line">                    //没循环一次创建一行</span><br><span class="line">                    HSSFRow row1 = sheet.createRow(lastRowNum + 1);</span><br><span class="line">                    //在索引0的位置创建单元格(左上端)</span><br><span class="line">                    //标题 分区编号 区域编号 关键字 起始号 结束号 位置信息</span><br><span class="line">                    row1.createCell(0).setCellValue(s.getId());</span><br><span class="line">                    row1.createCell(1).setCellValue(s.getRegion().getId());</span><br><span class="line">                    row1.createCell(2).setCellValue(s.getAddresskey());</span><br><span class="line">                    row1.createCell(3).setCellValue(s.getStartnum());</span><br><span class="line">                    row1.createCell(4).setCellValue(s.getEndnum());</span><br><span class="line">                    row1.createCell(5).setCellValue(s.getPosition());</span><br><span class="line">                &#125;</span><br><span class="line">                //工作簿完成</span><br><span class="line">                //下载  两个头 一个流</span><br><span class="line">                //文件名</span><br><span class="line">                String filename = new Date(System.currentTimeMillis()).toLocaleString() + <span class="string">"张思思.xls"</span>;</span><br><span class="line">                //父类没有response，所以需要将response添加到父类</span><br><span class="line">                HttpServletResponse response = getResponse();</span><br><span class="line">                //ServletContext.getMimeType 根据文件的扩展名  获取对应Mime 类型</span><br><span class="line">                response.setContentType(getServletContext().getMimeType(filename));</span><br><span class="line">                //2、附件头  通过浏览器拿请求类型</span><br><span class="line">                response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + MyFileUtils.encodeDownloadFilename(filename, getRequest().getHeader(<span class="string">"user-agent"</span>)));</span><br><span class="line">                //3、输出流</span><br><span class="line">                try &#123;</span><br><span class="line">                    workbook.write(response.getOutputStream());</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            push(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //4：下载不需要跳转，就是当前页面</span><br><span class="line">        <span class="built_in">return</span> NONE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/Eclipse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/Eclipse/" itemprop="url">Eclipse</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-06T18:23:46+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发工具/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Eclipse-ini文件"><a href="#Eclipse-ini文件" class="headerlink" title="Eclipse.ini文件"></a>Eclipse.ini文件</h3><p>该文档中提及的以下警告信息需要重点注意。</p>
<ul>
<li>-vmargs 之后的所有行都被作为参数传递给JVM；Eclipse的所有参数和选项必须在 -vmargs之前指定(正如在命令行上使用参数一样)。</li>
</ul>
<p>这就是为什么要在文件开始处插入 -vm 选项的原因。</p>
<ul>
<li>在命令行中使用 -vmargs将覆盖所有在 .ini文件中的 -vmargs设置，除非在.ini文件中或命令行中指定了 –auncher.appendVmargs。</li>
</ul>
<p><strong>设置 -vm选项</strong></p>
<p>设置 -vm 选项用于确定Eclipse使用那个JVM实现。你可能会注意到我们已经选定了JVM作为一个库(<em>.dll /</em>.so)，这在启动时能提供更好的性能，还支持程序作为Eclipse可执行文件运行而并不是作为Java可执行文件。</p>
<p>如果没有设置-vm 选项时，Eclipse 使用那个JVM，请注意Eclipse不查询JAVA_HOME 环境变量(Eclipse wiki)。相反，Eclipse执行解析path环境变量的Java命令。</p>
<p><strong>自定义JVM参数</strong></p>
<p>推荐的JVM参数列表来自于Piotr Gabryanczyk 在Java内存管理模型方面的研究成果。最初用于JetBRAINS Intellij设置，这种配置对Eclipse环境也有用的。在一下场合中有帮助；</p>
<ul>
<li>防止垃圾回收器中断程序的运行超过10ms(-XX:MaxGCPauseMillis=10)</li>
<li>降低垃圾回收器启动的级别到30%的所占用内存(-XX:MaxHeapFreeRatio=70)</li>
<li>强制垃圾回收器作为一个并行线程运行，降低对应用程序的干扰(-XX:+UseConcMarkSweepGC)</li>
<li>为垃圾回收器选择增量模式，可以在GC工作中生成中断让应用程序明确地停止冻结(-XX:+CMSIncrementalPacing)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/Spring-MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/Spring-MVC/" itemprop="url">Spring MVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-05T10:03:30+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SpringMVC的注解"><a href="#SpringMVC的注解" class="headerlink" title="SpringMVC的注解"></a>SpringMVC的注解</h3><ol>
<li>@ModelAttribute</li>
</ol>
<p>大致有两种使用方式，一种是直接标记在方法上，一种是标记在方法的参数中，两种标记方法产生的效果也各不相同。</p>
<ul>
<li>注解放在方法上面</li>
</ul>
<p>当同一个controller中有任意一个方法被@ModelAttribute注解标记，页面请求只要进入这个控制器，不管请求那个方法，均会先执行被@ModelAttribute标记的方法，所以我们可以用@ModelAttribute注解的方法做一些初始化操作。当同一个controller中有多个方法被@ModelAttribute注解标记，所有被@ModelAttribute标记的方法均会被执行，按先后顺序执行，然后再进入请求的方法。</p>
<p>​    </p>
<p>下面方法做一些变形，变形为带有参数的返回，这样也是实际开发中经常会操作的 </p>
<p>首先创建一个pojo对象，对象包含name，sex两个属性。并对JSP及控制器代码做一些修改</p>
<p>页面首先使用EL表达式接收返回参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span> + request.getServerName() + <span class="string">":"</span> + request.getServerPort() + path + <span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>, function () &#123;</span><br><span class="line"></span><br><span class="line">                window.location.href = <span class="string">"&lt;%=basePath%&gt;model/modelTest.do"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.name &#125;"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>@ModelAtterbute方法无返回值情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="keyword">null</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问ModelTest.jsp页面并点击测试</p>
<p> <img src="https://img-blog.csdn.net/20170225235700722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从执行结果看出，当访问请求时，会首先访问init方法，然后再对modelTest方法进行访问，并且是同一个请求，因为model模型数据的作用域与request相同，所以可以用此标记直接标记在方法上对实际要访问的方法进行一些初始化操作</p>
<ul>
<li>@ModelAttribute标记方法有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">init</span><span class="params">(Model mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入init方法"</span>);</span><br><span class="line">        PojoTest pojo=<span class="keyword">new</span> PojoTest(<span class="string">"小明"</span>, <span class="string">"男"</span>);</span><br><span class="line">        mode.addAttribute(<span class="string">"pojo"</span>, pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"model/befor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"befor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">befor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"进入befor方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里稍微做了点变形，可以看到在被@ModelAttribute方法中设值了返回路径为befor方法，但是在在代码运行的过程中并不会跳转befor方法，而是在代码执行完成return之前直接跳转了实际请求的方法。不执行return</p>
<p> 进入init方法<br>进入modelTest方法</p>
<ul>
<li><p>当@RequestMapping标记和@ModelAttribute同时标记在一个方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试页面发现进入控制器后返回，页面报404，这是因为当两个注解标记到同一个方法上时，逻辑视图名并不是返回值，而是返回请求的路径，根据model/modelTest.do生成逻辑视图。在这里我们修改下代码，把controller上的@RequestMapping标记去掉，并修改下页面的请求路径，让生成的视图路径和访问的页面路径相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value=<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入modelTest方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(function()&#123;</span><br><span class="line">           $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">  </span><br><span class="line">               window.location.href=<span class="string">"&lt;%=basePath%&gt;modelTest.do"</span>;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo &#125;"</span>&gt;</span><br><span class="line">  </span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>点击测试页面，会发现当两个注解同时注解到一个方法上时，方法的返回值会变成model模型的返回值，key是标记的名</p>
<h4 id="ModelAttribute标记在参数前"><a href="#ModelAttribute标记在参数前" class="headerlink" title="@ModelAttribute标记在参数前"></a>@ModelAttribute标记在参数前</h4><p>从from表单或url地址中取值，这里就以url地址为例，为了避免url地址中文乱码问题，这里调用了encodeURL函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            $(<span class="string">"#modelTest"</span>).on(<span class="string">"click"</span>,function()&#123;</span><br><span class="line"></span><br><span class="line">                window.location.href=<span class="string">"&lt;%=basePath%&gt;model/modelTest.do?userName="</span>+encodeURI(<span class="string">'小明'</span>)+<span class="string">"&amp;sex="</span>+encodeURI(<span class="string">'男'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"modelTest"</span> value=<span class="string">"测试"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.userName &#125;"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"$&#123;pojo.sex &#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pojo.setUserName(<span class="keyword">new</span> String(pojo.getUserName().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">            pojo.setSex(<span class="keyword">new</span> String(pojo.getSex().getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pojo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击页面测试，页面文本框会显示URL地址传递过来的参数，因为SpringMVC会自动匹匹配页面传递过来的参数的name属性和后台控制器中的方法中的参数名，如果参数名相同，会自动匹配，如果控制器中方法是封装的bean,会自动匹配bean中的属性，其实这种取值方式不需要用@ModelAttribute注解，只要满足匹配要求，也能拿得到值</p>
<p> <img src="https://img-blog.csdn.net/20170226011711946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从model对象中取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"model"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(<span class="string">"pojo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PojoTest <span class="title">init</span><span class="params">( PojoTest pojo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setSex(<span class="string">"男"</span>);</span><br><span class="line">        <span class="keyword">return</span> pojo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"modelTest.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">modelTest</span><span class="params">(@ModelAttribute(<span class="string">"pojo"</span>)</span> PojoTest pojo) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pojo.setUserName(<span class="string">"小明"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"modelTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击测试发现，modelTest拿到inint方法中的pojo对象，合并两次set的参数后返回页面</p>
</li>
</ul>
<p>   <img src="https://img-blog.csdn.net/20170226023308348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFycnlfWkhfV2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/FastDfs分布式文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/FastDfs分布式文件系统/" itemprop="url">FastDFS 分布式文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-31T10:40:45+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="FastDfs简介"><a href="#FastDfs简介" class="headerlink" title="FastDfs简介"></a>FastDfs简介</h3><ol>
<li>FastDfs是一个轻量级的开源分布式文件系统</li>
<li>FastDfs主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>
<li>FastDfs实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>
<li>支持存储服务器在线扩容</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>
<li><p>FastDFS特别适合大中型网站使用，用来存储资源文件(如：图片、文档、音频、视频等等)</p>
<p>  FastDFS是一个开源的轻量级分布式文件系统，她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。  </p>
</li>
</ol>
<p>FastDFS服务端有两个角色：<strong>跟踪器(tracker)</strong>和<strong>存储节点(storage)</strong>。跟踪器主要做调度工作，在访问上起负载均衡 的作用。</p>
<h4 id="Tracker"><a href="#Tracker" class="headerlink" title="Tracker"></a>Tracker</h4><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%BC%95%E5%85%A5Tracker.jpg?raw=true" alt=""></p>
<p>Group之间是相互独立的，Group内是相互备份的；Tracker之间也是相互独立的。</p>
<ul>
<li><p>Group之间 相互独立</p>
</li>
<li><p>同一Group内的Storage Server 之间需要互相备份</p>
<p>文件存放到一个Storage以后，需要备份到别的服务器</p>
</li>
<li><p>Tracker之间是不交互的</p>
<ul>
<li>每个storage server都需要向所有Tracker去主动报告信息</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ol>
<li>group内的server内容都是一致的</li>
<li>一个负责跟踪一个负责存储</li>
<li>group会向每个tracker都汇报，tracker存储的信息很少</li>
</ol>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg?raw=true" alt=""></p>
<h4 id="选定Tracker-Server"><a href="#选定Tracker-Server" class="headerlink" title="选定Tracker Server"></a>选定Tracker Server</h4><ul>
<li>Tracker Server不止一个，客户端选择哪一个做上传文件？</li>
</ul>
<p>Client是如何知道上传到那个Tracker Server</p>
<p>Client可以维护一个Tracker列表</p>
<ul>
<li>Tracker如何选择Group？(三种策略)<ul>
<li>round robin(轮询)</li>
<li>load balance(选择最大剩余空间的组上传文件)</li>
<li>specify group(指定group上传)</li>
</ul>
</li>
</ul>
<h4 id="选定Storage-Server"><a href="#选定Storage-Server" class="headerlink" title="选定Storage Server"></a>选定Storage Server</h4><ul>
<li>一个组内有多个Storage Server ，选择哪一个？<ul>
<li><ol>
<li>Round robin，所有server轮询使用(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>根据IP地址进行排序选择第一个服务器(IP地址最小者)</li>
</ol>
</li>
<li><ol start="3">
<li>根据优先级进行排序(上传优先级由storage server来设置，参数为upload_priority)</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%20%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg?raw=true" alt=""></p>
<h4 id="选择storage-path"><a href="#选择storage-path" class="headerlink" title="选择storage path"></a>选择storage path</h4><ul>
<li>如何选择storage path(虚拟磁盘目录M00，M01路径)<ul>
<li><ol>
<li>round robin ，轮询(默认)</li>
</ol>
</li>
<li><ol start="2">
<li>load balance，选择使用剩余空间最大的存储路径</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>目录和文件</p>
<ul>
<li>选定存放目录？<ul>
<li>storage会生成一个file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg)，采用Base64编码，file_id包含字段包括：storage server_ip(文件的源服务器)、文件创建时间、文件大小、文件CRC32校验码和随机数、；(这个时候文件名已经和最早的文件名是两回事儿了)</li>
<li>每个存储目录下有两个256*256个子目录，storage 会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为文件名存储到该子目录下</li>
</ul>
</li>
</ul>
<p>Group1/M00/00/OC/wKjGgVgbV2-ABdo-AAAAHw.jpg   </p>
<p>tracker可以通过上面的东西迅速的找到文件</p>
<p><strong>要点：</strong></p>
<ul>
<li>server之间不分主从，每个目录可以不止放一个文件</li>
<li>存储服务器启动的时候就会把两个256*256个目录一次创建出来</li>
<li>file_id必须由client来保存。</li>
</ul>
<p>怎么确定存放在那个目录</p>
<p>storage会按照文件的file_id(wKjGgVgbV2-ABdo-AAAAHw.jpg   )做两次hash算法，路由到其中一个子目录中。</p>
<h4 id="Storage-Server之间的文件同步"><a href="#Storage-Server之间的文件同步" class="headerlink" title="Storage Server之间的文件同步"></a>Storage Server之间的文件同步</h4><ul>
<li>同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；</li>
<li>文件同步只在组内的storage server之间进行，采用push方式，即源服务器同步给目标服务器；</li>
<li>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</li>
<li>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一套storage server将已有的所有数据(包括源头数据和备份数据)同步给新增服务器</li>
</ul>
<p>client是FastDFS提供的客户端</p>
<p>FastDFS有覆盖方法，可以修改某个已经上传的文件，甚至是追加操作。</p>
<p>例子：</p>
<p>A，B，C三个服务器在同一个组中</p>
<ul>
<li>9:30用户向服务器A上传了一个文件X(文件创建时间9:30)</li>
<li>9:31用户向服务器B上传了一个文件Y(文件创建时间9:31)</li>
<li>9:32用户向服务器A上传了一个文件Z(文件创建时间9:32)</li>
</ul>
<p>A向B，C同步文件X，并且向Tracker Server汇报</p>
<ul>
<li>我向B同步了X(文件创建时间9:30)</li>
<li>我向C同步了X(文件创建时间9:30)</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A52.jpg?raw=true" alt=""></p>
<p>通过文件名都可以取到创建时间和源服务器地址</p>
<p>这个时候下载文件Y，tracker会去那个服务器上面寻找呢?</p>
<p>这个时候可以直接从B中下载，如果这个时候B宕机了，只有和A或C中找，查tracker中的表时，B–&gt;A在9：31前的都同步了，就去A中找。如果A也宕机了，就去C中找，看这个时间前的是否同步。</p>
<p>tracker不需要保存左侧的信息，根据文件名就可以了。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A53.jpg?raw=true" alt=""></p>
<p>这个时候假设用户想下载文件Z，就去源服务器下载，如果源服务器宕机，就去其他服务器下载。根据时间判断是否在这个时间前的同步了，如果同步了就下载，如果没有就下载。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/storage%20Server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A54.jpg?raw=true" alt=""></p>
<p>当试图下载文件的时候，根据文件名拿到创建时间和服务器，根据时间来判断是否可以下载。</p>
<p>FastDFS文件同步方式</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F.jpg?raw=true" alt=""></p>
<p>最后最早同步时间，</p>
<p>对于服务器A来讲，服务器B向他同步的时间是9:31,服务器C是9:33.计算最后的时间，那么根据上图。</p>
<p>对服务器A，它的最早同步时间是9:31</p>
<p>对服务器B，它的最早同步时间是9:32</p>
<p><strong>取最小值，然后直接和最小值进行比对。</strong></p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%9C%80%E5%90%8E%E6%9C%80%E6%97%A9%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4.jpg?raw=true" alt=""></p>
<p>X可以从三个服务器下载</p>
<p>Y可以从A和B服务器下载，C不行。</p>
<p>Z可以从源服务器A下载，或者服务器B下载,C不行</p>
<p>W只能从服务器C这个源服务器下载，虽然根据时间判断C已经将9:33前的同步到了A和B这两个服务器，但是根据规则，它不能去A和B下载。</p>
<p>虽然简单，但是会牺牲一下。</p>
<p>选择一个可供下载的Storage Server策略</p>
<ul>
<li>该文件上传到源Storage server(文件直接上传到该服务器上的)</li>
<li>文件创建时间戳&lt;Storage server被同步到的文件时间戳，这意味着当前文件已经被同步过来了；</li>
<li>文件创建时间戳=Storage server被同步到的文件时间戳，且(当前时间-文件创建时间戳)&gt;一个文件同步完成需要的最大时间(如5分钟);</li>
<li>(当前时间-文件创建时间戳)&gt;文件同步延迟阈值，比如我们把阈值设置为1天，表示文件同步在一天内肯定可以完成</li>
</ul>
<p>当走到第四个的时候可能已经出问题了。</p>
<p>tracker定位一个组中的server</p>
<h3 id="FastDFS的使用"><a href="#FastDFS的使用" class="headerlink" title="FastDFS的使用"></a>FastDFS的使用</h3><p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8.jpg?raw=true" alt=""></p>
<p>这里的FastDFSAPI可以当做client</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/FastDFS%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8Cnagix%E9%9B%86%E6%88%90.jpg?raw=true" alt=""></p>
<p>上图这种就是</p>
<p>如果上传的话还是走Nginx，到应用服务器</p>
<p>如果下载的时候，直接通过Nginx，直接到FastDFS，模块和Nginx集成。绕过应用服务器</p>
<p>要点：</p>
<ul>
<li>Tracker server内部没有数据库，要么是内存要么是纯文件，文件格式自己定义</li>
</ul>
<h3 id="防止盗链"><a href="#防止盗链" class="headerlink" title="防止盗链"></a>防止盗链</h3><ul>
<li>辛苦上传的文件不想被人盗取</li>
<li>给URL增加token<ul>
<li>Token只有自己的网站才能生成</li>
<li>Token会过期</li>
</ul>
</li>
</ul>
<p>refer</p>
<h4 id="防止盗链的配置"><a href="#防止盗链的配置" class="headerlink" title="防止盗链的配置"></a>防止盗链的配置</h4><p>是否做token检查，缺省为false</p>
<p>http.anti_steal.check_token=true</p>
<p>即生成token的有效时长 秒</p>
<p>http.anti_steal.token_ttl=900</p>
<p>生成token的密钥，尽量设置得长一些</p>
<p>http.anti_steal.secret<em>key=@#%*&amp;$)87)</em>+$%!~</p>
<p>Token = md5(文件名，密钥，时间戳)</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E9%98%B2%E6%AD%A2%E7%9B%97%E9%93%BE%E7%9A%84%E9%85%8D%E7%BD%AE.jpg?raw=true" alt=""></p>
<p>将文件名、密钥和时间戳的组合通过md5加密传给token</p>
<p>token是在服务器端生成</p>
<p>客户端下载文件的时候，除了传fileid以外还需要token</p>
<p>客户端发送的是fileid，服务器端返回的是一个token</p>
<h4 id="合并存储"><a href="#合并存储" class="headerlink" title="合并存储"></a>合并存储</h4><ul>
<li>海量小文件的缺点<ul>
<li>元数据管理低效，磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上</li>
<li>数据存储分散</li>
<li>磁盘的大量随机访问降低效率</li>
</ul>
</li>
<li>FastDFS提供的合并存储功能<ul>
<li>默认大文件64M</li>
<li>每个文件空间称为slot(256bytes&lt;=slot&lt;=16MB)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E6%B2%A1%E6%9C%89%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6ID.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/FastDFS/%E5%90%88%E5%B9%B6%E6%97%B6%E7%9A%84%E6%96%87%E4%BB%B6.jpg?raw=true" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>FastDFS是穷人的解决方案</li>
<li>FastDFS把简洁和高效做到了极致，非常节约资源，中小网站完全用的起</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-集成Hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-集成Hibernate3/" itemprop="url">Spring--集成Hibernate3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-28T17:26:07+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E9%95%BF%E9%A2%88%E9%B9%BF.jpg?raw=true" alt=""></p>
<h3 id="集成Hibernate3"><a href="#集成Hibernate3" class="headerlink" title="集成Hibernate3"></a>集成Hibernate3</h3><p>​       Hibernate是全自动的ORM框架，能自动为对象生成相应SQL并透明的持久化对象到数据库。</p>
<p> <strong>Spring2.5+版本支持Hibernate 3.1+版本，不支持低版本，Spring3.0.5版本提供对Hibernate 3.6.0 Final版本支持。</strong></p>
<h4 id="如何集成"><a href="#如何集成" class="headerlink" title="如何集成"></a>如何集成</h4><p>Spring通过使用如下Bean进行集成Hibernate：</p>
<ul>
<li>LocalSessionFactoryBean ：用于支持XML映射定义读取：</li>
<li>configLocation和configLocations：用于定义Hibernate配置文件位置，一般使用classpath:hibernate.cfg.xml形式指定；</li>
<li>mappingLocations：用于指定Hibernate映射文件位置，如chapter8/hbm/user.hbm.xml;</li>
<li>hibernateProperties：用于定义Hibernate属性，即Hibernate配置文件中的属性；</li>
<li>dataSource：定义数据源；</li>
<li>hibernateProperties、dataSource用于消除Hibernate配置文件，因此如果使用configLocations指定配置文件，就不要设置这两个属性了，否则会产生重复配置。推荐使用dataSource来指定数据源，而使用hibernateProperties指定Hibernate属性。</li>
<li>AnnotationSessionFactoryBean：用于支持注解风格映射定义读取，该类继承LocalSessionFactoryBean并额外提供自动查找注解风格配置模型的能力；</li>
<li>AnnotatedClasses：设置注解了模型类，通过注解指定映射元数据。</li>
<li>packagesToScan：通过扫码指定的包获取注解模型类，而不是手工指定，如”com.zero.**.model”将扫码com.zero包及子包下的model包下所有注解模型类。</li>
</ul>
<p>接下来学习一下Spring如何继承Hibernate吧；</p>
<p><strong>1、准备jar包：</strong></p>
<p>首先准备Spring对ORM框架支持的jar包：</p>
<p>org.springframework.orm-3.0.5.RELEASE.jar      //提供对ORM框架集成</p>
<p>下载hibernate-distribution-3.6.0.Final包，获取如下Hibernate需要的jar包：</p>
<p>hibernate3.jar        //核心包</p>
<p>lib\required\antlr-2.7.6.jar        //HQL解析时使用的包</p>
<p>lib\required\javassist-3.9.0.GA.jar        //字节码类库，类似与cglib</p>
<p>lib\required\commons-collections-3.1.jar  //对集合类型支持包，前边测试时已经提供过了，无需再拷贝该包了</p>
<p>lib\required\dom4j-1.6.1.jar            //xml解析包，用于解析配置使用</p>
<p>lib\required\jta-1.1.jar                 //JTA事务支持包</p>
<p>lib\jpa\hibernate-jpa-2.0-api-1.0.0.Final.jar //用于支持JPA</p>
<p> 下载slf4j-1.6.1.zip（<a href="http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple" target="_blank" rel="noopener">http://www.slf4j.org/download.html），slf4j是日志系统门面（Simple</a> Logging Facade for Java），用于对各种日志框架提供给一致的日志访问接口，从而能随时替换日志框架（如log4j、java.util.logging）：</p>
<p>将这些jar包添加到类路径中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/Spring-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/Spring-JDBC/" itemprop="url">Spring-JDBC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-28T15:02:23+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E8%A9%B9%E5%A7%86%E6%96%AF.jpg?raw=true" alt=""></p>
<p>抄自开涛博客   <a href="http://jinnianshilongnian.iteye.com/blog/1423896" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1423896</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h4><p>​       传统应用程序开发中，进行JDBC编程是相当痛苦的，如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cn.javass.spring.chapter7. TraditionalJdbcTest  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">    PreparedStatement pstmt = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      conn = getConnection();              <span class="comment">//1.获取JDBC连接  </span></span><br><span class="line">                                       <span class="comment">//2.声明SQL  </span></span><br><span class="line">      String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;  </span><br><span class="line">      pstmt = conn.prepareStatement(sql);    <span class="comment">//3.预编译SQL  </span></span><br><span class="line">      ResultSet rs = pstmt.executeQuery();   <span class="comment">//4.执行SQL  </span></span><br><span class="line">      process(rs);                       <span class="comment">//5.处理结果集  </span></span><br><span class="line">      closeResultSet(rs);                 <span class="comment">//5.释放结果集  </span></span><br><span class="line">      closeStatement(pstmt);              <span class="comment">//6.释放Statement  </span></span><br><span class="line">      conn.commit();                    <span class="comment">//8.提交事务  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">      <span class="comment">//9.处理异常并回滚事务  </span></span><br><span class="line">      conn.rollback();  </span><br><span class="line">      <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">      <span class="comment">//10.释放JDBC连接，防止JDBC连接不关闭造成的内存泄漏  </span></span><br><span class="line">      closeConnection(conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       以上代码片段具有冗长、重复、容易忘记某一步骤从而导致出错、显示控制事务、显示处理受检查异常等等。</p>
<p>​        有朋友可能重构出自己的一套JDBC模板，从而能简化日常开发，但自己开发的JDBC模板不够通用，而且对于每一套JDBC模板实现都差不多，从而导致开发人员必须掌握每一套模板。</p>
<p>​        Spring JDBC提供了一套JDBC抽象框架，用于简化JDBC开发，而且如果各个公司都使用该抽象框架，开发人员首先减少了学习成本，直接上手开发，如图7-1所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JDBC.JPG?raw=true" alt=""></p>
<p>图7-1 Spring JDBC与传统JDBC编程对比</p>
<h4 id="Spring对JDBC的支持"><a href="#Spring对JDBC的支持" class="headerlink" title="Spring对JDBC的支持"></a>Spring对JDBC的支持</h4><p>​       Spring通过抽象JDBC访问并提供一致的API来简化JDBC编程的工作量。我们只需要<strong>声明SQL、调用合适的Spring JDBC框架API、处理结果集</strong>即可。事务由Spring管理，并将JDBC受查异常转换为Spring一致的非受查异常，从而简化开发。</p>
<p>​        Spring主要提供<strong>JDBC模板方式、关系数据库对象化方式和SimpleJdbc</strong>方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p>
<ul>
<li><strong>JDBC模板方式：</strong>Spring JDBC 框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如Jdbc Template、NamedParameterJdbcTemplate、SimpleJdbcTemplate。 </li>
<li><strong>关系数据库对象化方式：</strong>Spring JDBC 框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoreProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li>
<li><strong>SimpleJdbc 方式</strong>：Spring JDBC框架还提供了<strong>SimpleJdbc 方式</strong>来简化JDBC编程，SimpleJdbcInsert、SimpleJdbcCall用来简化数据库表插入、存储过程或函数访问；</li>
</ul>
<p>Spring JDBC还提供了一些强大的工具类，如DataSourceUtils来在必要的时候手工获取数据库连接等。</p>
<h4 id="Spring的JDBC架构"><a href="#Spring的JDBC架构" class="headerlink" title="Spring的JDBC架构"></a>Spring的JDBC架构</h4><p>Spring JDBC抽象框架由四部分组成：datasource、support、core、object。如图7-2所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20JDBC%20%E6%9E%B6%E6%9E%84%E5%9B%BE.JPG?raw=true" alt=""></p>
<p>图7-2 Spring JDBC架构图</p>
<pre><code>**support包：**提供将JDBC异常转化为DAO非检查异常转换类、一些工具类如JdbcUtils等。
</code></pre><p>​    <strong>dataSource包：</strong>提供简化访问JDBC数据源(javax.sql.DataSource实现)工具类，并提供了一些    DataSource简单实现类从而能使从这些DataSource获取的连接能自动得到Spring管理事务支持。</p>
<p>​    <strong>coe包：</strong>提供JDBC模板类实现及可变部分的回调接口，还提供SimpleJdbcInsert等辅助类。</p>
<p>​    <strong>object包：</strong>提供关系数据库的对象表示形式，如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类，该包是基于core包JDBC模板类实现。</p>
<h3 id="JDBC模板类"><a href="#JDBC模板类" class="headerlink" title="JDBC模板类"></a>JDBC模板类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​       Spring JDBC抽象框架core包提供了JDBC模板类，其中JdbcTemplate是core包的核心类，所以其他模板类都是基于它封装完成的，JDBC模板类是第一种工作模式。</p>
<p>​        JdbcTemplate类通过模板设计模式帮助我们消除了冗长的代码，只做需要做的事情（即可变部分），并且帮我们做哪些固定部分，如连接的创建及关闭。</p>
<p>​        JdbcTemplate类对可变部分采用回调接口方式实现，如ConnectionCallback通过回调接口返回给用户一个连接，从而可以使用该连接做任何事情、StatementCallback通过回调接口返回给用户一个Statement，从而可以使用该Statement做任何事情等等，还有其他一些回调接口如图7-3所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/JdbcTemplate%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3.JPG?raw=true" alt=""></p>
<p>图7-3 JdbcTemplate支持的回调接口</p>
<p> Spring除了提供JdbcTemplate核心类，还提供了基于JdbcTemplate实现的NamedParameterJdbcTemplate类用于支持命名参数绑定、 SimpleJdbcTemplate类用于支持Java5+的可变参数及自动装箱拆箱等特性。</p>
<h4 id="传统JDBC编程替代方案"><a href="#传统JDBC编程替代方案" class="headerlink" title="传统JDBC编程替代方案"></a>传统JDBC编程替代方案</h4><p>前边我们已经使用过传统JDBC编程方式，接下来让我们看下Spring JDBC框架提供的更好的解决方案。</p>
<p> 1）准备需要的jar包并添加到类路径中：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.springframework.jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）传统JDBC编程替代方案：</p>
<p> 在使用JdbcTemplate模板类时必须通过DataSource获取数据库连接，Spring JDBC提供了DriverManagerDataSource实现，它通过包装“DriverManager.getConnection”获取数据库连接，具体DataSource相关请参考【7.5.1控制数据库连接】。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url=<span class="string">"jdbc:hsqldb:mem:test"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"123"</span>;</span><br><span class="line">        DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource(url,username,password);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"org.hsqldb.jdbcDriver"</span>);</span><br><span class="line">        jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、声明SQL</span></span><br><span class="line">        String sql=<span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//2.处理结果集</span></span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们具体分析一下：</p>
<p>1）  <strong>jdbc:hsqldb:mem:test：</strong>表示使用hsqldb内存数据库，数据库名为“test”。</p>
<p>2）  <strong>public static void setUpClass()：</strong>使用junit的@BeforeClass注解，表示在所以测试方法之前执行，且只执行一次。在此方法中定义了DataSource并使用DataSource对象创建了JdbcTemplate对象。JdbcTemplate对象是线程安全的。</p>
<p>3）  <strong>JdbcTemplate执行流程：</strong>首先定义SQL，其次调用JdbcTemplate方法执行SQL，最后通过RowCallbackHandler回调处理ResultSet结果集。</p>
<p>Spring JDBC解决方法相比传统JDBC编程方式是不是简单多了，是不是只有可变部分需要我们来做，其他的都由Spring JDBC框架来实现了。</p>
<p>接下来让我们深入JdbcTemplate及其扩展吧。</p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>​       首先让我们来看下如何使用JdbcTemplate来实现增删改查。</p>
<p> 一、首先创建表结构：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String createTableSql = <span class="string">"create memory table test"</span> + <span class="string">"(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "</span> + <span class="string">"name varchar(100))"</span>;</span><br><span class="line">    jdbcTemplate.update(createTableSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String dropTableSql = <span class="string">"drop table test"</span>;</span><br><span class="line">    jdbcTemplate.execute(dropTableSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  org.junit包下的<strong>@Before和@After</strong>分别表示在测试方法之前和之后执行的方法，对于每个测试方法都将执行一次； </p>
<p>2）  <strong>create memory table test</strong>表示创建hsqldb内存表，包含两个字段id和name，其中id是具有自增功能的主键，如果有朋友对此不熟悉hsqldb可以换成熟悉的数据库。 </p>
<p>二、定义测试骨架，该测试方法将用于实现增删改查测试：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring-AOP/" itemprop="url">Spring--AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-24T16:21:43+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/4.jpg?raw=true" alt=""></p>
<h2 id="AOP基础"><a href="#AOP基础" class="headerlink" title="AOP基础"></a>AOP基础</h2><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>​       在进行AOP开发前，先熟悉几个概念：</p>
<ul>
<li><strong>连接点（Jointpoint）：</strong>表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，<strong>在AOP中表示为“在哪里干”</strong>；</li>
<li><strong>切入点（Pointcut）：</strong>选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，<strong>在AOP中表示为“在哪里干的集合”</strong>；</li>
<li><strong>通知（Advice）：</strong>在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；<strong>在AOP中表示为“干什么”；</strong></li>
<li><strong>方面/切面（Aspect）：</strong>横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；<strong>在AOP中表示为“在哪干和干什么集合”；</strong></li>
<li><strong>引入（inter-type declaration）：</strong>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, <strong>在AOP中表示为“干什么（引入什么）”</strong>；</li>
<li><strong>目标对象（Target Object）：</strong>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，<strong>在AOP中表示为“对谁干”</strong>；</li>
<li><strong>AOP代理（AOP Proxy）：</strong>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是<strong>通过代理来对目标对象应用切面</strong>。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li>
<li><p><strong>织入（Weaving）：</strong>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</p>
<p>在AOP中，通过切入点选择目标对象的连接点，然后在目标对象的相应连接点处织入通知，而切入点和通知就是切面（横切关注点），而在目标对象连接点处应用切面的实现方式是通过AOP代理对象，如图6-2所示。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/AOP%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.JPG?raw=true" alt=""></p>
</li>
</ul>
<p>图6-2 概念关系</p>
<p> 接下来再让我们具体看看Spring有哪些通知类型：</p>
<ul>
<li><strong>前置通知（Before Advice）:</strong>在切入点选择的连接点处的方法之前执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。</li>
<li><strong>后置通知（After Advice）:</strong>在切入点选择的连接点处的方法之后执行的通知，包括如下类型的后置通知：</li>
<li><strong>后置返回通知(After returning Advice)：</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置异常通知(After throwing Advice):</strong>在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。</li>
<li><strong>后置最终通知(After finally Advice):</strong>在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java的finally块。</li>
<li><strong>环绕通知(Around Advice):</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等等。</li>
</ul>
<p>各种通知类型在UML序列图中的位置如图6-3所示:<br>   <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B.JPG?raw=true" alt=""></p>
<p>图6-3 通知类型</p>
<h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>​       AOP代理就是AOP框架通过代理模式创建的对象，Spring使用JDK动态代理或CGLIB代理来实现，Spring缺省使用JDK动态代理来实现，从而任何接口都可别代理，如果被代理的对象实现不是接口将默认使用CGLIB代理，不过CGLIB代理当然也可应用到接口。</p>
<p>​        <strong>AOP代理的目的就是将切面织入到目标对象。</strong></p>
<p>​        概念都将完了，接下来让我们看一下AOP的 HelloWorld!吧。</p>
<h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>​       首先准备开发需要的jar包，请到spring-framework-3.0.5.RELEASE-dependencies.zip和spring-framework-3.0.5.RELEASE-with-docs中查找如下jar包：</p>
<p>  org.springframework.aop-3.0.5.RELEASE.jar</p>
<p>  com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</p>
<p>  com.springsource.org.aopalliance-1.0.0.jar</p>
<p>   com.springsource.net.sf.cglib-2.2.0.jar </p>
<h4 id="定义目标类"><a href="#定义目标类" class="headerlink" title="定义目标类"></a>定义目标类</h4><p>​       1）定义目标接口：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）定义目标接口实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注：在日常开发中最后将业务逻辑定义在一个专门的service包下，而实现定义在service包下的impl包中，服务接口以IXXXService形式，而服务实现就是XXXService，这就是规约设计，见名知义。当然可以使用公司内部更好的形式，只要大家都好理解就可以了。</p>
<h4 id="定义切面支持类"><a href="#定义切面支持类" class="headerlink" title="定义切面支持类"></a>定义切面支持类</h4><p>​       有了目标类，该定义切面了，切面就是通知和切入点的组合，而切面是通过配置方式定义的，因此这定义切面前，我们需要定义切面支持类，切面支持类提供了通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========after finally advice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       此处HelloWorldAspect类不是真正的切面实现，只是定义了通知实现的类，在此我们可以把它看作就是缺少了切入点的切面。</p>
<p>​        注：对于AOP相关类最后专门放到一个包下，如“aop”包，因为AOP是动态织入的，所以如果某个目标类被AOP拦截了并应用了通知，可能很难发现这个通知实现在哪个包里，因此推荐使用规约命名，方便以后维护人员查找相应的AOP实现。</p>
<h4 id="在XML中进行配置"><a href="#在XML中进行配置" class="headerlink" title="在XML中进行配置"></a>在XML中进行配置</h4><p>有了通知实现，那就让我们来配置切面吧：</p>
<p>​       1）首先配置AOP需要aop命名空间，配置头如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       2）配置目标类：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       3）配置切面：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"helloWorldService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldService"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"aspect"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zero.aop.HelloWorldAspect"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* com.zero.aop.*.*(..))"</span>/&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">"aspect"</span>&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"beforeAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">        &lt;aop:after pointcut=<span class="string">"execution(* com.zero.aop.*.*(..))"</span> method=<span class="string">"afterFinallyAdvice"</span>/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>​       切入点使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>配置，expression属性用于定义切入点模式，默认是AspectJ语法，“execution(<em> cn.javass..</em>.*(..))”表示匹配cn.javass包及子包下的任何方法执行。</p>
<p> 切面使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签配置，其中“ref”用来引用切面支持类的方法。</p>
<p> 前置通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签来定义，pointcut-ref属性用于引用切入点Bean，而method用来引用切面通知实现类中的方法，该方法就是通知实现，即在目标类方法执行之前调用的方法。</p>
<p> 最终通知使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签来定义，切入点除了使用pointcut-ref属性来引用已经存在的切入点，也可以使用pointcut属性来定义，如pointcut=”execution(<em> cn.javass..</em>.*(..))”，method属性同样是指定通知实现，即在目标类方法执行之后调用的方法。</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>测试类非常简单，调用被代理Bean跟调用普通Bean完全一样，Spring AOP将为目标对象创建AOP代理，具体测试代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop.xml"</span>);</span><br><span class="line">        IHelloWorldService helloworldService =</span><br><span class="line">                ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);</span><br><span class="line">        helloworldService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       该测试将输出如下如下内容：</p>
<p> ===========before advice<br>============Hello World!<br>===========after finally advice</p>
<p>​        从输出我们可以看出：前置通知在切入点选择的连接点（方法）之前允许，而后置通知将在连接点（方法）之后执行，具体生成AOP代理及执行过程如图6-4所示。</p>
<p> <img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/Spring%20AOP%E6%A1%86%E6%9E%B6%E7%94%9F%E6%88%90AOP%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.JPG?raw=true" alt=""></p>
<p> 图6-4 Spring AOP框架生成AOP代理过程</p>
<h3 id="基于Schema的AOP"><a href="#基于Schema的AOP" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h3><h4 id="基于Schema的AOP-1"><a href="#基于Schema的AOP-1" class="headerlink" title="基于Schema的AOP"></a>基于Schema的AOP</h4><p>​     基于Schema的AOP从Spring2.0之后通过“aop”命名空间来定义切面、切入点及声明通知。</p>
<p> 在Spring配置文件中，所有AOP相关定义必须放在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，该标签下可以有<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>、<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>、<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签，配置顺序不可变。 </p>
<ul>
<li><a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>：用来定义切入点，该切入点可以重用；</li>
<li><a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>：用来定义只有一个通知和一个切入点的切面；</li>
<li><p><a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，advisor只包含一个通知和一个切入点。</p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Spring/aop-schema.JPG?raw=true" alt=""></p>
</li>
</ul>
<h4 id="声明切面"><a href="#声明切面" class="headerlink" title="声明切面"></a>声明切面</h4><p>​    切面就是包含切入点和通知的对象，在Spring容器中将被定义为一个Bean，Schema方式的切面需要一个切面支持Bean，该支持Bean的字段和方法提供了切面的状态和行为信息，并通过配置方式来指定切入点和通知实现。</p>
<p>​      切面使用<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签指定，ref属性用来引用切面支持Bean。</p>
<p>​     切面支持Bean“aspectSupportBean”跟普通Bean完全一样使用，切面使用“ref”属性引用它。</p>
<h4 id="声明切入点"><a href="#声明切入点" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​    切入点在Spring中也是一个Bean，Bean定义方式可以有很三种方式：</p>
<p>​     <strong>1）在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下使用<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>声明一个切入点Bean</strong>，该切入点可以被多个切面使用，对于需要共享使用的切入点最好使用该方式，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>**2）在&lt;aop:aspect&gt;*标签下使用&lt;aop:pointcut&gt;声明一个切入点Bean**，该切入点可以被多个切面使用，但一般该切入点只被该切面使用，当然也可以被其他切面使用，但最好不要那样使用，该切入点使用id属性指定Bean名字，在通知定义时使用pointcut-ref属性通过该id引用切入点，expression属性指定切入点表达式： 
</code></pre> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">" pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>3）匿名切入点Bean，</strong>可以在声明通知时通过pointcut属性指定切入点表达式，该切入点是匿名切入点，只被该通知使用：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspectSupportBean"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="声明通知"><a href="#声明通知" class="headerlink" title="声明通知"></a>声明通知</h4><p> 基于Schema方式支持前边介绍的5中通知类型：</p>
<p> <strong>一、前置通知：</strong>在切入点选择的方法之前执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:before" target="_blank" rel="noopener">aop:before</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">"前置通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">arg-names</span>=<span class="string">"前置通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>二者选一，指定切入点；</p>
<p>​         <strong>method：</strong>指定前置通知实现方法名，如果是多态需要加上参数类型，多个用“，”隔开，如beforeAdvice(java.lang.String)；</p>
<p>​         <strong>arg-names：</strong>指定通知实现方法的参数名字，多个用“，”分隔，可选，类似于【3.1.2 构造器注入】中的参数名注入限制：<strong>在class文件中没生成变量调试信息是获取不到方法参数名字的，因此只有在类没生成变量调试信息时才需要使用arg-names属性来指定参数名，如</strong>arg-names=”param”表示通知实现方法的参数列表的第一个参数名字为“param”。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayBefore(..)) and args(param)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">method</span>=<span class="string">"beforeAdvice(java.lang.String)"</span>   </span></span><br><span class="line"><span class="tag">                           <span class="attr">arg-names</span>=<span class="string">"param"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaBeforeAdvice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">     ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">     IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">     helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>=====================================================before advice param:before============say before==========================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayBefore(..)) ”匹配目标方法sayBefore，且使用“args(param)”匹配目标方法只有一个参数且传入的参数类型为通知实现方法中同名的参数类型；</p>
<p><strong>2）目标方法定义：</strong>使用method=” beforeAdvice(java.lang.String) “指定前置通知实现方法，且该通知有一个参数类型为java.lang.String参数；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=” param “指定通知实现方法参数名为“param”，切入点中使用“args(param)”匹配的目标方法参数将自动传递给通知实现方法同名参数。</p>
<p>   <strong>二、后置返回通知：</strong>在切入点选择的方法正常返回时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-returning" target="_blank" rel="noopener">aop:after-returning</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">"后置返回通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">"后置返回通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">returning</span>=<span class="string">"返回值对应的后置返回通知实现方法参数名"</span>  </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>returning：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法执行正常返回后，将把目标方法返回值传给通知方法；returning限定了只有目标方法返回值匹配与通知方法相应参数类型时才能执行后置返回通知，否则不执行，对于returning对应的通知方法参数为Object类型将匹配任何目标返回值。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterReturning</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============after returning"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterReturningAdvice"</span>  </span></span><br><span class="line"><span class="tag">                               <span class="attr">arg-names</span>=<span class="string">"retVal"</span>    </span></span><br><span class="line"><span class="tag">                               <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterReturningAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterReturning();      </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================after returning===========after returning advice retVal:true======================================</td>
</tr>
</tbody>
</table>
<p>分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterReturning(..)) ”匹配目标方法sayAfterReturning，该方法返回true；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterReturningAdvice”指定后置返回通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”retVal”指定通知实现方法参数名为“retVal”；</p>
<p><strong>4）返回值命名：</strong>returning=”retVal”用于将目标返回值赋值给通知实现方法参数名为“retVal”的参数上。</p>
<p> <strong>三、后置异常通知：</strong>在切入点选择的方法抛出异常时执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的<a href="aop:after-throwing" target="_blank" rel="noopener">aop:after-throwing</a>标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"后置异常通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"后置异常通知实现方法参数列表参数名字"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"将抛出的异常赋值给的通知实现方法参数名"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>   <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p>​         <strong>throwing：</strong>定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；throwing限定了只有目标方法抛出的异常匹配与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，对于throwing对应的通知方法参数为Throwable类型将匹配任何异常。</p>
<p>首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAfterThrowing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============before throwing"</span>);  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">method</span>=<span class="string">"afterThrowingAdvice"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">arg-names</span>=<span class="string">"exception"</span>  </span></span><br><span class="line"><span class="tag">                                <span class="attr">throwing</span>=<span class="string">"exception"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException.class)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAfterThrowingAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAfterThrowing();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>==================================================before throwing===========after throwing advice exception:java.lang.RuntimeException======================================</td>
</tr>
</tbody>
</table>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterThrowing(..))”匹配目标方法sayAfterThrowing，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=”afterThrowingAdvice”指定后置异常通知实现方法；</p>
<p><strong>3）目标方法参数命名：</strong>其中使用arg-names=”exception”指定通知实现方法参数名为“exception”；</p>
<p><strong>4）异常命名：</strong>returning=”exception”用于将目标方法抛出的异常赋值给通知实现方法参数名为“exception”的参数上。</p>
<p> <strong>四、后置最终通知：</strong>在切入点选择的方法返回时执行，不管是正常返回还是抛出异常都执行，通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:after &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                  <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref：</strong>同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sayAfterFinally</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAfterFinally(..))”匹配目标方法sayAfterFinally，该方法将抛出RuntimeException异常；</p>
<p><strong>2）目标方法定义：</strong>使用method=” afterFinallyAdvice “指定后置最终通知实现方法。</p>
<p> <strong>五、环绕通知：</strong>环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值，可通过<a href="aop:aspect" target="_blank" rel="noopener">aop:aspect</a>标签下的&lt;aop:around &gt;标签声明：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span>  <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">method</span>=<span class="string">"后置最终通知实现方法名"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">arg-names</span>=<span class="string">"后置最终通知实现方法参数列表参数名字"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**同前置通知同义；</p>
<p>​         <strong>method：</strong>同前置通知同义；</p>
<p>​         <strong>arg-names：</strong>同前置通知同义；</p>
<p> 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型，在通知实现方法内部使用ProceedingJoinPoint的proceed()方法使目标方法执行，proceed 方法可以传入可选的Object[]数组，该数组的值将被作为目标方法执行时的参数。</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAround</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"============around param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三在cn.javass.spring.chapter6.aop. HelloWorldAspect定义通知实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.zero..*.sayAround(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">"aroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAroundAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayAround(<span class="string">"haha"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ===========================</p>
<p>======================around before advice</p>
<p>============around param:replace</p>
<p>===========around after advice</p>
<p>====================================== </p>
<p> 分析一下吧：</p>
<p><strong>1）切入点匹配：</strong>在配置中使用“execution(<em> cn.javass..</em>.sayAround(..))”匹配目标方法sayAround；</p>
<p><strong>2）目标方法定义：</strong>使用method=”aroundAdvice”指定环绕通知实现方法，在该实现中，第一个方法参数为pjp，类型为ProceedingJoinPoint，其中“Object retVal = pjp.proceed(new Object[] {“replace”});”，用于执行目标方法，且目标方法参数被“new Object[] {“replace”}”替换，最后返回“retVal ”返回值。</p>
<p><strong>3）测试：</strong>我们使用“helloworldService.sayAround(“haha”);”传入参数为“haha”，但最终输出为“replace”，说明参数被替换了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);</span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);</span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​     Spring引入允许为目标对象引入新的接口，通过在&lt; aop:aspect&gt;标签内使用&lt; aop:declare-parents&gt;标签进行引入，定义方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">types-matching</span>=<span class="string">"AspectJ语法类型表达式"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">implement-interface</span>=<span class="string">引入的接口</span>"               </span></span><br><span class="line"><span class="tag">          <span class="attr">default-impl</span>=<span class="string">"引入接口的默认实现"</span>  </span></span><br><span class="line"><span class="tag">          <span class="attr">delegate-ref</span>=<span class="string">"引入接口的默认实现Bean引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>types-matching：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；</p>
<p>​         <strong>implement-interface：</strong>定义需要引入的接口；</p>
<p>​         <strong>default-impl和delegate-ref：</strong>定义引入接口的默认实现，二者选一，default-impl是接口的默认实现类全限定名，而delegate-ref是默认的实现的委托Bean名；</p>
<p>接下来让我们练习一下吧：</p>
<p>​    首先定义引入的接口及默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroductiondService</span> <span class="keyword">implements</span> <span class="title">IIntroductionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">induct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========introduction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次在chapter6/advice.xml配置文件中接着前置通知配置的例子添加如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">"com.zero..*.IHelloWorldService+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">"com.zero.iin.IIntroductionService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">"com.zero.iin.IntroductiondService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后测试一下吧，测试代码cn.javass.spring.chapter6.AopTest：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaIntroduction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">    IIntroductionService introductionService =  </span><br><span class="line">    ctx.getBean(<span class="string">"helloWorldService"</span>, IIntroductionService.class);  </span><br><span class="line">    introductionService.induct();  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> =========introduction</p>
<p> ======================================  </p>
<p> 分析一下吧：</p>
<p><strong>1）目标对象类型匹配：</strong>使用types-matching=”cn.javass..*.IHelloWorldService+”匹配IHelloWorldService接口的子类型，如HelloWorldService实现；</p>
<p><strong>2）引入接口定义：</strong>通过implement-interface属性表示引入的接口，如“cn.javass.spring.chapter6.service.IIntroductionService”。</p>
<p><strong>3）引入接口的实现：</strong>通过default-impl属性指定，如“cn.javass.spring.chapter6.service.impl.IntroductiondService”，也可以使用“delegate-ref”来指定实现的Bean。</p>
<p><strong>4）获取引入接口：</strong>如使用“ctx.getBean(“helloWorldService”, IIntroductionService.class);”可直接获取到引入的接口。</p>
<h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p> Advisor表示只有一个通知和一个切入点的切面，由于Spring AOP都是基于AOP联盟的拦截器模型的环绕通知的，所以引入Advisor来支持各种通知类型（如前置通知等5种），Advisor概念来自于Spring1.2对AOP的支持，在AspectJ中没有相应的概念对应。</p>
<p> Advisor可以使用<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下的<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>标签定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"切入点表达式"</span> <span class="attr">pointcut-ref</span>=<span class="string">"切入点Bean引用"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"通知API实现引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​         <strong>pointcut和pointcut-ref**</strong>：**二者选一，指定切入点表达式；</p>
<p>​         <strong>advice-ref：</strong>引用通知API实现Bean，如前置通知接口为MethodBeforeAdvice；</p>
<p> 接下来让我们看一下示例吧：</p>
<p> 首先在cn.javass.spring.chapter6.service.IhelloWorldService定义一个测试方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其次在cn.javass.spring.chapter6.service.impl. HelloWorldService定义实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayAdvisorBefore</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"============say "</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三定义前置通知API实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceImpl</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"===========before advice"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在chapter6/advice.xml配置文件中先添加通知实现Bean定义：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeAdvice"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.BeforeAdviceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>标签下，添加Advisor定义，添加时注意顺序：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..))"</span>  </span></span><br><span class="line"><span class="tag">                     <span class="attr">advice-ref</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchemaAdvisor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">   ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice.xml"</span>);  </span><br><span class="line">   IHelloWorldService helloworldService =  </span><br><span class="line">   ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">   helloworldService.sayAdvisorBefore(<span class="string">"haha"</span>);  </span><br><span class="line">   System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输入：</p>
<p> ======================================</p>
<p> ===========before advice</p>
<p> ============say haha</p>
<p> ======================================  </p>
<h3 id="基于-AspectJ的AOP"><a href="#基于-AspectJ的AOP" class="headerlink" title="基于@AspectJ的AOP"></a>基于@AspectJ的AOP</h3><p>​       Spring除了支持Schema方式配置AOP，还支持注解方式：使用@AspectJ风格的切面声明。</p>
<h4 id="启用对-AspectJ的支持"><a href="#启用对-AspectJ的支持" class="headerlink" title="启用对@AspectJ的支持"></a>启用对@AspectJ的支持</h4><p>Spring默认不支持@AspectJ风格的切面声明，为了支持需要使用如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样Spring就能发现@AspectJ风格的切面并且将切面应用到目标对象。</p>
<h4 id="声明切面-1"><a href="#声明切面-1" class="headerlink" title="声明切面"></a>声明切面</h4><p>​       @AspectJ风格的声明切面非常简单，使用@Aspect注解进行声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>()  </span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Aspect</span></span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       然后将该切面在配置文件中声明为Bean后，Spring就能自动识别并进行AOP方面的配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"……Aspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       该切面就是一个POJO，可以在该切面中进行切入点及通知定义，接着往下看吧。</p>
<h4 id="声明切入点-1"><a href="#声明切入点-1" class="headerlink" title="声明切入点"></a>声明切入点</h4><p>​       @AspectJ风格的命名切入点使用org.aspectj.lang.annotation包下的@Pointcut+方法（方法必须是返回void类型）实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"切入点表达式"</span>, argNames = <span class="string">"参数名列表"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutName</span><span class="params">(……)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式；</p>
<p>​       <strong>argNames：</strong>指定命名切入点方法参数列表参数名字，可以有多个用“，”分隔，这些参数将传递给通知方法同名的参数，同时比如切入点表达式“args(param)”将匹配参数类型为命名切入点方法同名参数指定的参数类型。</p>
<p>​       <strong>pointcutName：</strong>切入点名字，可以使用该名字进行引用该切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个切入点，名字为“beforePointcut”，该切入点将匹配目标方法的第一个参数类型为通知方法实现中参数名为“param”的参数类型。</p>
<h4 id="声明通知-1"><a href="#声明通知-1" class="headerlink" title="声明通知"></a>声明通知</h4><p>​       @AspectJ风格的声明通知也支持5种通知类型：</p>
<p> <strong>一、前置通知：</strong>使用org.aspectj.lang.annotation 包下的@Before注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"切入点表达式或命名切入点"</span>, argNames = <span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​    <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义。</p>
<p>接下来示例一下吧：</p>
<p>1、定义接口和实现，在此我们就使用Schema风格时的定义；</p>
<p>2、定义切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter6.aop;  </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;  </span><br><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAspect2</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义切入点：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value=<span class="string">"execution(* cn.javass..*.sayAdvisorBefore(..)) &amp;&amp; args(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointcut</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义通知：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"beforePointcut(param)"</span>, argNames = <span class="string">"param"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(String param)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========before advice param:"</span> + param);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在chapter6/advice2.xml配置文件中进行如下配置：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop  </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">            </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.service.impl.HelloWorldService"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span>  </span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect2"</span>/&gt;</span>  </span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6、测试代码cn.javass.spring.chapter6.AopTest:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationBeforeAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter6/advice2.xml"</span>);  </span><br><span class="line">    IHelloWorldService helloworldService = ctx.getBean(<span class="string">"helloWorldService"</span>, IHelloWorldService.class);  </span><br><span class="line">    helloworldService.sayBefore(<span class="string">"before"</span>);  </span><br><span class="line">    System.out.println(<span class="string">"======================================"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<p> ==========================================</p>
<p> ===========before advice param:before</p>
<p> ============say before</p>
<p> ==========================================  </p>
<p>切面、切入点、通知全部使用注解完成：</p>
<p>​       1）使用@Aspect将POJO声明为切面；</p>
<p>​       2）使用@Pointcut进行命名切入点声明，同时指定目标方法第一个参数类型必须是java.lang.String，对于其他匹配的方法但参数类型不一致的将也是不匹配的，通过argNames = “param”指定了将把该匹配的目标方法参数传递给通知同名的参数上；</p>
<p>​       3）使用@Before进行前置通知声明，其中value用于定义切入点表达式或引用命名切入点；</p>
<p>​       4）配置文件需要使用<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>来开启注解风格的@AspectJ支持；</p>
<p>​       5）需要将切面注册为Bean，如“aspect”Bean；</p>
<p>​       6）测试代码完全一样。</p>
<p><strong>二、后置返回通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterReturning注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">returning=<span class="string">"返回值对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argName：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>returning：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayBefore(..))"</span>,  </span><br><span class="line">    pointcut=<span class="string">"execution(* cn.javass..*.sayAfterReturning(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"retVal"</span>, returning=<span class="string">"retVal"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object retVal)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after returning advice retVal:"</span> + retVal);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterReturningAdvice测试方法。</p>
<p> <strong>三、后置异常通知：</strong>使用org.aspectj.lang.annotation 包下的@AfterThrowing注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">pointcut=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>,  </span><br><span class="line">throwing=<span class="string">"异常对应参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>pointcut：</strong>同样是指定切入点表达式或命名切入点，如果指定了将覆盖value属性指定的，pointcut具有高优先级；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<p>​       <strong>throwing：</strong>与Schema方式配置中的同义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(  </span><br><span class="line">    value=<span class="string">"execution(* cn.javass..*.sayAfterThrowing(..))"</span>,  </span><br><span class="line">    argNames=<span class="string">"exception"</span>, throwing=<span class="string">"exception"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception exception)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after throwing advice exception:"</span> + exception);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterThrowingAdvice测试方法。</p>
<p> <strong>四、后置最终通知：</strong>使用org.aspectj.lang.annotation 包下的@After注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* cn.javass..*.sayAfterFinally(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFinallyAdvice</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========after finally advice"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationAfterFinallyAdvice测试方法。 </p>
<p><strong>五、环绕通知：</strong>使用org.aspectj.lang.annotation 包下的@Around注解声明；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span> (  </span><br><span class="line">value=<span class="string">"切入点表达式或命名切入点"</span>,  </span><br><span class="line">argNames=<span class="string">"参数列表参数名"</span>)</span><br></pre></td></tr></table></figure>
<p>​       <strong>value：</strong>指定切入点表达式或命名切入点；</p>
<p>​       <strong>argNames：</strong>与Schema方式配置中的同义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value=<span class="string">"execution(* cn.javass..*.sayAround(..))"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"===========around before advice"</span>);  </span><br><span class="line">    Object retVal = pjp.proceed(<span class="keyword">new</span> Object[] &#123;<span class="string">"replace"</span>&#125;);  </span><br><span class="line">    System.out.println(<span class="string">"===========around after advice"</span>);  </span><br><span class="line">    <span class="keyword">return</span> retVal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的annotationAroundAdviceTest测试方法。 </p>
<h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>​       @AspectJ风格的引入声明在切面中使用org.aspectj.lang.annotation包下的@DeclareParents声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">value=<span class="string">" AspectJ语法类型表达式"</span>,  </span><br><span class="line">defaultImpl=引入接口的默认实现类)  </span><br><span class="line"><span class="keyword">private</span> Interface <span class="class"><span class="keyword">interface</span></span>;</span><br></pre></td></tr></table></figure>
<p> <strong>value：</strong>匹配需要引入接口的目标对象的AspectJ语法类型表达式；与Schema方式中的types-matching属性同义；</p>
<p>​       private Interface interface<strong>：</strong>指定需要引入的接口；</p>
<p>​       defaultImpl<strong>：</strong>指定引入接口的默认实现类，没有与Schema方式中的delegate-ref属性同义的定义方式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeclareParents</span>(  </span><br><span class="line">    value=<span class="string">"cn.javass..*.IHelloWorldService+"</span>, defaultImpl=cn.javass.spring.chapter6.service.impl.IntroductiondService.class)  </span><br><span class="line"><span class="keyword">private</span> IIntroductionService introductionService;</span><br></pre></td></tr></table></figure>
<p>其中测试代码与Schema方式几乎一样，在此就不演示了，如果需要请参考AopTest.java中的testAnnotationIntroduction测试方法。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Spring之资源与表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Spring之资源与表达式/" itemprop="url">Spring之资源与表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-24T11:27:18+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/whyathere/tuchuang/blob/master/%E7%BE%8E%E5%9B%BE/%E6%9C%88%E5%85%89%E4%B8%8B%E7%9A%84%E7%A5%81%E8%BF%9E%E5%B1%B1%E6%9C%80%E9%AB%98%E5%B3%B0.jpg?raw=true" alt=""></p>
<p>抄自：开涛  <a href="http://jinnianshilongnian.iteye.com/blog/1416319" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1416319</a></p>
<p>### </p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="资源基础知识"><a href="#资源基础知识" class="headerlink" title="资源基础知识"></a>资源基础知识</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在日常程序开发中，处理外部资源是很繁琐的事情，我们可能需要处理URL资源、File资源、ClassPath相关资源、服务器相关资源(JBoss AS 5.x 上的VFS资源)等等很多资源。因此处理这些资源需要使用不同的接口，这就增加了我们系统的复杂性；而且处理这些资源步骤都是类似的(打开资源、读取资源、关闭资源)，因此如果能抽象出一个统一的接口来对这些底层资源进行统一访问，是不是很方便，而且使我们系统更加简洁，都是对不同的底层资源使用同一个接口进行访问。</p>
<p>Spring提供了一个Resource接口来统一这些底层资源一直的访问，而且提供了一些便利的接口，从而能提供我们的生产力。</p>
<h4 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h4><p>Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;  </span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)InputStreamSource接口解析： </p>
<p><strong>getInputStream：</strong>每次调用都将返回一个新鲜的资源对应的java.io.InputStream字节流，调用者在使用完毕后必须关闭该资源。</p>
<p>2）Resource接口继承InputStreamSource接口，并提供一些便利方法：</p>
<ul>
<li><p><strong>exists：</strong>返回当前Resource代表的底层资源是否可读，true表示可读</p>
</li>
<li><p><strong>isReadable</strong>：返回当前Resource代表的底层资源是否可读，true表示可读。</p>
</li>
<li><p><strong>isOpen</strong>：返回当前Resource代表的底层资源是否已经打开，如果返回true，则只能被读取一次然后关闭以避免资源泄露；常见的Resource实现一般返回false。 </p>
</li>
<li><p><strong>getURL</strong>：如果当前Resource代表的底层资源能由java.util.URL代表，则返回该URL，否则抛出IOException。</p>
</li>
<li><p><strong>getURI</strong>：如果当前Resource代表的底层资源能由java.util.URI代表，则返回该URI，否则抛出IOException。 </p>
</li>
<li><p><strong>getFile</strong>：如果当前Resource代表的底层资源能由java.io.File代表，则返回该File，否则抛出IOException。 </p>
</li>
<li><p><strong>contentLength</strong>：返回当前Resource代表的底层文件资源的长度，一般是值代表的文件资源的长度。</p>
</li>
<li><p><strong>lastModified</strong> ：返回当前Resource代表的底层资源的最后修改时间。 </p>
</li>
<li><p><strong>createRelative</strong>：用于创建相对于当前Resource代表的底层资源的资源，比如当前Resource代表文件资源“d:/test/”则createRelative（“test.txt”）将返回表文件资源“d:/test/test.txt”Resource资源。 </p>
</li>
<li><p><strong>getFilename</strong>：返回当前Resource代表的底层文件资源的文件路径，比如File资源“file://d:/test.txt”将返回“d:/test.txt”，而URL资源<a href="http://www.javass.cn将返回“”，因为只返回文件路径。" target="_blank" rel="noopener">http://www.javass.cn将返回“”，因为只返回文件路径。</a> </p>
</li>
<li><p><strong>getDescription</strong>：返回当前Resource代表的底层资源的描述符，通常就是资源的全路径（实际文件名或实际URL地址）。</p>
<p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p>
</li>
</ul>
<h3 id="内置Resource实现"><a href="#内置Resource实现" class="headerlink" title="内置Resource实现"></a>内置Resource实现</h3><h4 id="ByteArrayResource"><a href="#ByteArrayResource" class="headerlink" title="ByteArrayResource"></a>ByteArrayResource</h4><p>ByteArrayResource代表byte[]数组资源对于“getInputStream”操作将返回一个ByteArrayInputStream。</p>
<p>首先让我们看下使用ByteArrayResource如何处理byte数组资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByteArrayResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ByteArrayResource(<span class="string">"Hello World !"</span>.getBytes()); <span class="comment">//得到一个操作系统默认的编码格式的字节数组。</span></span><br><span class="line">        <span class="keyword">if</span> (resource.exists())&#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，让我们看下“dumpStream”实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpStream</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取文件资源</span></span><br><span class="line">            is = resource.getInputStream();</span><br><span class="line">            <span class="comment">//2.读取资源</span></span><br><span class="line">            <span class="keyword">byte</span>[] descBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(descBytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(descBytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3.关闭资源</span></span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    让我们来仔细看一下代码，dumpStream方法很抽象定义了访问流的三部曲：打开资源、读取资源、关闭资源，所以dunpStrean可以再进行抽象从而能在自己项目中使用；byteArrayResourceTest测试方法，也定义了基本步骤：定义资源、验证资源存在、访问资源。</p>
<p>​        ByteArrayResource可多次读取数组资源，即isOpen ()永远返回false。</p>
<h4 id="InputStreamResource"><a href="#InputStreamResource" class="headerlink" title="InputStreamResource"></a>InputStreamResource</h4><p>​       InputStreamResource代表java.io.InputStream字节流，对于“getInputStream ”操作将直接返回该字节流，因此只能读取一次该字节流，即“isOpen”永远返回true。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInputStreamResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"Hello World!"</span>.getBytes());</span><br><span class="line">    Resource resource = <span class="keyword">new</span> InputStreamResource(bis);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h4><p>​       FileSystemResource代表java.io.File资源，对于“getInputStream ”操作将返回底层文件的字节流，“isOpen”将永远返回false，从而表示可多次读取底层文件的字节流。</p>
<p>​        让我们看下测试代码吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意由于“isOpen”将永远返回false，所以可以多次调用dumpStream(resource)。</p>
<h4 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h4><p>​       ClassPathResource代表classpath路径的资源，将使用ClassLoader进行加载资源。classpath 资源存在于类路径中的文件系统中或jar包里，且“isOpen”永远返回false，表示可多次读取资源。</p>
<pre><code>ClassPathResource加载资源替代了Class类和ClassLoader类的“getResource(String name)”和“getResourceAsStream(String name)”两个加载类路径资源方法，提供一致的访问方式。
</code></pre><p> ClassPathResource提供了三个构造器：</p>
<p>​          <strong>public ClassPathResource(String path)</strong>：使用默认的ClassLoader加载“path”类路径资源；</p>
<p>​          <strong>public ClassPathResource(String path, ClassLoader classLoader)</strong>：使用指定的ClassLoader加载“path”类路径资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/test1.properties”；</p>
<p>​          <strong>public ClassPathResource(String path, Class&lt;?&gt; clazz)</strong>：使用指定的类加载“path”类路径资源，将加载相对于当前类的路径的资源；</p>
<p> 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties”；</p>
<p>​        而如果需要 加载的资源路径为“test1.properties”，将加载的资源为“cn/javass/spring/chapter4/test1.properties”。</p>
<p>​        让我们直接看测试代码吧：</p>
<p> 1）使用默认的加载器加载资源，将加载当前ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByDefaultClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）使用指定的ClassLoader进行加载资源，将加载指定的ClassLoader类路径上相对于根路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , cl);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）使用指定的类进行加载资源，将尝试加载相对于当前类的路径的资源：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathResourceByClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">    Resource resource1 = <span class="keyword">new</span> ClassPathResource(<span class="string">"cn/javass/spring/chapter4/test1.properties"</span> , clazz);</span><br><span class="line">    <span class="keyword">if</span>(resource1.exists()) &#123;</span><br><span class="line">        dumpStream(resource1);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource1.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource1.isOpen());</span><br><span class="line"></span><br><span class="line">    Resource resource2 = <span class="keyword">new</span> ClassPathResource(<span class="string">"test1.properties"</span> , <span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">if</span>(resource2.exists()) &#123;</span><br><span class="line">        dumpStream(resource2);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource2.getFile().getAbsolutePath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource2.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       “resource1”将加载cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties资源；“resource2”将加载“cn/javass/spring/chapter4/test1.properties”；</p>
<p> 4）加载jar包里的资源，首先在当前类路径下找不到，最后才到Jar包里找，而且在第一个Jar包里找到的将被返回：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classpathResourceTestFromJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"overview.html"</span>);</span><br><span class="line">    <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">        dumpStream(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"path:"</span> + resource.getURL().getPath());</span><br><span class="line">    Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前类路径包含“overview.html”，在项目的“resources”目录下，将加载该资源，否则将加载Jar包里的“overview.html”，而且不能使用“resource.getFile()”，应该使用“resource.getURL()”，因为资源不存在于文件系统而是存在于jar包里，URL类似于“file:/C:/…/***.jar!/overview.html”。</p>
<p> 类路径一般都是相对路径，即相对于类路径或相对于当前类的路径，因此如果使用“/test1.properties”带前缀“/”的路径，将自动删除“/”得到“test1.properties”。</p>
<h4 id="UrlResource"><a href="#UrlResource" class="headerlink" title="UrlResource"></a>UrlResource</h4><p>​       UrlResource代表URL资源，用于简化URL资源访问。“isOpen”永远返回false，表示可多次读取资源。</p>
<p>​        UrlResource一般支持如下资源访问：</p>
<p>​      UrlResource一般支持如下资源访问：</p>
<p>​         <strong>http：</strong>通过标准的http协议访问web资源，如new UrlResource(“http://地址”)；</p>
<p>​         <strong>ftp：</strong>通过ftp协议访问资源，如new UrlResource(“ftp://地址”)；</p>
<p>​         <strong>file：</strong>通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”)；</p>
<p>具体使用方法在此就不演示了，可以参考cn.javass.spring.chapter4.ResourceTest中urlResourceTest测试方法。</p>
<h4 id="ServletContextResource"><a href="#ServletContextResource" class="headerlink" title="ServletContextResource"></a>ServletContextResource</h4><p>​       ServletContextResource代表web应用资源，用于简化servlet容器的ServletContext接口的getResource操作和getResourceAsStream操作；在此就不具体演示了。</p>
<h4 id="VfsResource"><a href="#VfsResource" class="headerlink" title="VfsResource"></a>VfsResource</h4><p>VfsResource代表Jboss 虚拟文件系统资源。</p>
<p> Jboss VFS(Virtual File System)框架是一个文件系统资源访问的抽象层，它能一致的访问物理文件系统、jar资源、zip资源、war资源等，VFS能把这些资源一致的映射到一个目录上，访问它们就像访问物理文件资源一样，而其实这些资源不存在于物理文件系统。</p>
<p> 在示例之前需要准备一些jar包，在此我们使用的是Jboss VFS3版本，可以下载最新的Jboss AS 6x，拷贝lib目录下的“jboss-logging.jar”和“jboss-vfs.jar”两个jar包拷贝到我们项目的lib目录中并添加到“Java Build Path”中的“Libaries”中。</p>
<p> 让我们看下示例（cn.javass.spring.chapter4.ResourceTest）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForRealFileSystem</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home"</span>);</span><br><span class="line"><span class="comment">//2.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mount(home, <span class="keyword">new</span> RealFileSystem(<span class="keyword">new</span> File(<span class="string">"d:"</span>)));</span><br><span class="line"><span class="comment">//3.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//4.通过一致的接口访问</span></span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVfsResourceForJar</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.首先获取jar包路径</span></span><br><span class="line">        File realFile = <span class="keyword">new</span> File(<span class="string">"lib/org.springframework.beans-3.0.5.RELEASE.jar"</span>);</span><br><span class="line">        <span class="comment">//2.创建一个虚拟的文件目录</span></span><br><span class="line">        VirtualFile home = VFS.getChild(<span class="string">"/home2"</span>);</span><br><span class="line">        <span class="comment">//3.将虚拟目录映射到物理的目录</span></span><br><span class="line">        VFS.mountZipExpanded(realFile, home,</span><br><span class="line">                TempFileProvider.create(<span class="string">"tmp"</span>, Executors.newScheduledThreadPool(<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//4.通过虚拟目录获取文件资源</span></span><br><span class="line">        VirtualFile testFile = home.getChild(<span class="string">"META-INF/spring.handlers"</span>);</span><br><span class="line">        Resource resource = <span class="keyword">new</span> VfsResource(testFile);</span><br><span class="line">        <span class="keyword">if</span>(resource.exists()) &#123;</span><br><span class="line">            dumpStream(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"path:"</span> + resource.getFile().getAbsolutePath());</span><br><span class="line">        Assert.assertEquals(<span class="keyword">false</span>, resource.isOpen());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​       通过VFS，对于jar里的资源和物理文件系统访问都具有一致性，此处只是简单示例，如果需要请到Jboss官网深入学习。</p>
<h3 id="访问Resource"><a href="#访问Resource" class="headerlink" title="访问Resource"></a>访问Resource</h3><h4 id="ResourceLoader接口"><a href="#ResourceLoader接口" class="headerlink" title="ResourceLoader接口"></a>ResourceLoader接口</h4><p>ResourceLoader接口用于返回Resource对象；其实现可以看作是一个生产Resource的工厂类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       getResource接口用于根据提供的location参数返回相应的Resource对象；而getClassLoader则返回加载这些Resource的ClassLoader。</p>
<p>​        Spring提供了一个适用于所有环境的DefaultResourceLoader实现，可以返回ClassPathResource、UrlResource；还提供一个用于web环境的ServletContextResourceLoader，它继承了DefaultResourceLoader的所有功能，又额外提供了获取ServletContextResource的支持。</p>
<p>​        ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：“classpath:path”表示返回ClasspathResource，“<a href="http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：" target="_blank" rel="noopener">http://path”和“file:path”表示返回UrlResource资源，如果不加前缀则需要根据当前上下文来决定，DefaultResourceLoader默认实现可以加载classpath资源，如代码所示（cn.javass.spring.chapter4.ResourceLoaderTest）：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testResourceLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader loader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">    Resource resource = loader.getResource(<span class="string">"classpath:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(ClassPathResource.class, resource.getClass());</span><br><span class="line">    Resource resource2 = loader.getResource(<span class="string">"file:cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返回的是ClassPathResource</span></span><br><span class="line">    Assert.assertEquals(UrlResource.class, resource2.getClass());</span><br><span class="line">    Resource resource3 = loader.getResource(<span class="string">"cn/javass/spring/chapter4/test1.txt"</span>);</span><br><span class="line">    <span class="comment">//验证返默认可以加载ClasspathResource</span></span><br><span class="line">    Assert.assertTrue(resource3 <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于目前所有ApplicationContext都实现了ResourceLoader，因此可以使用其来加载资源。</p>
<p>​         <strong>ClassPathXmlApplicationContext：</strong>不指定前缀将返回默认的ClassPathResource资源，否则将根据前缀来加载资源；</p>
<p>​         <strong>FileSystemXmlApplicationContext：</strong>不指定前缀将返回FileSystemResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>WebApplicationContext：</strong>不指定前缀将返回ServletContextResource，否则将根据前缀来加载资源；</p>
<p>​         <strong>其他：</strong>不指定前缀根据当前上下文返回Resource实现，否则将根据前缀来加载资源。</p>
<h4 id="ResourceLoaderAware接口"><a href="#ResourceLoaderAware接口" class="headerlink" title="ResourceLoaderAware接口"></a>ResourceLoaderAware接口</h4><p>​       ResourceLoaderAware是一个标记接口，用于通过ApplicationContext上下文注入ResourceLoader。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）  首先准备测试Bean，我们的测试Bean还简单只需实现ResourceLoaderAware接口，然后通过回调将ResourceLoader保存下来就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）  配置Bean定义（chapter4/resourceLoaderAware.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）测试(cn.javass.spring.chapter4.ResoureLoaderAwareTest)：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</span><br><span class="line">        ResourceBean resourceBean = ctx.getBean(ResourceBean.class);</span><br><span class="line">        ResourceLoader loader = resourceBean.getResourceLoader();</span><br><span class="line">        Assert.assertTrue(loader <span class="keyword">instanceof</span> ApplicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       注意此处“loader instanceof ApplicationContext”，说明了ApplicationContext就是个ResoureLoader。</p>
<p>​        由于上述实现回调接口注入ResourceLoader的方式属于侵入式，所以不推荐上述方法，可以采用更好的自动注入方式，如“byType”和“constructor”，此处就不演示了。   </p>
<h4 id="注入Resource"><a href="#注入Resource" class="headerlink" title="注入Resource"></a>注入Resource</h4><p>​       通过回调或注入方式注入“ResourceLoader”，然后再通过“ResourceLoader”再来加载需要的资源对于只需要加载某个固定的资源是不是很麻烦，有没有更好的方法类似于前边实例中注入“java.io.File”类似方式呢？</p>
<p>​        Spring提供了一个PropertyEditor “ResourceEditor”用于在注入的字符串和Resource之间进行转换。因此可以使用注入方式注入Resource。</p>
<p>​        ResourceEditor完全使用ApplicationContext根据注入的路径字符串获取相应的Resource，说白了还是自己做还是容器帮你做的问题。</p>
<p> 接下让我们看下示例：</p>
<p>​        1）准备Bean：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBean3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       2）准备配置文件（chapter4/ resourceInject.xml）：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span> <span class="attr">value</span>=<span class="string">"cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"com.zero.resource.ResourceBean3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resource"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">"classpath:cn/javass/spring/chapter4/test1.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       注意此处“resourceBean1”注入的路径没有前缀表示根据使用的ApplicationContext实现进行选择Resource实现。</p>
<p>​        3）让我们来看下测试代码（cn.javass.spring.chapter4.ResourceInjectTest）吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter4/resourceInject.xml"</span>);</span><br><span class="line">    ResourceBean3 resourceBean1 = ctx.getBean(<span class="string">"resourceBean1"</span>, ResourceBean3.class);</span><br><span class="line">    ResourceBean3 resourceBean2 = ctx.getBean(<span class="string">"resourceBean2"</span>, ResourceBean3.class);</span><br><span class="line">    Assert.assertTrue(resourceBean1.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">    Assert.assertTrue(resourceBean2.getResource() <span class="keyword">instanceof</span> ClassPathResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       接下来一节让我们深入ApplicationContext对各种Resource的支持，及如何使用更便利的资源加载方式。</p>
<h3 id="Resource通配符路径"><a href="#Resource通配符路径" class="headerlink" title="Resource通配符路径"></a>Resource通配符路径</h3><h4 id="使用路径通配符加载Resource"><a href="#使用路径通配符加载Resource" class="headerlink" title="使用路径通配符加载Resource"></a>使用路径通配符加载Resource</h4><p>​        前面介绍的资源路径都是非常简单的一个路径匹配一个资源，Spring还提供了一种更强大的Ant模式通配符匹配，从能一个路径匹配一批资源。</p>
<p>​        Ant路径通配符支持“？”、“*”、“**”，注意通配符匹配不包括目录分隔符“/”：</p>
<p> <strong>“?**</strong>”：匹配一个字符**，如“config?.xml”将匹配“config1.xml”；</p>
<p>​         <strong>“***</strong>”：匹配零个或多个字符串*<em>，如“cn/</em>/config.xml”将匹配“cn/javass/config.xml”，但不匹配匹配“cn/config.xml”；而“cn/config-*.xml”将匹配“cn/config-dao.xml”；</p>
<p>​         <strong>“****</strong>”：匹配路径中的零个或多个目录<strong>，如“cn/</strong>/config.xml”将匹配“cn /config.xml”，也匹配“cn/javass/spring/config.xml”；而“cn/javass/config-<strong>.xml”将匹配“cn/javass/config-dao.xml”，即把“</strong>”当做两个“*”处理。</p>
<p>Spring提供AntPathMatcher来进行Ant风格的路径匹配。具体测试请参考cn.javass.spring.chapter4. AntPathMatcherTest。</p>
<p>Spring在加载类路径资源时除了提供前缀“classpath:”的来支持加载一个Resource，还提供一个前缀“classpath*:”来支持加载所有匹配的类路径Resource。</p>
<p>Spring提供ResourcePatternResolver接口来加载多个Resource，该接口继承了ResourceLoader并添加了“Resource[] getResources(String locationPattern)”用来加载多个Resource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;  </span><br><span class="line">       String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;  </span><br><span class="line">       Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring提供了一个ResourcePatternResolver实现PathMatchingResourcePatternResolver，它是基于模式匹配的，默认使用AntPathMatcher进行路径匹配，它除了支持ResourceLoader支持的前缀外，还额外支持“classpath<em>:”用于加载所有匹配的类路径Resource，ResourceLoader不支持前缀“classpath</em>:”：</p>
<p> 首先做下准备工作，在项目的“resources”创建“META-INF”目录，然后在其下创建一个“INDEX.LIST”文件。同时在“org.springframework.beans-3.0.5.RELEASE.jar”和“org.springframework.context-3.0.5.RELEASE.jar”两个jar包里也存在相同目录和文件。然后创建一个“LICENSE”文件，该文件存在于“com.springsource.cn.sf.cglib-2.2.0.jar”里。</p>
<p> <strong>一、“classpath</strong>”：*<em> 用于加载类路径（包括jar包）中的一个且仅一个资源；对于多个匹配的也只返回一个，所以如果需要多个匹配的请考虑“classpath</em>:”前缀；</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathPrefix</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();  </span><br><span class="line">    <span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, resources.length);  </span><br><span class="line">    <span class="comment">//只加载一个匹配的Resource，且通过ResourceLoader.getResource进行加载  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二、“classpath*”：</strong> 用于加载类路径（包括jar包）中的所有匹配的资源。带通配符的classpath使用“ClassLoader”的“Enumeration<url> getResources(String name)”方法来查找通配符之前的资源，然后通过模式匹配来获取匹配的资源。如“classpath:META-INF/*.LIST”将首先加载通配符之前的目录“META-INF”，然后再遍历路径进行子路径匹配从而获取匹配的资源。 </url></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefix</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">     ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();        </span><br><span class="line">     <span class="comment">//将加载多个绝对匹配的所有Resource  </span></span><br><span class="line">    <span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);      </span><br><span class="line">    <span class="comment">//将加载多个模式匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:META-INF/*.LIST"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意“resources.length &gt;1”说明返回多个Resource。不管模式匹配还是非模式匹配只要匹配的都将返回。</p>
<pre><code>在“com.springsource.cn.sf.cglib-2.2.0.jar”里包含“asm-license.txt”文件，对于使用“classpath*: asm-*.txt”进行通配符方式加载资源将什么也加载不了“asm-license.txt”文件，注意一定是模式路径匹配才会遇到这种问题。这是由于“ClassLoader”的“getResources(String name)”方法的限制，对于name为“”的情况将只返回文件系统的类路径，不会包换jar包根路径。 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClasspathAsteriskPrefixLimit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();      <span class="comment">//将首先通过ClassLoader.getResources("")加载目录，  </span></span><br><span class="line">    <span class="comment">//将只返回文件系统的类路径不返回jar的跟路径  </span></span><br><span class="line">    <span class="comment">//然后进行遍历模式匹配  </span></span><br><span class="line">    Resource[] resources = resolver.getResources(<span class="string">"classpath*:asm-*.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//将通过ClassLoader.getResources("asm-license.txt")加载  </span></span><br><span class="line">    <span class="comment">//asm-license.txt存在于com.springsource.net.sf.cglib-2.2.0.jar  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:asm-license.txt"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length &gt; <span class="number">0</span>);       </span><br><span class="line">    <span class="comment">//将只加载文件系统类路径匹配的Resource  </span></span><br><span class="line">    resources = resolver.getResources(<span class="string">"classpath*:LICENS*"</span>);  </span><br><span class="line">    Assert.assertTrue(resources.length == <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于“resolver.getResources(“classpath<em>:asm-</em>.txt”);”，由于在项目“resources”目录下没有所以应该返回0个资源；“resolver.getResources(“classpath<em>:asm-license.txt”);”将返回jar包里的Resource；“resolver.getResources(“classpath</em>:LICENS*”);”，因为将只返回文件系统类路径资源，所以返回1个资源。</p>
<p> 因此加载通配符路径时（即路径中包含通配符），必须包含一个根目录才能保证加载的资源是所有的，而不是部分。</p>
<p> <strong>三、“file”：</strong>加载一个或多个文件系统中的Resource。如“file:D:/*.txt”将返回D盘下的所有txt文件；      </p>
<p><strong>四、无前缀</strong>：通过ResourceLoader实现加载一个资源。</p>
<p>AppliacationContext提供的getResources方法将获取资源委托给ResourcePatternResolver实现，默认使用PathMatchingResourcePatternResolver。所有在此就无需介绍其使用方法了。</p>
<h4 id="注入Resource数组"><a href="#注入Resource数组" class="headerlink" title="注入Resource数组"></a>注入Resource数组</h4><p>​       Spring还支持注入Resource数组，直接看配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean1"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>log4j.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean2"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span> <span class="attr">value</span>=<span class="string">"classpath*:META-INF/INDEX.LIST"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceBean3"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter4.bean.ResourceBean4"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/javass/spring/chapter4/test1.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath*:META-INF/INDEX.LIST<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       “resourceBean1”就不用多介绍了，传统实现方式；对于“resourceBean2”则使用前缀“classpath*”，看到这大家应该懂的，加载匹配多个资源；“resourceBean3”是混合使用的；测试代码在“cn.javass.spring.chapter4.ResourceInjectTest.testResourceArrayInject”。</p>
<p>​        Spring通过ResourceArrayPropertyEditor来进行类型转换的，而它又默认使用“PathMatchingResourcePatternResolver”来进行把路径解析为Resource对象。所有大家只要会使用“PathMatchingResourcePatternResolver”，其它一些实现都是委托给它的，比如AppliacationContext的“getResources”方法等。</p>
<h4 id="AppliacationContext实现对各种Resource的支持"><a href="#AppliacationContext实现对各种Resource的支持" class="headerlink" title="AppliacationContext实现对各种Resource的支持"></a>AppliacationContext实现对各种Resource的支持</h4><p>​       <strong>一、ClassPathXmlApplicationContext：</strong>默认将通过classpath进行加载返回ClassPathResource，提供两类构造器方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//1）通过ResourcePatternResolver实现根据configLocation获取资源  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span>；  </span></span><br><span class="line"><span class="function">       <span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, ……)</span></span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//2）通过直接根据path直接返回ClasspathResource  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String path, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class clazz, ……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​       第一类构造器是根据提供的配置文件路径使用“ResourcePatternResolver ”的“getResources()”接口通过匹配获取资源；即如“classpath:config.xml”</p>
<p>​        第二类构造器则是根据提供的路径和clazz来构造ClassResource资源。即采用“public ClassPathResource(String path, Class&lt;?&gt; clazz)”构造器获取资源。</p>
<p>​        <strong>二、FileSystemXmlApplicationContext：</strong>将加载相对于当前工作目录的“configLocation”位置的资源，注意在linux系统上不管“configLocation”是否带“/”，都作为相对路径；而在window系统上如“D:/resourceInject.xml”是绝对路径。因此在除非很必要的情况下，不建议使用该ApplicationContext。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span></span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String... configLocations,……)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line"><span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       此处还需要注意：在linux系统上，构造器使用的是相对路径，而ctx.getResource()方法如果以“/”开头则表示获取绝对路径资源，而不带前导“/”将返回相对路径资源。如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"/root/confg.xml"</span>);  </span><br><span class="line"><span class="comment">//windows系统，第一个将相对于当前vm路径进行加载；  </span></span><br><span class="line"><span class="comment">//第二个则是绝对路径方式加载  </span></span><br><span class="line">ctx.getResource (<span class="string">"chapter4/config.xml"</span>);  </span><br><span class="line">ctx.getResource (<span class="string">"d:/chapter4/confg.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>​       因此如果需要加载绝对路径资源最好选择前缀“file”方式，将全部根据绝对路径加载。如在linux系统“ctx.getResource (“file:/root/confg.xml”);”    </p>
<h2 id="Spring表达式语言"><a href="#Spring表达式语言" class="headerlink" title="Spring表达式语言"></a>Spring表达式语言</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​       Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>​        表达式语言给静态Java语言增加了动态功能。</p>
<p>​        SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h4 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h4><p> 表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>​       SpEL支持如下表达式：</p>
<p><strong>一、基本表达式：</strong>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p><strong>二、类相关表达式：</strong>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p><strong>三、集合相关表达式：</strong>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p><strong>四、其他表达式</strong>：模板表达式。</p>
<p><strong>注：SpEL表达式中的关键字是不区分大小写的。</strong></p>
<h3 id="SpEL基础"><a href="#SpEL基础" class="headerlink" title="SpEL基础"></a>SpEL基础</h3><h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>​       首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>​        SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>​        让我们看下代码片段吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression =</span><br><span class="line">                parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<p>1）创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</p>
<p>2）解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</p>
<p>3）构造上下文：准备比如变量定义等等表达式需要的上下文数据。</p>
<p>4）求值：通过Expression接口的getValue方法根据上下文获得表达式值。</p>
<p>是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h4 id="SpEL原理及接口"><a href="#SpEL原理及接口" class="headerlink" title="SpEL原理及接口"></a>SpEL原理及接口</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

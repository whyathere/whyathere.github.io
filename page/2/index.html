<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bill">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Bill">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bill">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Bill</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/正则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/正则/" itemprop="url">正则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T19:36:21+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>正则表达式是对<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6" target="_blank" rel="noopener">字符</a>串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/Spring 的注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/Spring 的注解/" itemprop="url">Spring 注解和配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T18:42:24+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring-XML"><a href="#Spring-XML" class="headerlink" title="Spring-XML"></a>Spring-XML</h3><h4 id="lt-context-component-scan-base-package-quot-quot-gt"><a href="#lt-context-component-scan-base-package-quot-quot-gt" class="headerlink" title="&lt;context:component-scan base-package=&quot;&quot; &gt;"></a><code>&lt;context:component-scan base-package=&quot;&quot; &gt;</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自动扫描base-package 对应路径或者改路径子包下面的java文件，带有@Service、@Controller等这些注解的类，则把这些类注册为bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只想扫描包下面的 controller可以用  include-filter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"assignable"</span> <span class="attr">expression</span>=<span class="string">"com"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"assignable"</span> <span class="attr">expression</span>=<span class="string">"com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>context:component-scan</code></p>
<p>自动扫描base-package 对应路径或者改路径子包下面的java文件。将带有@Service、@Controller等这些注解的类，则把这些类注册为bean。</p>
<p><code>&lt;context:include-filter</code> ：只扫描这个下面的包，并起作用</p>
<p>这个需要与 <code>use-dafault-filters=”false”</code>搭配使用，否则不起作用。</p>
<p><code>&lt;context:exclude-filter</code>：除这个路径之外的起作用</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filter Type</th>
<th style="text-align:center">Examples Expression</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">annotation</td>
<td style="text-align:center">org.example.SomeAnnotation</td>
<td style="text-align:center">符合SomeAnnoation的target class</td>
</tr>
<tr>
<td style="text-align:center">assignable</td>
<td style="text-align:center">org.example.SomeClass</td>
<td style="text-align:center">指定class或interface的全名</td>
</tr>
<tr>
<td style="text-align:center">aspectj</td>
<td style="text-align:center">org.example..*Service+</td>
<td style="text-align:center">AspetJ语法</td>
</tr>
<tr>
<td style="text-align:center">regex</td>
<td style="text-align:center">org.example.Default.*</td>
<td style="text-align:center">Regelar Expression</td>
</tr>
<tr>
<td style="text-align:center">custom</td>
<td style="text-align:center">org.example.MyTypeFilter</td>
<td style="text-align:center">Spring3新增自订Type,称作org.springframework.core.type.TypeFilter</td>
</tr>
</tbody>
</table>
<h4 id="lt-mvc-annotation-driven-gt"><a href="#lt-mvc-annotation-driven-gt" class="headerlink" title="&lt;mvc:annotation-driven&gt;"></a><code>&lt;mvc:annotation-driven&gt;</code></h4><p>​        <code>&lt;</code>mvc:annotation-driven<code>&gt;</code>会自动注册<code>RequestMappingHandlerMapping</code>与<code>RequestMappingHandlerAdapter</code>两个Bean,这是Spring MVC为@Controller分发请求所必需的，并且提供了数据绑定支持，<code>@NumberFormatannotation</code>支持，<code>@DateTimeFormat</code>支持,@Valid支持读写XML的支持（JAXB）和读写JSON的支持（默认Jackson）等功能</p>
<p>​    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置Fastjson支持 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"features"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteDateUseDateFormat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;list&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteDateUseDateFormat&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;QuoteFieldNames&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteNullListAsEmpty&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteNullStringAsEmpty&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteNullNumberAsZero&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteNullBooleanAsFalse&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;WriteMapNullValue&lt;/value&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/list&gt;--&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>&lt;mvc:message-converters register-defaults=”true”&gt;</strong>    </p>
<p>​    在说 <code>&lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;</code>之前要说一下</p>
<p><strong><code>@ResponseBody注解</code></strong></p>
<p>​    很明显这个注解是将方法的返回值作为response的body部分。首先就是方法返回的类型，可以是字节、数组、字符串、对象引用等，将这些返回类型以什么样的内容格式(即response的content-type类型，同时还要考虑到客户是否接受这个类型)存进response的body中返回给客户端是一个问题，对于    这个过程的处理都是靠许许多多的HttpMessageConverter转换器来完成的。</p>
<p>​    常用的content-type类型有：text/html、text/plain、text/xml、application/json、application/x-www-form-urlencoded、image/png等，不同的类型，对body中的数据的解析也是不一样的。 </p>
<p>​    &lt;mvc:message-converters register-defaults=”true”&gt;有一个register-defaults属性，当为true时，仍然注册默认的HttpMessageConverter，当为false则不注册，仅仅使用用户自定义的HttpMessageConverter。     </p>
<p>​    HttpMessageConverter主要针对那些不会返回view视图的response： </p>
<p>含有方法含有<strong>@ResponseBody</strong>或者返回值为<strong>HttpEntity</strong>等类型的，它们都会用到HttpMessageConverter。以@ResponseBody举例：</p>
<p>首先先决定由那个HandlerMethodReturnValueHandler来处理返回值，由于是@ResponseBody所以将会由RequestResponseBodyMethodProcessor来处理，选取一个合适的content-type，再由这个content-type和返回类型来选取合适的HttpMessageConverter，找到合适的HttpMessageConverter后，便调用它的write方法。 </p>
<p>这里是fastjson</p>
<h4 id="lt-mvc-default-servlet-handler-gt"><a href="#lt-mvc-default-servlet-handler-gt" class="headerlink" title="&lt;mvc:default-servlet-handler /&gt;"></a><code>&lt;mvc:default-servlet-handler /&gt;</code></h4><p>​    如果将DispatcherServlet请求映射配置为”/“，则Spring MVC将捕获Web容器所有的请求，包括静态资源的请求，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。</p>
<p>​    在springMVC-servlet.xml中配置&lt;mvc:default-servlet-handler /&gt;后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。</p>
<h4 id="mvc-view-controller"><a href="#mvc-view-controller" class="headerlink" title="mvc:view-controller"></a><code>mvc:view-controller</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">view-name</span>=<span class="string">"redirect:$&#123;shiro.loginUrl&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在springmvc中使用mvc:view-controller标签直接将访问url和视图进行映射，而无需要通过控制器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/IDEA使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/IDEA使用/" itemprop="url">IDEA使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T18:27:21+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index">
                    <span itemprop="name">IDEA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><h4 id="1、merge代码"><a href="#1、merge代码" class="headerlink" title="1、merge代码"></a>1、merge代码</h4><p><img src="/Users/mac/Library/Application Support/typora-user-images/image-20181122185526775.png" alt="image-20181122185526775"></p>
<p>2、</p>
<h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><h3 id="按键对应名称"><a href="#按键对应名称" class="headerlink" title="按键对应名称"></a>按键对应名称</h3><ul>
<li><p>⌘ Command</p>
</li>
<li><p>⇧ Shift</p>
</li>
<li><p>⌥ Option</p>
</li>
<li><p>⌃ Control</p>
</li>
<li><p>↩︎ Return/Enter</p>
</li>
<li><p>⌫ Delete</p>
</li>
<li><p>⌦ 向前删除键（Fn+Delete）</p>
</li>
<li><p>⇞ Page Up（Fn+↑）</p>
</li>
<li><p>⇟ Page Down（Fn+↓）</p>
</li>
<li><p>Home Fn + ←</p>
</li>
<li><p>End Fn + →</p>
</li>
<li><p>⇥ 右制表符（Tab键）</p>
</li>
<li><p>⇤ 左制表符（Shift+Tab）</p>
</li>
<li><p>⎋ Escape (Esc)</p>
</li>
</ul>
<h3 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键"></a>实用快捷键</h3><ul>
<li>Command+I :实现接口中的方法</li>
<li>Command+E:打开最近访问的文件</li>
<li>Command+SHIFT+E:最近编辑过的文件</li>
<li>Ctrl+H：显示当前类的子类</li>
<li>Ctrl+ENTER：getter和setter方法</li>
<li>Command+SHIFT+V：从剪切板中选择要粘贴的内容</li>
<li>Option+Command+L：格式化代码</li>
<li>Command+Shift+上下箭头：代码上下移动</li>
<li>Command+Alt+B:导航到一个抽象方法的实现代码</li>
<li>Command+Alt+T:包围代码(使用if..else,try..catch)</li>
<li>Command+U:打开父类方法</li>
<li>Ctrl+↑或↓：上下个方法</li>
<li>Command+7：查看当前类的所有方法</li>
<li>Command+5：打开Debug面板</li>
<li>Command+9：版本控制面板</li>
<li>Command+1：打开隐藏Project控制面板</li>
<li>Alt+Command+B：接口方法的实现</li>
<li>fn+option+F7 :查看调用该方法的类</li>
<li>control+shift+R:全局替换</li>
<li>Command + R:当前类替换</li>
<li>Command + 6 ：TODO</li>
<li>Shift+Command+Enter ： 行尾加分号</li>
</ul>
<h2 id="IDEA软件设置"><a href="#IDEA软件设置" class="headerlink" title="IDEA软件设置"></a>IDEA软件设置</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><h4 id="现在汉字为乱码"><a href="#现在汉字为乱码" class="headerlink" title="现在汉字为乱码"></a>现在汉字为乱码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># \u7248\u672C\u53F7</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/24977343/54085254-08d72f00-4377-11e9-9848-dbdcf09c6fe8.png" alt=""></p>
<p>勾选这里即可</p>
<h3 id="控制台中文乱码"><a href="#控制台中文乱码" class="headerlink" title="控制台中文乱码"></a>控制台中文乱码</h3><p><img src="/Users/mac/zero/img/image-20191220095854878.png" alt="image-20191220095854878"></p>
<p>设置在这里即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/英文提示不用怕/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/英文提示不用怕/" itemprop="url">英文提示不用怕</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T18:27:21+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>Could not resolve dependencies for project DD。     无法解决项目DD的依赖关系;</p>
<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resolve</td>
<td style="text-align:center">解析</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/Linux相关知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/Linux相关知识/" itemprop="url">Linux相关知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T19:09:01+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从纯净系统启动为止"><a href="#从纯净系统启动为止" class="headerlink" title="从纯净系统启动为止"></a>从纯净系统启动为止</h3><h4 id="挂在iso镜像"><a href="#挂在iso镜像" class="headerlink" title="挂在iso镜像"></a>挂在iso镜像</h4><ol>
<li>找到光盘的完整路径名，在命令行输入： ls -l /dev | grep cdrom</li>
<li>可以看到光盘的名字叫做： cdrom</li>
<li>mount /dev/cdrom /mnt 将镜像挂在到/mnt目录下</li>
<li>进入到Packages目录，在命令行输入：cd Packages。然后输入：ls -l | grep mysql。找到我们要拷贝出来的rpm包</li>
<li>卸载光盘 umount /mnt</li>
<li>安装rpm插件， rpm -ivh 软件包名</li>
</ol>
<h4 id="开关机和重启"><a href="#开关机和重启" class="headerlink" title="开关机和重启"></a>开关机和重启</h4><ol>
<li><p>关机命令： </p>
<ul>
<li>halt 立刻关机 </li>
<li>power off 立刻关机</li>
<li>shutdown -h now 立刻关机(root使用)</li>
<li>Shutdown -h 10 过十分钟关机。可以使用shutdown -c命令取消重启</li>
</ul>
</li>
<li><p>重启命令</p>
<ul>
<li><p>reboot</p>
</li>
<li><p>shutdown -r now 立即重启(root使用)</p>
</li>
<li><p>shutdown -r 10.   shutdown -c可以取消</p>
</li>
</ul>
</li>
</ol>
<h3 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h3><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p><strong>启动时携带的参数</strong></p>
<p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小，注意这里不是每页显示的行数<br>-i 忽略搜索时的大小写<br>-m 显示类似more命令的百分比<br>-N 显示每行的行号<br>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>-s 显示连续空行为一行<br>-S 行过长时间将超出部分舍弃</p>
<p><strong>启动后可以使用的参数</strong></p>
<p>/字符串：向下搜索”字符串”的功能<br>?字符串：向上搜索”字符串”的功能</p>
<p>n：重复前一个搜索（与 / 或 ? 有关）<br>N：反向重复前一个搜索（与 / 或 ? 有关）</p>
<p>b：向前翻动一页<br>空格：向后翻动一页</p>
<p>上箭头：向前翻动一行<br>下箭头：向下翻动一行</p>
<p>g：到文件开头<br>G：到文件结尾</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[resetPassword\] account :</span><br></pre></td></tr></table></figure>
<p>[]需要转译，所以加斜杠，否则查不出来。</p>
<p>q：退出less命令</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>lsof -i:端口号</p>
<p>kil -9 进程号</p>
<h4 id="查看当前服务器外网ip命令"><a href="#查看当前服务器外网ip命令" class="headerlink" title="查看当前服务器外网ip命令"></a>查看当前服务器外网ip命令</h4><p>curl <a href="https://ip.cn" target="_blank" rel="noopener">https://ip.cn</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/数据结构和算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/数据结构和算法/" itemprop="url">数据结构和算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T10:10:55+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么学习数据结构和算法？"><a href="#为什么学习数据结构和算法？" class="headerlink" title="为什么学习数据结构和算法？"></a>为什么学习数据结构和算法？</h2><ol>
<li>直接好处是能够有写出性能更优的代码</li>
<li>算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面</li>
<li>长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。</li>
</ol>
<p>我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。</p>
<p><strong>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。</strong></p>
<h2 id="带着问题去学习"><a href="#带着问题去学习" class="headerlink" title="带着问题去学习"></a>带着问题去学习</h2><ol>
<li>时间复杂和空间复杂度之间的互换</li>
<li>目前框架实现了很多功能，广泛而且好用，不用太担心性能问题。就好像司机不需要懂汽车的引擎原理，也能当顺风车司机载美女兜风，遇见不会的上Google，懒了就上GitHub找框架。但是这样写了多年代码，依然是菜鸟。</li>
<li></li>
</ol>
<h2 id="什么是数据结构和算法"><a href="#什么是数据结构和算法" class="headerlink" title="什么是数据结构和算法"></a>什么是数据结构和算法</h2><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一种方法。</p>
<p>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据机构之上。</p>
<p>数据结构上静态的，它只是组织数据的一种方式。如果不在它的基础上操作，构建算法，孤立存在的数据结构就是没用的。</p>
<p>数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。</p>
<p><strong>数据结构是为算法服务的，算法是要作用在特定的数据结构上的。</strong>因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p>
<h2 id="学习的重点"><a href="#学习的重点" class="headerlink" title="学习的重点"></a>学习的重点</h2><p>首先要掌握一个数据结构与算法中最重要的概念—复杂度分析。</p>
<p><img src="https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg" alt=""></p>
<p>复杂度分析：效率和资源消耗的度量衡</p>
<h3 id="最常用最基础的20个数据结构和算法："><a href="#最常用最基础的20个数据结构和算法：" class="headerlink" title="最常用最基础的20个数据结构和算法："></a>最常用最基础的20个数据结构和算法：</h3><p><strong>10个数据结构</strong></p>
<p>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</p>
<p><strong>10个算法</strong></p>
<p>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p>
<p>学习他们的：“来历”、“特点”、“适合解决什么问题”和“实际应用场景”</p>
<h3 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h3><ul>
<li>边学边练，使用代码表达出来</li>
<li>主动提问、多思考、多互动</li>
<li>自我激励，每次学完做一篇学习笔记</li>
<li>沉下心</li>
</ul>
<p>不需要死记硬背，要掌握分析的能力，要记住算法的特点、应用场景。用到了能想到就好。</p>
<h2 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h2><p>掌握了这些技巧，可以让你化被动为主动，学起来更加轻松，更加有动力！</p>
<p><strong>1.边学边练，适度刷题</strong></p>
<p>每周刷题，本周的讲解，自己用代码敲出来。</p>
<p><strong>2.多问、多思考、多互动</strong></p>
<p><strong>3.设置目标，就像打怪升级一样</strong></p>
<p><strong>4.知识需要沉淀，不要试图一下子掌握所有</strong></p>
<p>在学习的过程中，一定会碰到”拦路虎”。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。<strong>学习知识的过程是反复迭代、不断沉淀的过程。</strong></p>
<p>所谓读书百遍其义自见。</p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="复杂度分析-上-：如何分析、统计计算法的执行效率和资源消耗"><a href="#复杂度分析-上-：如何分析、统计计算法的执行效率和资源消耗" class="headerlink" title="复杂度分析(上)：如何分析、统计计算法的执行效率和资源消耗"></a>复杂度分析(上)：如何分析、统计计算法的执行效率和资源消耗</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>所有代码的执行时间T(n)与每行代码的执行次数n成正比</strong></p>
<p>T(n) = O(f(n))；</p>
<p>其中，T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。</p>
<p>所以，T(n) = O(2n+2)   这就是 <strong>大O时间复杂度表示法</strong>。大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示 <strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫做 <strong>渐进时间复杂度</strong>(asymptotic time complexity)，简称 <strong>时间复杂度</strong>。</p>
<p>当n很大时，我们可以把它想象成10000、100000。而这个时候公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果大O表示法表示刚讲的那两段代码的时间复杂度，就可以记为： T(n) = O(n)； T(n) = O(n²);</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>只关注循环执行次数最多的一段代码**</strong></li>
</ul>
<p>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。</p>
<p>所以上面代码总的时间复杂度就是  O(n)</p>
<ul>
<li><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></li>
</ul>
<p>总的时间复杂度等于量级最大的那段代码的时间复杂度。</p>
<p>如果T1(n) = O(f(n)),T2(n) = O(g(n));那么T(n) = T1(n)+T2(n) = max(O(f(n)),O(g(n))) = O(max(fn),g(n))).</p>
<ul>
<li><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></li>
</ul>
<p><strong>乘法法则</strong>适用于嵌套循环</p>
<p>如果T1(n) = O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)<em>T2(n)=O(f(n))乘以O(g(n))=O(f(n)</em>乘以g(n))。</p>
<p>也就是说，假设T1(n) = O(n),T2(n) = O(n²),则T1(n)*T2(n) = O(n³)。落实到具体的代码上，我们可以把乘法法则看成是 <strong>嵌套循环</strong>，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>负责度量级</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" alt=""></p>
<p>对于图上的复杂度量级，可以粗略的分为两类，<strong>多项式量级</strong>和 <strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2n立方)和O(n!)</p>
<p>时间复杂度的全称是：<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong></p>
<p>空间复杂度全称就是：渐进空间复杂度(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong></p>
<h4 id="常见的多项式时间复杂度"><a href="#常见的多项式时间复杂度" class="headerlink" title="常见的多项式时间复杂度"></a><strong>常见的多项式时间复杂度</strong></h4><p><strong>O(1)</strong></p>
<p>首先必须要明确一个概念，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是O(1)，而不是O(3)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure>
<p>只要代码的执行时间不随n的增大而增长，这样代码的时间复杂度我们都记作O(1)。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)</strong>。</p>
<p><strong>2.O(logn)、O(nlogn)</strong></p>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码可以看出，变量i的值从1开始取，每次循环一次就乘以2。当大于n时，循环结束。实际上，变量i的取值就是一个等比数列。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97.jpg" alt=""></p>
<p>所以，我们只要知道x值是多少，就知道这行代码执行的次数了。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%AF%B9%E6%95%B0" alt=""></p>
<p><strong>3.O（m+n）、O(m*n)</strong></p>
<p>代码的复杂度 <strong>由两个数据的规模</strong>来决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。</p>
<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法法则改为:T1(m)+T2(n) = O(f(m)+g(n))。但是乘法法则继续有效:T1(m)<em>T2(n) =O(f(m)</em>f(n)).</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>时间复杂度的全称是 <strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</strong>类比一下，空间复杂度全称就是 <strong>渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟时间复杂度分析一样，我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。</p>
<p>我们常见的空间复杂度分析比时间复杂度分析要简单很多。</p>
<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，<strong>用来分析算法执行效率与数据规模之间的增长关系</strong>，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：</p>
<ul>
<li>O(1)            常数阶</li>
<li>O(logn)           对数阶忽略系数，同理O(log2n) 就等于 O(log3n)。因此在对数阶时间复杂度的表示方法里，我们忽略对数的”底”，统一表示为O(logn)</li>
<li>O(n)                线性阶                </li>
<li>O(nlogn)        线性对数阶 循环了n遍的O(logn)</li>
<li>O(n²)               平方阶  嵌套循环n</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt=""></p>
<p><strong>复杂度分析并不难，关键在于多练</strong></p>
<h3 id="课后总结"><a href="#课后总结" class="headerlink" title="课后总结"></a>课后总结</h3><p>重点在于在编程的时候，要具有这种复杂度分析的思维。</p>
<h4 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h4><ul>
<li>复杂度分析：如何让计算机更快时间、更省空间的解决问题</li>
<li>需要从执行时间和占用空间两个维度来评估数据结构和算法的性能</li>
<li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度</li>
<li>复杂度描述的是算法执行时间(或执行效率)与数据规模的增长关系</li>
</ul>
<h4 id="为什么要进行复杂度分析"><a href="#为什么要进行复杂度分析" class="headerlink" title="为什么要进行复杂度分析"></a>为什么要进行复杂度分析</h4><ul>
<li>与性能测试相比，复杂度分析不依赖执行环境、易操作、指导性强</li>
<li>有利于降低系统开发和维护成本</li>
<li>不同的测试环境测试结果不同，受硬件和数据量的影响。而复杂度分析是独立于环境的，两者并不冲突。</li>
</ul>
<h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>来源：</p>
<ul>
<li>算法的执行时间与每行代码的执行次数成正比，用T(n)=O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模</li>
</ul>
<p>特点：</p>
<ul>
<li>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</li>
</ul>
<p>分析法则：</p>
<ul>
<li>单段看高频：比如循环</li>
<li>多段取最大：比如有单循环和多重循环，那么取多重循环的复杂度</li>
<li>嵌套求乘积：比如递归、多重循环等</li>
<li>多参求加：两个参数控制循环，取二者复杂度相加</li>
</ul>
<p>O是一个数学符号，不是代表一个英文单词。</p>
<p>进行复杂度分析主要是提升自己分析复杂度的思维和效率的认知。</p>
<p>就像程序员用设计模式来讨论代码设计一样，说出名字就知道代码是如何组织的，大O也是一样。</p>
<p>摆脱底层码农的处境。</p>
<p>空间复杂度和时间复杂度的区别：一个是表示内存的消耗，一个是表示执行的快慢。</p>
<p>疑问：每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？</p>
<p>1、开发过程中，码代码的过程中就能得出其复杂度，这并不会太多浪费时间，同时只有分析了每段代码的复杂度，才能估算出它们的执行效率。</p>
<p>2、优化代码时，只有在分析每段代码的复杂度后，才能定位问题代码，才能做出相应优化</p>
<h2 id="复杂度分析（下）：：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：：浅析最好、最坏、平均、均摊时间复杂度</h2><h3 id="今天的内容"><a href="#今天的内容" class="headerlink" title="今天的内容"></a>今天的内容</h3><ul>
<li>最好情况时间复杂度</li>
<li>最坏情况时间复杂度</li>
<li>平均情况时间复杂度</li>
<li>均摊时间复杂度</li>
</ul>
<h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><p>最好时间复杂度：O(1)    数组第一个就可以找到想要的</p>
<p>最坏时间复杂度：O(n)    整个数组循环了一遍没找到</p>
<p>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示</p>
<p>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别复杂度上。基本上均摊结果等于低级别复杂度。</p>
<h3 id="如何分析平均、均摊时间复杂度"><a href="#如何分析平均、均摊时间复杂度" class="headerlink" title="如何分析平均、均摊时间复杂度"></a>如何分析平均、均摊时间复杂度</h3><ul>
<li>平均时间复杂度<ul>
<li>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示</li>
</ul>
</li>
<li>均摊时间复杂度<ul>
<li>两个条件满足时使用：<ul>
<li>代码在绝大多数情况下是低阶别复杂度，只有极少数情况是高级别复杂度</li>
<li>低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一般情况下平均和均摊说一个就好了</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="如何理解栈"><a href="#如何理解栈" class="headerlink" title="如何理解栈"></a>如何理解栈</h2><p>就一摞叠起来的盘子。平放盘子的时候，都是从下往上一个个的放；取的时候，我们也是从上往下一个个的取，不能从中间任意抽取。<strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p>
<p>从栈的操作特性上来看，<strong>栈上一种“受限操作”的线性表，</strong>只允许在一端插入和删除数据。</p>
<p>实际上，从功能上来说，数组和链表确实可以替代栈，但是特定的数据结构上对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就容易出错。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p>
<p>栈既可以通过数组实现也可以通过链表实现。不管基于数组还是链表，入栈、出栈的时间复杂度都是为O(1)。</p>
<p>Java中常用方法：</p>
<ul>
<li>E push(E item)    将item压入栈并返回item</li>
<li>E pop()  弹出并返回栈顶的item。如果栈为空，请不要调用这个方法</li>
<li>E peek ()  返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法</li>
</ul>
<p><strong>思考</strong>    </p>
<ol>
<li><p>为什么函数调用要用栈来保存临时变量呢？其他数据结构不行吗？</p>
<p>答：程序运行中有两个存储空间可用，一个是栈，归属于进程本身的，另外一个是堆，所有进程共用的。</p>
<p>猜测：1.防止CPU迷路 2.函数调用经常嵌套，A调用B，B又调用C，那么就需要先把C执行完，结果赋给B中的临时变量，B的执行结果再赋给A的临时变量，嵌套越深的函数就越需要最先执行，这样刚好符合栈的特点，因此每次遇到函数调用，只需要压栈，最后依次从栈顶弹出依次执行即可。</p>
</li>
<li><p>JVM内容管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储Java中的对象。那JVM里面的”栈”跟我们这里说的”栈”是不是一回事呢？如果是，那它们为什么又叫做”栈”呢？</p>
</li>
</ol>
<h1 id="队列：队列在线程池等有限资源池中的应用"><a href="#队列：队列在线程池等有限资源池中的应用" class="headerlink" title="队列：队列在线程池等有限资源池中的应用"></a>队列：队列在线程池等有限资源池中的应用</h1><h2 id="如何理解”队列”"><a href="#如何理解”队列”" class="headerlink" title="如何理解”队列”"></a>如何理解”队列”</h2><p>可以把它想象成买票，先来的先买，后来的人后买。<strong>先进者先出，这就是典型的”队列”</strong></p>
<p>最基本的两个操作：<strong>入队enqueue()</strong>，放一个数据到队列尾部；<strong>出对dequeue()</strong>,从队列头部去除一个元素。</p>
<p><img src="https://static001.geekbang.org/resource/image/9e/3e/9eca53f9b557b1213c5d94b94e9dce3e.jpg" alt=""></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>​    例子：用户A推荐用户B来注册，用户B又推荐了用户C来注册。我们可以说，用户C的”最终推荐人”为用户A，用户B的”最终推荐人”也为用户A，而用户A没有”最终推荐人”。</p>
<p>​    <img src="https://static001.geekbang.org/resource/image/29/0e/2984d45578440e9a348144c70d124a0e.jpg" alt=""></p>
<p>给定一个用户ID，如何查找这个用户的”最终推荐人”?</p>
<h2 id="如何理解递归"><a href="#如何理解递归" class="headerlink" title="如何理解递归"></a>如何理解递归</h2><p>数据结构最难理解的知识点，一个是 <strong>动态规划</strong>，另一个是 <strong>递归</strong>。</p>
<p>递归是有一个 <strong>递</strong> 和一个 <strong>归</strong> 的过程。</p>
<h2 id="递归需要满足三个条件"><a href="#递归需要满足三个条件" class="headerlink" title="递归需要满足三个条件"></a>递归需要满足三个条件</h2><p>那么什么样的问题可以用递归来解决呢？有三个条件，只要满足以下三个条件，就可以用递归来解决。</p>
<p><strong>1.一个问题的解可以分解为几个子问题的解</strong></p>
<p>子问题就是数据规模更小的问题。比如，电影院的例子，要知道，”自己”在那一排的问题，可以分解为”前一排的人在哪一排”这样的子问题。</p>
<p><strong>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p>
<p>比如电影院的例子，你求解”自己在那一排”的思路，和前面一排人求解”自己在那一排”的思路，是一模一样的。</p>
<p><strong>3.递归终止条件</strong></p>
<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>
<p>比如电影院的例子，第一排的人不需要再继续询问任何人。f(1) = 1,这就是递归的终止条件。</p>
<h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>写递归代码最关键的是 <strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就简单了。</p>
<p>例子：上n个台阶的楼梯。每次只能上1个台阶或2个台阶。那么总共有多少种走法呢？</p>
<p>我们仔细想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1台阶后，n-1个台阶的走法加上先走2个台阶后，n-2个台阶的走法。用公式表示就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>有了递推公式，再看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1) = 1。这个递归的终止条件足够吗？我们可以用n=2，n=3这样比较小的数试验一下。</p>
<p>n=2时，f(2)=f(1)+f(0)。如果递归终止条件只有一个f(1)=1,那f(2)就无法求解了。所以除了f(1)=1这一个终止条件外还要有f(0)=1,表示走0个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们把f(2)=2作为一种终止条件，表示走2个台阶，有两种走法，一步走完或者两步走完。</p>
<p>所以，递归终止的条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3,n=4来验证一下，这个终止条件十分足够并且正确。</p>
<p>递归终止条件和递推公式组合一起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>)=<span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>)=<span class="number">2</span>;</span><br><span class="line">f(n)=f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最终递归代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：<strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong></p>
<p>计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p>
<p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式该是怎样的呢？</p>
<p>如果一个问题A可以分解为若干子问题B、C、D，你可以假设子问题B、C、D已经解决，再次基础上思考如何解决问题A。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>
<p>因此，<strong>编写递归的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p>
<h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？</p>
<p>在”栈”那一节中，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>比如前面电影院的例子，如果我们将系统栈或者JVM堆栈大小设置为1KB，在求解f(19999)时便会出现如下堆栈报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<p>那么，如何避免出现堆栈溢出呢？</p>
<p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，我们就不继续往下再递归了，直接返回报错。还是电影院的例子，我们可以改成成下面的样子，就可以避免堆栈溢出了。不过，我写的代码是伪代码，边界没有考虑，比如x&lt;=0;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种做法并不能完全解决问题，因为最大允许的递归深度根当前线程剩余的栈空间大小有关，实现无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不是很实用。</p>
<h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，实用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把这个递归过程分解一下的话，那就是这个样子的：</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg" alt=""></p>
<p>从图中，我们可以直观地看到，想计算f(5)，需要计算机f(4)和f(3)，而计算f(4)还需要计算f(3)，因此f(3)就被计算了很多次，这就是重复计算问题。</p>
<p>为了避免重复计算，我们可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>
<p>按照上面的思路，我们来改造一下刚才的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了堆栈溢出、重复计算这两个常见问题。递归代码还有很多别的问题。</p>
<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是O(1)，而是O(n).</p>
<h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们根据实际情况来选择是否需要用递归的方式来实现。</p>
<p>只看f(x) = f(x-1)+1这个递推公式。可以改写为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么是不是所有的递归代码都可以改为这种 <strong>迭代循环</strong>的非递归写法呢？</p>
<p>笼统的将，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们在内存堆栈上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改成成看上去不是递归代码的样子。</p>
<p>但是这种思路实际上是将递归改为了”手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>如何找到”最终推荐人”</p>
<p>解决方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">  <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) <span class="keyword">return</span> actorId;</span><br><span class="line">  <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c</p>
<p>是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里有两个问题。</p>
<p>第一，如果递归很深，可能会有堆栈溢出的问题</p>
<p>第二，如果数据库里存在在脏数据，我们还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C的推荐人又是A，这样就会发生死循环。</p>
<p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测A-B-C-A这种”环”的存在。如何来检测环的存在呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归是一种非常高效、简洁的编码技巧。只要是满足”三个条件”的问题就可以通过递归代码来解决。</p>
<p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p>
<p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们平时调试代码喜欢使用IDE的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有神马好的调试方法呢？</p>
<h1 id="排序-上-：为什么插入排序比冒泡排序更受欢迎？"><a href="#排序-上-：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="排序(上)：为什么插入排序比冒泡排序更受欢迎？"></a>排序(上)：为什么插入排序比冒泡排序更受欢迎？</h1><p>最经典、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p>
<p>按照时间复杂度把它们分成了三类，分三节课来讲解。</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg" alt=""></p>
<p>思考题：<strong>插入排序和冒泡排序的时间复杂度相同，都是O(n²)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</strong></p>
<h2 id="如何分拆一个”排序算法”？"><a href="#如何分拆一个”排序算法”？" class="headerlink" title="如何分拆一个”排序算法”？"></a>如何分拆一个”排序算法”？</h2><p>学习排序算法,我们除了学习它的算法原理、代码实现之外，更重要的是学会如何评价、分析一个排序算法。那分析一个排序算法，要从那几个方面下手呢？</p>
<h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><p>一般从几个方面来衡量</p>
<h4 id="最好情况、最坏情况、平均情况时间复杂度"><a href="#最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="最好情况、最坏情况、平均情况时间复杂度"></a>最好情况、最坏情况、平均情况时间复杂度</h4><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p>
<p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p>
<h4 id="时间复杂度的系数、常数、低阶"><a href="#时间复杂度的系数、常数、低阶" class="headerlink" title="时间复杂度的系数、常数、低阶"></a>时间复杂度的系数、常数、低阶</h4><p>时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p>
<h4 id="比较次数和交换-或移动-次数"><a href="#比较次数和交换-或移动-次数" class="headerlink" title="比较次数和交换(或移动)次数"></a>比较次数和交换(或移动)次数</h4><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，我们在分析排序算法的执行效率的时候，应该把比较次数和交换(或移动)次数也考虑进去。</p>
<h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序(Sorted in place)</strong>。原地排序算法，就是特指空间复杂度是O(1)的排序算法。今天的三种排序算法，都是原地排序算法。</p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>例如：2，3，3，4，8，9</p>
<p>这组数据中有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫做 <strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫做 <strong>不稳定的排序算法</strong>。</p>
<p>例如订单：订单有两个属性，一个是下单时间，另一个是订单金额。我们希望按照金额从小到大对订单数据排序。</p>
<p>对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p>
<p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，而不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。</p>
<p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong> 第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F.jpg" alt=""></p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</p>
<p>用一个例子，看排序的过程。对一组数据4，5，6，3，2，1，从小到大进行排序。第一冒泡操作的详细过程就是这样：</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%92%E6%B3%A1.jpg" alt=""></p>
<p>可以看出，经过一次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行6次这样的冒泡操作就行了。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E7%BB%93%E6%9E%9C%E5%9B%BE.jpg" alt=""></p>
<p>冒泡过程可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。这里给6个元素排序，只需要4次冒泡操作就可以了。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个问题：</p>
<p><strong>第一，冒泡排序是原地排序算法吗？</strong></p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p>
<p><strong>第二，冒泡排序是稳定的排序算法吗？</strong></p>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<p><strong>第三，冒泡排序的时间复杂度是多少？</strong></p>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行n次冒泡操作，所以最坏情况时间复杂度为O(n²)。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5.jpg" alt=""></p>
<p>平均情况时间复杂度是多少呢？平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。</p>
<p>对于包含n个数据的数组，这n个数据就有n！种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如进行6次冒泡的，这里只需要4次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。通过 <strong>有序度</strong> 和 <strong>逆序度</strong> 这两个概念来进行分析。</p>
<p><strong>有序度</strong> 是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E6%9C%89%E5%BA%8F%E5%BA%A6%E7%A4%BA%E4%BE%8B.jpg" alt=""></p>
<p>同理，对于一个倒序排列的数组，比如6，5，4，3，2，1，有序度是0；对于一个完全有序的数组，比如1，2，3，4，5，6，有序度就是 <strong>n*(n-1)/2</strong>，也就是15。我们把这种完全有序的数组的有序度叫做 <strong>满有序度</strong>。</p>
<p>逆序度的定义跟有序度相反（默认从小到大为有序）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure>
<p>可以得到一个公式： <strong>逆序度=满有序度 - 有序度</strong>。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p>
<p>例子：要排序的数组的初始状态是 4，5，6，3，2，1，其中，有序元素对有(4,5),(4,6),(5,6)，有序度为3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E6%9C%89%E5%BA%8F%E5%BA%A6%E5%88%86%E6%9E%90.jpg" alt=""></p>
<p>冒泡排序包含两个操作原子，<strong>比较</strong>和 <strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为 <strong>逆序度，也就是n*(n-1)/2 - 初始有序度</strong>。此例中就是 15 -3 =12，要进行12次交换操作。</p>
<p>平均情况下，需要 n*(n-1)/4次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是O(n²)，所以平均情况下的时间复杂度就是O(n²)。</p>
<p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，比较概率论的定量分析太复杂，不太好用。</p>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><p>插入排序包含两种操作，一种是 <strong>元素的比较</strong>，一种是 <strong>元素的移动</strong>。当我们需要将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素a插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一，插入排序是原地排序算法吗？</strong></p>
<p>从实现过程可以很明显的看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p>
<p><strong>第二，插入排序是稳定的排序算法吗？</strong></p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的顺序不变，所以插入排序是稳定的排序算法。</p>
<p><strong>第三，插入排序的时间复杂度是多少？</strong></p>
<p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据㐇能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是 <strong>从头到尾遍历已经有序的数据</strong>。</p>
<p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为O(n²)。</p>
<p>对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n²)。</p>
<h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p>
<p>选择排序空间复杂度为O(1),是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n²)。</p>
<p>选择排序不是稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<p>比如5，8，5，2，9这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素2，与第一个5交换位置，那第一个5和中间的5顺序就变了，所以就不稳定了。正式因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<h2 id="解答开篇-1"><a href="#解答开篇-1" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>冒泡排序和插入排序的时间复杂度都是O(n²)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p>
<p>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p>
<p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把执行一个赋值语句的时间粗略地计为单位时间(unit_time)，然后分别用冒泡排序和插入排序对同一个逆序度是K的数组进行排序。用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间。</p>
<p>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n²),但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。自学  <strong>希尔排序</strong></p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94.jpg" alt=""></p>
<p>这三种时间复杂度为O(n²)的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。后面讲排序优化的时候，有些编程语言中的排序函数的实现原理会用到插入排序算法。</p>
<p>这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为O(nlogn)的排序算法。</p>
<h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>特定算法是依赖特定的数据结构的。这三种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/Git使用学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/Git使用学习/" itemprop="url">Git使用学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T15:10:49+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fshrh2oexpj31kw0wkgsx.jpg" alt=""></p>
<p> branch 查看当前分支</p>
<h2 id="查看本地和远端所有分支"><a href="#查看本地和远端所有分支" class="headerlink" title="查看本地和远端所有分支"></a>查看本地和远端所有分支</h2><p>git branch -a</p>
<p>工作区    暂存区    版本库    三种状态</p>
<p>push.  </p>
<p>push origin master </p>
<p>其中origin是指的远程仓库，master 是本地仓库默认名称</p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><ol>
<li>master分支下  pull下最新的代码</li>
<li>git checkout -b  &lt;分支名&gt;    :在本地新建分支</li>
<li>git push origin &lt;分支名&gt;   :向远端提交分支</li>
<li>git branch –set-upstream-to=origin/&lt;分支名&gt;  &lt;分支名&gt;     ：设置head为远程仓库的master</li>
<li>git status</li>
</ol>
<h2 id="提交代码到分支"><a href="#提交代码到分支" class="headerlink" title="提交代码到分支"></a>提交代码到分支</h2><ol>
<li>git checkout 分支名</li>
<li>git    add 文件名                ：添加文件到缓存</li>
<li>git rm —cached  :从缓存中去除文件</li>
<li>git commit :提交</li>
<li>git push :推送到远程分支</li>
</ol>
<h2 id="合并分支与master的代码"><a href="#合并分支与master的代码" class="headerlink" title="合并分支与master的代码"></a>合并分支与master的代码</h2><ol>
<li>git branch -vv :本地分支跟踪的远程分支</li>
<li>git fetch origin –prune :GitLab更新远程分支信息</li>
</ol>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支；</span><br><span class="line"><span class="meta">$</span> git fetch origin master:temp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 比较本地代码与刚刚从远程下载下来的代码的区别；</span><br><span class="line"><span class="meta">$</span> git diff temp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 合并temp分支到本地的master分支;</span><br><span class="line"><span class="meta">$</span> git merge temp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 如果不想保留temp分支，删除;</span><br><span class="line"><span class="meta">$</span> git branch -d temp</span><br></pre></td></tr></table></figure>
<h4 id="直接使用-git-fetch-命令"><a href="#直接使用-git-fetch-命令" class="headerlink" title="直接使用 git fetch 命令"></a>直接使用 git fetch 命令</h4><ul>
<li>创建并更新本地远程分支。即创建并更新origin/xxx 分支，拉取代码到origin/xxx分支上;</li>
<li>在FETCH_HEAD中设定当前分支-origin/当前分支对应，如直接到时候git merge就可以将origin/abc合并到abc分支上</li>
</ul>
<h4 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h4><ul>
<li>手动指定了要fetch的remote。在不指定分支时通常默认为master；</li>
</ul>
<h4 id="对比git-pull"><a href="#对比git-pull" class="headerlink" title="对比git pull"></a>对比git pull</h4><p>与git pull相比git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷;</p>
<h2 id="回滚到指定commit，丢弃commit之后的提交记录"><a href="#回滚到指定commit，丢弃commit之后的提交记录" class="headerlink" title="回滚到指定commit，丢弃commit之后的提交记录"></a>回滚到指定commit，丢弃commit之后的提交记录</h2><p>查看历史提交：  git log | head -n 40</p>
<p>1、git reset –hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96   回滚到某个版本</p>
<p>2、git push -f -u origin &lt;分支名&gt;   ：强制提交到分支，覆盖远程分支</p>
<h2 id="git-add-添加了不需要的文件，想撤销上一步操作"><a href="#git-add-添加了不需要的文件，想撤销上一步操作" class="headerlink" title="git add 添加了不需要的文件，想撤销上一步操作"></a>git add 添加了不需要的文件，想撤销上一步操作</h2><p><code>git reset HEAD</code></p>
<p>后面什么都不跟的话 就是上一次add里面的全部撤销掉</p>
<p><code>git reset HEAD xxxx.java</code>就是对某个文件进行撤销</p>
<h2 id="删除分支以及远程分支"><a href="#删除分支以及远程分支" class="headerlink" title="删除分支以及远程分支"></a>删除分支以及远程分支</h2><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a><strong>删除远程分支</strong></h3><p>git push origin –delete  &lt;–分支名–&gt;</p>
<p>git branch -a    //查看分支</p>
<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a><strong>删除本地分支</strong></h3><p>git branch -D &lt;—分支名–&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Mybatis/" itemprop="url">Mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T18:27:21+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="全局参数配置"><a href="#全局参数配置" class="headerlink" title="全局参数配置"></a>全局参数配置</h3><h4 id="批量起别名"><a href="#批量起别名" class="headerlink" title="批量起别名"></a>批量起别名</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.zero.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认是OTHER这里改为NULL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"NULL"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启驼峰命名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Mybatis参数"><a href="#Mybatis参数" class="headerlink" title="Mybatis参数"></a>Mybatis参数</h3><h4 id="主要参数的意义"><a href="#主要参数的意义" class="headerlink" title="主要参数的意义"></a>主要参数的意义</h4><p>property:对应到javaBean中的值</p>
<p>column:指定数据库中那一列的值</p>
<p>javaType:列值对应的java类型</p>
<p>discriminator:标签鉴别器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--获取自增主键的值</span></span><br><span class="line"><span class="comment">    useGeneratedKeys 使用自增主键获取主键值策略</span></span><br><span class="line"><span class="comment">    keyProperty : 指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的那个属性</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmployee"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into tb_user (name,address)</span><br><span class="line">    values</span><br><span class="line">    (#&#123;name&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h4><p>多个参数会被封装成一个map，#{}就是从map中获取指定的key的值。</p>
<p>key是param</p>
<p>value是传入的值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    select * from tb_user where id = #&#123;param1&#125; and name = #&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个参数的时候可以命名参数：明确指定封装参数时map的key。@Param(“”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlogByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String name)</span>;</span><br></pre></td></tr></table></figure>
<p>key：使用@Param注解指定的值</p>
<p>value:参数值</p>
<p>#{指定的key}取出对应的参数值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    select * from tb_user where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>d</span><br></pre></td></tr></table></figure>
<h4 id="以Map为参数集合"><a href="#以Map为参数集合" class="headerlink" title="以Map为参数集合"></a>以Map为参数集合</h4><p>如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo</p>
<p>#{属性名}：取出传入pojo的属性值</p>
<p>如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用为了方便，我们可以传入map</p>
<p>#{key}:取出map中对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlogByMap</span><span class="params">(Map&lt;String,String&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByMap"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    select *  from tb_user where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"id"</span>,<span class="string">"4"</span>);</span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">Blog blog = mapper.getBlogByMap(map);</span><br></pre></td></tr></table></figure>
<h4 id="编写专门的TO"><a href="#编写专门的TO" class="headerlink" title="编写专门的TO"></a>编写专门的TO</h4><p>如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO(Transfer Object)数据传入对象</p>
<p>Page{</p>
<p>​    int index;</p>
<p>​    int size;</p>
<p>}</p>
<h4 id="传参处理"><a href="#传参处理" class="headerlink" title="传参处理"></a>传参处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlog</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id,  String name)</span>;</span><br></pre></td></tr></table></figure>
<p>取值：id==&gt;#{id/param1}   name ==&gt; #{param2}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlog</span><span class="params">(Integer id,  @Param(<span class="string">"e"</span>)</span>Blog blog)</span>;</span><br></pre></td></tr></table></figure>
<p>取值：id ==&gt; #{param1}   name ==&gt;  #{param2.name/e.name}</p>
<p>特别注意：如果是Collection (List、Set) 类型或者数组，也会特殊处理。也是把传入的list或者数组封装在map中，</p>
<p>key：Collection(collection),如果是List还可以使用这个key(list)</p>
<p>数组(array)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Blog <span class="title">getBlogById</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取值：取出第一个id的值: #{list[0]}   不能写ids或者param1</p>
<h3 id="和-取值"><a href="#和-取值" class="headerlink" title="#和$取值"></a>#和$取值</h3><p>#{}和${}都可以取map或者pojo的值</p>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> tb_blog <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">name</span> = ?</span><br></pre></td></tr></table></figure>
<p>区别：</p>
<p>​    #{}：是以预编译的形式，将参数设置到sql语句中；？PreparedStatement  防止sql注入</p>
<p>​    ${}：取出的值直接拼装在sql语句中；会有安全问题，无法防止sql注入</p>
<p>大多情况下取参数的值都应该使用#{}；</p>
<p>比如分表、排序：按照年份拆分</p>
<p>​    select * from 2016(2017)_year</p>
<p>年份不确定，原生jdbc不支持占位符的地方我们可以使用${}进行取值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> $&#123;<span class="keyword">year</span>&#125;_salary <span class="keyword">where</span> xxx;</span><br></pre></td></tr></table></figure>
<p>#{}只能取出参数中的值</p>
<p>#{}：更丰富的用法：</p>
<p>规定参数的一些规则：</p>
<p>javaType、jdbcType、mode(存储过程)、numericScale、</p>
<p>resultMap、typeHandler、jdbcTypeName、expression</p>
<p>jdbcType：通常要在某种特定的条件下设置；</p>
<p>​    在我们的数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如oracle：为null时会报错，这个时候要处理这个报错告知mybatis。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = <span class="keyword">new</span> Blog(<span class="keyword">null</span>,<span class="string">"lisi"</span>,<span class="string">"null"</span>);</span><br><span class="line">mapper.addBlog(blog);</span><br></pre></td></tr></table></figure>
<p>​    如果是oracle会报错：无效的类型。不能区分出null的类型。JdbcType OTHER：无效的类型</p>
<p>而mysql的没有问题的。因为mybatis对所有的null都映射的是JDBC OTHER类型。</p>
<p>当jdbcType为null时，默认为OTHER。这个OTHER  oracle不认识。由于全局配置中，jdbcTypeForNull = OTHER</p>
<p>1、#{enmail,jdbcType=OTHER} 只会影响当前sql语句的jdbcType</p>
<p>2、直接改全局配置，将全部的jdbcTypeForNull改为null</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认是OTHER这里改为NULL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"NULL"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个NULL，oracle和mysql都可识别。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>select元素来定义查询操作</p>
<p>id:唯一标识符</p>
<p>-用来引用这条语句，需要和接口的方法名一致</p>
<p>parameterType：参数类型</p>
<p>-可以不传，Mybatis会根据TypeHandler自动推断</p>
<p>resultType：返回值类型</p>
<p>-别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Blog&gt; <span class="title">getBlogByNameLike</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--resultType:如果返回值类型是一个集合，要写集合中元素的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByNameLike"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">  select * from tb_user where name like #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">            BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="comment">//            Blog blog = new Blog(null,"zhangsan","Beijing");</span></span><br><span class="line">            List&lt;Blog&gt; like = mapper.getBlogByNameLike(<span class="string">"%z%"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Blog blog : like)&#123;</span><br><span class="line">                System.out.println(blog);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>resultType为com.zero.dao.Blog时，jdbc会将数据封装为Blog然后返回。</p>
<h4 id="select记录封装map"><a href="#select记录封装map" class="headerlink" title="select记录封装map"></a>select记录封装map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">//告诉mybatis封装这个map的时候使用哪个属性作为map的key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Blog&gt; <span class="title">getBlogByNameLikeReturnMap</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>@MapKey是指定封装这个map的时候哪个属性作为封装Map的key</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String,Blog&gt;   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByNameLikeReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    select * from tb_user where name like #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Blog&gt; map = mapper.getBlogByNameLikeReturnMap(<span class="string">"%w%"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="自定义结果映射规则-resultMap"><a href="#自定义结果映射规则-resultMap" class="headerlink" title="自定义结果映射规则 resultMap"></a>自定义结果映射规则 resultMap</h4><ol>
<li><p>如果查出的列明和javaBean的属性名不一样，需要写别名，或者如果符合驼峰命名法则开启驼峰命名</p>
<ul>
<li><p>autoMappingBehavior默认是PARTIAL，开启自动映射的功能。唯一的要求是列名和javaBean属性名一致</p>
</li>
<li><p>如果autoMappingBehavior设置为null则会取消自动映射</p>
</li>
<li><p>数据库字段命名规范，POJO属性符合驼峰命名法，如A_COLUMN-&gt;aColumn，我们可以开启自动驼峰命名规则映射功能</p>
</li>
<li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启驼峰命名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>此外resultMap还可以指定自定义结果集映射规则</p>
<p>如何定义规则：在该mapper标签中最上面自定义某个javaBean的封装规则</p>
<p>如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.zero.dao.BlogMapperPlus"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义某个javaBean的封装规则</span></span><br><span class="line"><span class="comment">        type：自定义规则的Java类型</span></span><br><span class="line"><span class="comment">        id：唯一id方便引用</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyBlog"</span> <span class="attr">type</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定主键的封装规则</span></span><br><span class="line"><span class="comment">        id：定义主键会底层有优化</span></span><br><span class="line"><span class="comment">        column:指定那一列</span></span><br><span class="line"><span class="comment">        property：指定对应的javaBean属性</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义普通列封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其他不指定的列会自动封装，但是只要写resultMap就要把全部的映射规则都写上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogById"</span> <span class="attr">resultMap</span>=<span class="string">"MyBlog"</span>&gt;</span></span><br><span class="line">        select * from tb_user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="resultMap关联查询"><a href="#resultMap关联查询" class="headerlink" title="resultMap关联查询"></a>resultMap关联查询</h4><p>如果Blog中包含部门对象</p>
<p>现在的要求是在查出这个对象的同时查出其所在的部门</p>
<p>Department</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_dept(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_user <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> d_id <span class="built_in">INT</span>(<span class="number">11</span>);</span><br></pre></td></tr></table></figure>
<p>创建tbl_dept表并为tb_user表添加一列d_id</p>
<p>现在为tb_user的d_id属性添加外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_user <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_user_dept</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(d_id) <span class="keyword">REFERENCES</span> tbl_dept(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<p>外键名称为fk_user_dept，将d_id的外键设置为tbl_dept的id属性。</p>
<p>此时想要查询出所有信息有两种方法：</p>
<p>1、外键关联</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--联合查询：级联属性封装结果--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyResult"</span> <span class="attr">type</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">        property="dept" 指定那个属性是联合对象</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"dept.id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"dept.departmentName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogAndDeptById"</span> <span class="attr">resultMap</span>=<span class="string">"MyResult"</span>&gt;</span></span><br><span class="line">      select e.id id,e.name name ,e.address address,d.id did,d.dept_name dept_name from tb_user e,tbl_dept d</span><br><span class="line">      where e.d_id=d.id and e.id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方法2：association标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--联合查询：级联属性封装结果--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyResult"</span> <span class="attr">type</span>=<span class="string">"com.zero.dao.Blog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">        property="dept" 指定那个属性是联合对象</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span>  <span class="attr">javaType</span>=<span class="string">"com.zero.dao.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">"mybatis/mybatis-config.xml"</span>;</span><br><span class="line">    InputStream is = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">    SqlSession session = sessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BlogMapperPlus mapper = session.getMapper(BlogMapperPlus.class);</span><br><span class="line">        Blog blog = mapper.getBlogAndDeptById(<span class="number">5</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line">        System.out.println(blog.getDept());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：这里测试的时候有报错信息：No constructor found in</p>
<p>Bean里面有一个全参数的构造函数，但是字段类型不匹配。</p>
<p>此时需要检查两个相互关联的javaBean是否有构造方法，如果设置了有参的构造方法，那么还需要有默认的无参构造。两个javaBean都需要。</p>
<p>方法三：association分布查询</p>
<p>先查询user然后拿到d_id之后再去部门里查询部门信息，这就可以写两个sql。一个比较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BlogMapperPlus.xml</span><br><span class="line">    <span class="comment">&lt;!--使用association进行分步查询</span></span><br><span class="line"><span class="comment">        1、先按照员工id查询员工信息</span></span><br><span class="line"><span class="comment">        2、根据查询员工信息中的d_id值去部门表查出部门信息</span></span><br><span class="line"><span class="comment">        3、部门设置员工中</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyResult1"</span> <span class="attr">type</span>=<span class="string">"com.zero.bean.Blog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        association定义关联的对象的封装规则.dept的值是调用查询方法查出来的.</span></span><br><span class="line"><span class="comment">        select:表明当前的属性是调动select指定的方法查出的结果</span></span><br><span class="line"><span class="comment">        column:指定将哪一列的值传递给这个方法</span></span><br><span class="line"><span class="comment">        流程：使用select指定的方法(传入column指定的这列参数的值)查出对象，并封装给property指定的属性</span></span><br><span class="line"><span class="comment">        --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">select</span>=<span class="string">"com.zero.dao.DepartmentMapper.getDeptById"</span> <span class="attr">column</span>=<span class="string">"d_id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getBlogByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyResult1"</span>&gt;</span></span><br><span class="line">        select * from tb_user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlogMapperPlus mapper = session.getMapper(BlogMapperPlus.class);</span><br><span class="line">Blog dept = mapper.getBlogByIdStep(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h5 id="分布查询-amp-延迟加载"><a href="#分布查询-amp-延迟加载" class="headerlink" title="分布查询&amp;延迟加载"></a>分布查询&amp;延迟加载</h5><p>每次查询user的时候，都将一起查询出来。部门信息在我们使用的时候再去查询；</p>
<p>需要在分段查询的基础上再加两个配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启延迟加载 显示的指定每个我们需要更改的配置的值，即使他是默认的，防止更新带来的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在需要任何属性的时候，属性都会被加载，否则属性会在被需要的时候加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlogMapperPlus mapper = session.getMapper(BlogMapperPlus.class);</span><br><span class="line">Blog dept = mapper.getBlogByIdStep(<span class="number">5</span>);</span><br><span class="line">System.out.println(dept.getName());</span><br></pre></td></tr></table></figure>
<h5 id="collection定义关联集合封装规则"><a href="#collection定义关联集合封装规则" class="headerlink" title="collection定义关联集合封装规则"></a>collection定义关联集合封装规则</h5><p>场景二：查询部门的时候将部门对应的所有员工信息也查询出来。</p>
<p><collection>定义关联集合类型的属性的封装规则</collection></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--嵌套结果集方式，使用collection标签定义关联的集合类型的属性封装规则--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyDept"</span> <span class="attr">type</span>=<span class="string">"com.zero.bean.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--collection定义关联集合类型的属性的封装规则</span></span><br><span class="line"><span class="comment">        这里指定blogs是一个集合</span></span><br><span class="line"><span class="comment">        ofType:指定集合里面元素的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"blogs"</span> <span class="attr">ofType</span>=<span class="string">"com.zero.bean.Blog"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义集合中元素的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--getDeptByIdPlus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByIdPlus"</span> <span class="attr">resultMap</span>=<span class="string">"MyDept"</span>&gt;</span></span><br><span class="line">    select d.id did,d.dept_name dept_name,e.id eid,e.name name,e.address address</span><br><span class="line">    from tbl_dept d</span><br><span class="line">    left join tb_user e</span><br><span class="line">    on d.id=e.d_id</span><br><span class="line">    where d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时查询结果时出现两个问题：</p>
<ul>
<li>不显示department的id，id为null</li>
<li>该部门有多个员工时提示报错。</li>
</ul>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/%E6%A1%86%E6%9E%B6/Mybatis/found%EF%BC%9A2.png?raw=true" alt=""></p>
<p>上面两个问题都是由于一个原因：</p>
<p>在DepartmentMapper.xml中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.id did   查询出来的是以did命名的</span><br></pre></td></tr></table></figure>
<p>而resultMap</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>column依然是id，这里改为did即可。</p>
<h5 id="collection分布查询-amp-延迟加载"><a href="#collection分布查询-amp-延迟加载" class="headerlink" title="collection分布查询&amp;延迟加载"></a>collection分布查询&amp;延迟加载</h5><p>分不查询可以先查dept中id为1的对象</p>
<p>然后再查employee中did也为1的对象</p>
<p>操作如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByDeptId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByDeptId"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span> &gt;</span></span><br><span class="line">    select * from tb_user where d_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DepartmentMapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptByIdStep</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyDeptStep"</span> <span class="attr">type</span>=<span class="string">"com.zero.bean.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"employees"</span> <span class="attr">select</span>=<span class="string">"com.zero.dao.EmployeeMapperPlus.getEmpsByDeptId"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--getDeptByIdStep--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyDeptStep"</span>&gt;</span></span><br><span class="line">    select id,dept_name dept_name from tbl_dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>column是指定要把那一列的值传给这个方法</p>
<p>如果要将多列的值传入要怎么操作呢？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyDeptStep"</span> <span class="attr">type</span>=<span class="string">"com.zero.bean.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"employees"</span> <span class="attr">select</span>=<span class="string">"com.zero.dao.EmployeeMapperPlus.getEmpsByDeptId"</span> <span class="attr">column</span>=<span class="string">"&#123;deptId=id&#125;"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--getDeptByIdStep--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyDeptStep"</span>&gt;</span></span><br><span class="line">    select id,dept_name dept_name from tbl_dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--扩展 collection要传递多列的值</span></span><br><span class="line"><span class="comment">    column="&#123;key1=column1,key2=column2&#125;"</span></span><br><span class="line"><span class="comment">    fetchType="lazy"  ：表示使用延迟加载</span></span><br><span class="line"><span class="comment">    lazy：延迟</span></span><br><span class="line"><span class="comment">    eager：立即</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="discriminator标签鉴别器"><a href="#discriminator标签鉴别器" class="headerlink" title="discriminator标签鉴别器"></a>discriminator标签鉴别器</h5><p>mybatis可以通过鉴别器识别某个列的值并作出相应的操作。</p>
<p>例如：如果是女生就把该女生的部门信息查询出来</p>
<p>​       如果是男生就不查询部门信息，但是要把name赋值给email</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyEmpDis"</span> <span class="attr">type</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis可以使用鉴别器判某列的值，然后根据某列的值改变封装行为</span></span><br><span class="line"><span class="comment">        封装Employee:</span></span><br><span class="line"><span class="comment">            如果查出的是女生 0 就把部门信息查询出来，否则不查。</span></span><br><span class="line"><span class="comment">            如果是男生 1，把name这一列的值赋值给email</span></span><br><span class="line"><span class="comment">        column:指定要判定的列名</span></span><br><span class="line"><span class="comment">        javaType:列值对应的java类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"string"</span> <span class="attr">column</span>=<span class="string">"gender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--女生 resultType:列值对应的java类型.也可以是resultMap但是不能缺少--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">select</span>=<span class="string">"com.zero.dao.DepartmentMapper.getDeptById"</span> <span class="attr">column</span>=<span class="string">"d_id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--男生把name赋值给email--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DynamicSQL"><a href="#DynamicSQL" class="headerlink" title="DynamicSQL"></a>DynamicSQL</h3><ul>
<li>动态SQL是Mybatis强大特性之一。极大的简化我们拼装SQL的操作。</li>
<li>动态SQL元素和使用JSTL或其他类似基于XML的文本处理器相似。</li>
<li>MyBatis采用功能强大的基于OGNL的表达式来简化操作。<ul>
<li>if</li>
<li>choose(when , otherwise)</li>
<li>trim(where,set)</li>
<li>foreach</li>
</ul>
</li>
</ul>
<h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询员工，emp对象携带了那个字段就通过这个字段来查询或者叠加查询--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByconditionIf"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">       select * from tb_user</span><br><span class="line">       where</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">           id=#&#123;id&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- test:判断表达式（OGNL）  c:if test</span></span><br><span class="line"><span class="comment">            从参数中取值进行判断</span></span><br><span class="line"><span class="comment">            遇见特殊符号应该去写转义字符比如</span></span><br><span class="line"><span class="comment">             " :&amp;quot;   或者 ''</span></span><br><span class="line"><span class="comment">             &amp;&amp; ： &amp;amp;&amp;amp;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name !=null and name !=''"</span>&gt;</span></span><br><span class="line">           and name like #&#123;name&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;if test="address !=null and address !='' "&gt;--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address !=null &amp;amp;&amp;amp; address !=&amp;quot;&amp;quot; "</span>&gt;</span></span><br><span class="line">           and address =#&#123;address&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email !=null and email.trim()!=&amp;quot;&amp;quot;"</span>&gt;</span></span><br><span class="line">           and email=#&#123;email&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--ognl会进行字符串与数字的转换判断 "0"==0  字符串0和数字0是一样的 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">           and gender=#&#123;gender&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里传入的参数是Employee，OGNL会自动识别里面的值</p>
<h4 id="where查询条件"><a href="#where查询条件" class="headerlink" title="where查询条件"></a>where查询条件</h4><p>上面的如果没有id，那么sql语句就会直接变成select * from tb_user  where and address = ?</p>
<p>明显sql语句是错误的。</p>
<p>如果查询的时候如果某些条件没带sql拼装就会有问题</p>
<p>解决方法：</p>
<ol>
<li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where  1==1</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis使用where标签来将所有的查询条件包括在内</p>
</li>
</ol>
<p>将所有if放到<where></where>标签内即可。这样，mybatis会将where标签中多出来的and或者or去掉。但是有时候where也是不好使的。例如：</p>
<p>将and放在语句的后面。  email=#{email}</p>
<p>where就只会去掉第一个多出来的and或者or</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_user <span class="keyword">WHERE</span> address =? <span class="keyword">and</span></span><br></pre></td></tr></table></figure>
<p><strong>所以在使用where标签的时候，and要写在第一位</strong></p>
<h4 id="sql-trim自定义字符串截取"><a href="#sql-trim自定义字符串截取" class="headerlink" title="sql_trim自定义字符串截取"></a>sql_trim自定义字符串截取</h4><p>就像上面的where标签所描述的那样，如果把and或者or放在了sql的后面，那么只能识别第一个and或者or其他的就会报错。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">""</span> <span class="attr">prefixOverrides</span>=<span class="string">""</span> <span class="attr">suffix</span>=<span class="string">""</span> <span class="attr">suffixOverrides</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>trim有四个属性</p>
<ul>
<li>prefix：给拼串后的整个字符串加一个前缀</li>
<li>prefixOverrides:前缀覆盖：去掉整个字符串前面多余的字符</li>
<li>suffix：给拼串后的整个字符串加一个后缀</li>
<li>suffixOverrides：去掉整个字符串后面多余的字符</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByonditionTrim"</span>  <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">        select * from tb_user</span><br><span class="line">        <span class="comment">&lt;!-- 自定义截取规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">suffixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- test:判断表达式（OGNL）  c:if test</span></span><br><span class="line"><span class="comment">         从参数中取值进行判断</span></span><br><span class="line"><span class="comment">         遇见特殊符号应该去写转义字符比如</span></span><br><span class="line"><span class="comment">          " :&amp;quot;   或者 ''</span></span><br><span class="line"><span class="comment">          &amp;&amp; ： &amp;amp;&amp;amp;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name !=null and name !=''"</span>&gt;</span></span><br><span class="line">         name like #&#123;name&#125; and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;if test="address !=null and address !='' "&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address !=null &amp;amp;&amp;amp; address !=&amp;quot;&amp;quot; "</span>&gt;</span></span><br><span class="line">         address =#&#123;address&#125;  and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email !=null and email.trim()!=&amp;quot;&amp;quot;"</span>&gt;</span></span><br><span class="line">         email=#&#123;email&#125; and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ognl会进行字符串与数字的转换判断 "0"==0  字符串0和数字0是一样的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">         gender=#&#123;gender&#125; and</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会自动在最前面添加一个where，然后在最后面去除一个and</p>
<h4 id="sql-choose分支选择"><a href="#sql-choose分支选择" class="headerlink" title="sql_choose分支选择"></a>sql_choose分支选择</h4><p>类似于java里的 switch   case</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--choose：分支选择</span></span><br><span class="line"><span class="comment">        如果带了id就用id查，如果带了name就用name查，只会进入其中一个</span></span><br><span class="line"><span class="comment">        choose标签里的when标签里的test就是判断条件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByonditionChoose"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">      select * from tb_user</span><br><span class="line">      <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                  id=#&#123;id&#125;</span><br><span class="line">              <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"name!=null"</span>&gt;</span></span><br><span class="line">                  name like #&#123;name&#125;</span><br><span class="line">              <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">                  email = #&#123;email&#125;</span><br><span class="line">              <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                  gender = 0</span><br><span class="line">              <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果传入了多个判断条件，那么它只会查符合第一个条件的</p>
<h4 id="sql-set"><a href="#sql-set" class="headerlink" title="sql_set"></a>sql_set</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 带了那一列的值就更新那一列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmp"</span>&gt;</span></span><br><span class="line">    update  tb_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"set"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null"</span>&gt;</span></span><br><span class="line">        name=#&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">        email=#&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="sql-foreach遍历集合"><a href="#sql-foreach遍历集合" class="headerlink" title="sql_foreach遍历集合"></a>sql_foreach遍历集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByConditionForeach"</span> <span class="attr">resultType</span>=<span class="string">"com.zero.bean.Employee"</span>&gt;</span></span><br><span class="line">    select * from tb_user where id in</span><br><span class="line">    <span class="comment">&lt;!-- collection:指定要遍历的集合：</span></span><br><span class="line"><span class="comment">         list类型的参数会特殊处理封装map中，map的key就叫list</span></span><br><span class="line"><span class="comment">         item：将当前遍历出的元素赋值给指定的定位</span></span><br><span class="line"><span class="comment">         separator:每个元素之间的分隔符</span></span><br><span class="line"><span class="comment">         open:遍历所有结果拼接一个开始的字符</span></span><br><span class="line"><span class="comment">         close:遍历出所有结果拼接一个结束的字符</span></span><br><span class="line"><span class="comment">         index:索引。遍历list的时候是索引，item就是当前值</span></span><br><span class="line"><span class="comment">                    遍历map的时候index表示的就是map的key，item就是map的值</span></span><br><span class="line"><span class="comment">         #&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item_id"</span> <span class="attr">separator</span>=<span class="string">","</span>  <span class="attr">open</span> =<span class="string">"("</span> <span class="attr">close</span> =<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item_id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpByConditionForeach</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapperDynamicSQL mapper = session.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">List&lt;Employee&gt; foreach = mapper.getEmpByConditionForeach(Arrays.asList(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"><span class="keyword">for</span> (Employee e:foreach)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="批量保存"><a href="#批量保存" class="headerlink" title="批量保存"></a>批量保存</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps"</span> &gt;</span></span><br><span class="line">    insert into tb_user(name,address,email,gender,d_id)</span><br><span class="line">    values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;emp.name&#125;,#&#123;emp.address&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapperDynamicSQL mapper = session.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">emps.add(<span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="string">"smith"</span>,<span class="string">"beijing"</span>,<span class="string">"whyathere@163.com"</span>,<span class="string">"1"</span>,<span class="keyword">new</span> Department(<span class="number">1</span>)));</span><br><span class="line">emps.add(<span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="string">"smith"</span>,<span class="string">"beijing"</span>,<span class="string">"whyathere@163.com"</span>,<span class="string">"1"</span>,<span class="keyword">new</span> Department(<span class="number">2</span>)));</span><br><span class="line">mapper.addEmps(emps);</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure>
<p><strong>另外一种方式</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">        insert into tb_user(name,address,gender,email,d_id)</span><br><span class="line">        values (#&#123;emp.name&#125;,#&#123;emp.address&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是这个时候会报错。sql不支持。需要进行配置</p>
<p>allowMultiQueries：在一条语句中，运行使用”;”来分隔多条查询(真/假，默认值为”假”)</p>
<h4 id="内置参数-parameter-amp-databaseld"><a href="#内置参数-parameter-amp-databaseld" class="headerlink" title="内置参数_parameter&amp;_databaseld"></a>内置参数_parameter&amp;_databaseld</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--两个内置参数</span></span><br><span class="line"><span class="comment">    不只是方法传递过来的参数可以被用来判断，取值</span></span><br><span class="line"><span class="comment">    mybatis默认还有两个内置参数：</span></span><br><span class="line"><span class="comment">    _parameter:代表整个参数</span></span><br><span class="line"><span class="comment">    如果是单个参数:_parameter就是这个参数；</span></span><br><span class="line"><span class="comment">         多个参数:就会被封装为一个map，_parameter就代表这个map；</span></span><br><span class="line"><span class="comment">    _databaseId:</span></span><br><span class="line"><span class="comment">         如果配置了databaseIdProvider标签</span></span><br><span class="line"><span class="comment">         _databaseId就是代表当前数据库的别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/Java%E5%9F%BA%E7%A1%80/databaseProvider.png?raw=true" alt=""></p>
<p><img src="https://github.com/whyathere/tuchuang/blob/master/Java%E5%9F%BA%E7%A1%80/select.png?raw=true" alt=""></p>
<h4 id="sql-bing绑定"><a href="#sql-bing绑定" class="headerlink" title="sql_bing绑定"></a>sql_bing绑定</h4><p>bing：可以将ognl表达式的值绑定到一个变量中，方便后面引用这个变量的值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bind: 可以将OGNL表达式的值绑定到一个变量中，方便后面来引用这个变量的值</span></span><br><span class="line"><span class="comment">     value:就是要绑定值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"_name"</span> <span class="attr">value</span>=<span class="string">"'%'+name+'%'"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的是将name拼串模糊查询的样例，然后赋值给_name</p>
<h4 id="抽取可重用sql片段"><a href="#抽取可重用sql片段" class="headerlink" title="抽取可重用sql片段 "></a>抽取可重用sql片段 <sql></sql></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"insertColum"</span>&gt;</span></span><br><span class="line">  user_id,name,email</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"insertColum"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testColomn"</span> <span class="attr">value</span>=<span class="string">"adc"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">设置了property就可以用$&#123;testColomn&#125;取值</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ol>
<li><p>sql抽取：将常要查询的列名，或者插入用的列名抽取出来方便使用</p>
</li>
<li><p>include还可以自定义一些property，sql标签内部就能使用自定义的属性</p>
<p>include标签的property设置的值，需要用${取值}而不能用#{}</p>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地配置和定制。缓存可以极大的提升查询效率。</p>
<ol>
<li>Mybatis系统中默认定义了两级缓存。</li>
<li><p>一级缓存<strong>和 </strong>二级缓存**</p>
</li>
<li><p>默认情况下，只有一级缓存(SqlSession级别的缓存，也称为本地缓存)开启。</p>
</li>
<li><p>二级缓存需要手动开启和配置，他是基于namespace级别的缓存</p>
</li>
<li><p>为了提高扩展性。Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p>
</li>
</ol>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>一级缓存：本地缓存</p>
<p>与数据库同一次会话期间查询到的数据会放在本地缓存中。以后如果要获取相同的数据，直接从缓存中拿，没必要再去查询数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapperPlus mapper = session.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">Employee emp1 = mapper.getEmployeeById(<span class="number">5</span>);</span><br><span class="line">Employee emp2 = mapper.getEmployeeById(<span class="number">5</span>);</span><br><span class="line">System.out.println(emp1);</span><br><span class="line">System.out.println(emp2);</span><br></pre></td></tr></table></figure>
<p>二级缓存：全局缓存</p>
<p>例如：按照id来查询同一个id两次，那么两次拿到的东西其实是一样的。包括对象。是从一级缓存中拿的。</p>
<h5 id="一级缓存失效的四种情况"><a href="#一级缓存失效的四种情况" class="headerlink" title="一级缓存失效的四种情况"></a>一级缓存失效的四种情况</h5><p>一级缓存是一直开启的，个人是无法关闭的。</p>
<p>一级缓存是sqlSession级别的缓存。</p>
<p>一级缓存失效情况：一级缓存没有使用，效果是还需要再向数据库发送查询</p>
<ol>
<li><p>sqlsession不同</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapperPlus mapper = session.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">Employee emp1 = mapper.getEmployeeById(<span class="number">5</span>);</span><br><span class="line">System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">SqlSession session1 = sessionFactory.openSession();</span><br><span class="line">EmployeeMapperPlus mapper1 = session1.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">Employee employeeById = mapper1.getEmployeeById(<span class="number">5</span>);</span><br><span class="line">System.out.println(employeeById);</span><br></pre></td></tr></table></figure>
<p>两次结果就不同了。而且发送了两次sql查询语句。</p>
</li>
<li><p>sqlSession相同，但是查询条件不同，当前这个session还没有这个数据</p>
</li>
<li><p>sqlSession相同，两次查询之间执行了增删改操作。添加了信息就会重新发送</p>
</li>
<li><p>sqlSession相同，但是手动清除了一级缓存。</p>
</li>
</ol>
<p>openSession.clearCache();    //清除缓存</p>
<h4 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h4><p>二级缓存是基于namespace级别的缓存：一个名称空间对应一个二级缓存</p>
<p>二级缓存工作机制：</p>
<ol>
<li>一个会话查询一条数据：这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存也就没有了。但是mybatis并没有清空，如果会话关闭，一级缓存中的数据会被保存到二级缓存中。新的会话查询信息，就可以参照二级缓存</li>
<li>sqlSession既有employeemapper查的employee又有DepartmentMapper查的Department对象。会被放在两个不同的namespace中，会放在自己的map中。</li>
</ol>
<h4 id="二级缓存的使用"><a href="#二级缓存的使用" class="headerlink" title="二级缓存的使用"></a>二级缓存的使用</h4><p>使用：开启全局二级缓存配置</p>
<ol>
<li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.</p>
<p>由于二级缓存是基于mapper级别的，一个namespace对应一个二级缓存</p>
<p>需要去mapper.xml中配置二级缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.zero.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样即开启了。</p>
<p>但是也有一些默认的策略。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">""</span> <span class="attr">flushInterval</span>=<span class="string">""</span> <span class="attr">readOnly</span>=<span class="string">""</span> <span class="attr">size</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>eviction</strong>：缓存的回收策略:</p>
<ul>
<li><p>LRU - 最近最少使用的；移除最长时间不被使用的对象。</p>
</li>
<li><p>FIFO - 先进先出；按照对象进入缓存的顺序来移除它们</p>
</li>
<li>SOFT - 软引用;移除基于垃圾回收器状态和软引用规则的对象</li>
<li>WEAK - 弱引用；更积极地移除基于垃圾收集器状态和弱引用规则的对象</li>
<li>默认的是LRU。</li>
</ul>
<p><strong>flushInterval</strong> : 缓存刷新间隔</p>
<p>缓存多长时间清空一次，默认是不清空，设置一个毫秒值</p>
<p><strong>readOnly</strong>：缓存是否只读。</p>
<p>true:只读。mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改操作</p>
<p>​        mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，但是速度快</p>
<p>false：非只读；mybatis觉的获取来的数据可能会被修改。</p>
<p>​            mybatis会利用序列化&amp;反序列化技术克隆一份新的数据给你。安全，速度稍慢一点。</p>
<p>默认是false</p>
<p><strong>size</strong>：缓存存放多少元素</p>
<p><strong>type</strong>:””,指定自定义缓存的全类名；</p>
<p>​        实现Cache接口即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FOFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">readOnly</span>=<span class="string">"false"</span> <span class="attr">size</span>=<span class="string">"1024"</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>我们的POJO需要实现序列号接口，因为需要序列化和序列化</li>
</ol>
<p>首先在未开启二级缓存的时候进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">"mybatis/mybatis-config.xml"</span>;</span><br><span class="line">    InputStream is = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">    SqlSession session1 = sessionFactory.openSession();</span><br><span class="line">    SqlSession session2 = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper1 = session1.getMapper(EmployeeMapper.class);</span><br><span class="line">        EmployeeMapper mapper2 = session2.getMapper(EmployeeMapper.class);</span><br><span class="line">        Employee employee = mapper1.getEmployee(<span class="number">5</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        session1.close();</span><br><span class="line">        Employee employee1 = mapper2.getEmployee(<span class="number">5</span>);</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line">        session2.close();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">        session2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时会进行两次sql查询。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">readOnly</span>=<span class="string">"false"</span> <span class="attr">size</span>=<span class="string">"1024"</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>开启缓存</p>
<p>就只会查询一次了，这里要注意一定要实现Employee类的序列化。</p>
<p>这次查询 是从二级缓存中获取，而不是再去查询。</p>
<p>虽然关闭了一级缓存，但是放到了二级缓存中。</p>
<p>只有会话提交或者关闭，一级缓存中的数据才会转移到二级缓存中。</p>
<h4 id="缓存有关的设置以及属性"><a href="#缓存有关的设置以及属性" class="headerlink" title="缓存有关的设置以及属性"></a>缓存有关的设置以及属性</h4><ol>
<li><p>开启缓存，false的时候是关闭缓存。关闭的是二级缓存，一级缓存一直可用</p>
</li>
<li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么可以用缓存。</p>
<p>在每一个查询<select>标签都会有一个属性，userCache使用缓存，默认为true</select></p>
<p>一级二级都可以使用，当关闭的时候禁用的时候一级缓存依然可以使用。</p>
<p>useCache对一级缓存是没有影响的，影响的是二级缓存。</p>
</li>
<li><p>每个增删改标签都有一个属性 flushCache = “true”；增删改执行完成后就会清除缓存。清除一级缓存和二级缓存。都会清除。虽然会从二级缓存查询，但是二级缓存已经被清除了。查询是不清除缓存的，如果查询标签设置flushCache = “true”也会禁用掉一级二级缓存。</p>
</li>
<li><p>sqlSession.clearCache();  只是清除Session的一级缓存跟二级缓存没有关系</p>
<h4 id="缓存的原理总结"><a href="#缓存的原理总结" class="headerlink" title="缓存的原理总结"></a>缓存的原理总结</h4><p>一级缓存会话关闭才会保存在二级缓存中。</p>
<p>关闭以后，新的会话进来，已经存在二级缓存的话就会先查找二级缓存中是否有对应的数据。</p>
<p>一进来就先看二级缓存，因为它的范围更大，如果没有才会去查找一级缓存。最好才会去查找数据库。</p>
</li>
</ol>
<h3 id="整合ehcache"><a href="#整合ehcache" class="headerlink" title="整合ehcache"></a>整合ehcache</h3><p>1、首先导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在mapper中添加一个标签就可以了</p>
<cache type="org.mybatis.caches.encache.EncacheCache">

<p>ehcache运行的时候需要一个ehcache.xml文件</p>
<h3 id="Mybatis语句"><a href="#Mybatis语句" class="headerlink" title="Mybatis语句"></a>Mybatis语句</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id="Base_Column_List" &gt;</span><br><span class="line">    `id`,`user_id`,`channel_id`,`create_user`,`update_user`,`create_time`,`update_time`,`status`</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>
<p><code></code>是为了防止关键字的，一般最好加上</p>
</cache>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Mac使用中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Mac使用中遇到的问题/" itemprop="url">Mac使用中遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T18:27:21+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mac/" itemprop="url" rel="index">
                    <span itemprop="name">Mac</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>## </p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="本地安装启动redis"><a href="#本地安装启动redis" class="headerlink" title="本地安装启动redis"></a>本地安装启动redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make test</span><br></pre></td></tr></table></figure>
<p>在执行redis 编译测试的时候提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>
<p>解决办法是打开 Terminal，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>这将下载并安装 xcode 开发者工具，之后就会修复这个问题。这个问题是因为需要你明确同意许可协议。如果你有多个版本的 Xcode 或者只需要命令行工具而非 Xcode，你可能需要重置 Xcode 的路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重置 Xcode 路径</span><br><span class="line">xcode-select --switch /Applications/Xcode.app</span><br><span class="line"><span class="meta">#</span> 使用命令行工具</span><br><span class="line">xcode-select --switch /Library/Developer/CommandLineTool</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/深入理解计算机原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bill">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/深入理解计算机原理/" itemprop="url">深入理解计算机原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T18:27:21+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><h4 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h4><p>​    计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。其中两种尤为重要。第一种是由指令集体系结构或指令集架构，来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</p>
<p>​    它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。</p>
<p>​    第二种抽象是，机器级程序使用的内存地址是虚拟的地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</p>
<p>​    在编译过程中，编译器会将C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。</p>
<p>​    计算机系统底层硬件只识别机器语言，而处理器就是用来执行一系列指令，每条指令执行某个简单的操作。比如两个数相加，汇编指令ADD会被编码为一个或多个字节组成的二进制格式。</p>
<p>​    这里 <strong>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构(Instruction-Set Architecture ,ISA)</strong></p>
<p>​    而不同的处理器家族，比如Intel IA32、IBM/Freescale PowerPC和AMD处理器家族，都有不同的ISA。不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言是一样的。不同的处理器，其指令集体系结构也不一样，也就是说一个程序编译在一种机器上运行，就不能在另外一种机器上运行。如何处理这种兼容性问题呢？ <strong>ISA在编译器编写者和处理器设计人之间提供了一个抽象概念层，编译器编写者只需要知道允许那些指令，以及它们是如何编写的；而处理器设计者必须建造出这些指令的处理器。</strong></p>
<ul>
<li>程序计数器(通常称为”PC”，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。</li>
</ul>
<p>机器代码只是简单地将内存看出一个很大的、按字节寻址的数组。C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。<strong>即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数</strong></p>
<p>​    程序内存包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用 <strong>虚拟地址来寻址</strong>。在任意给定时刻，只有有限的一部分虚拟地址被认为是合法的。例如，x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是2的48次方或64TB范围内的一个字节。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>
<p>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</p>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>​    由于是从16位体系结构扩展成32位的，Intel 用术语 “字(word)”表示16位数据类型。因此32位数为”双字(double words)”，称64位数为”四字(quad words)”。</p>
<table>
<thead>
<tr>
<th style="text-align:center">C声明</th>
<th style="text-align:center">Intel数据类型</th>
<th style="text-align:center">汇编代码后缀</th>
<th style="text-align:center">大小(字节)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">字节</td>
<td style="text-align:center">b</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">字</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">字</td>
<td style="text-align:center">l</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">char*</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度</td>
<td style="text-align:center">s</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度</td>
<td style="text-align:center">l</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>​            C语言数据类型在x86-64中的大小。在64位机器中，指针长8字节</p>
<p>​    浮点数主要有两种形式：单精度(4字节)值，对应于C语言数据类型float；双精度对应double。    </p>
<p>​    如上表所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如：数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。注意，汇编代码也会使用后缀’1’来表示4字节整数和8字节双精度浮点数。因为浮点数使用的是一组完全不同的指令和寄存器。</p>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>​    一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的 <strong>通用目的的寄存器</strong>。这些寄存器用来<strong>存储整数数据和指针。</strong></p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/2018-11-16-093431.png" alt=""></p>
<h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>​    大多数指令有一个或多个 <strong>操作数(operand)</strong>，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式。如下图。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。</p>
<p>​    第一种类型是 <strong>立即数(immediate)</strong>，用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是’$’后面跟一个用标准C表示法表示的整数，比如,$-577或$0x1F。不同的指令允许的立即数数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。</p>
<p>​    第二种类型是 <strong>寄存器(register)</strong>，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节分别对应于8位、16位、32位或64位。符号ra来表示任意寄存器a，用引用R[ra]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符做索引。</p>
<p>​    第三类操作数是 <strong>内存引用</strong>，它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为将内存看成一个很大的字节数组。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/2018-11-16-093554.png" alt="image-20181116173554467"></p>
<h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>​    最频繁使用的指令是将数据从一个位置复制到另一个位置。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MOV       S,D</td>
<td style="text-align:center">D←S</td>
<td style="text-align:center">传送</td>
</tr>
<tr>
<td style="text-align:center">movb</td>
<td style="text-align:center"></td>
<td style="text-align:center">传送字节</td>
</tr>
<tr>
<td style="text-align:center">movw</td>
<td style="text-align:center"></td>
<td style="text-align:center">传送字(2字节)</td>
</tr>
<tr>
<td style="text-align:center">movl</td>
<td style="text-align:center"></td>
<td style="text-align:center">传送双字(4字节)</td>
</tr>
<tr>
<td style="text-align:center">movq</td>
<td style="text-align:center"></td>
<td style="text-align:center">传送四字(8字节)</td>
</tr>
<tr>
<td style="text-align:center">movabsq     I,R</td>
<td style="text-align:center">R←I</td>
<td style="text-align:center">传送绝对的四字</td>
</tr>
</tbody>
</table>
<p>​    源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个 <strong>位置</strong>，要么是一个寄存器要么是一个内存地址。x86-64限制， <strong>传送指令的两个操作数不能都指向内存位置。</strong>因为这样需要将需要两条指令：第一条指令将源值加载到寄存器中，第二条将寄存器值写入到目的位置。</p>
<h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>在x86-64中，程序栈存放在内存中某个区域。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。</p>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令 pushq %rbp的行为等价于下面两条指令：</p>
<p>​    subq $8,%rsp</p>
<p>​    movq %rbp,(%rsp)</p>
<p>它们之前的区别是在机器代码中pushq指令编码为1个字节，而上面那两条指令一共需要8个字节。</p>
<p>如下图前两栏给出的是，当%rsp为0x108,%rax 为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后将0x123存放到内存地址0x100处。</p>
<p><img src="http://pcq0v117m.bkt.clouddn.com/2018-11-16-093235.png" alt="image-20181116173231518"></p>
<p>弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8.因此，指令popq %rax等价于下面两条指令：        </p>
<p>​    movq (%rsp),%rax</p>
<p>​    add $8,%rsp</p>
<p>​    上图的第三栏说明的是在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读处值 0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值将增加回到0x108。如图中所示，值0x123仍然会保持在内存位置0x100中，知道被覆盖(例如被另外一条入栈操作覆盖)。无论如何，%rsp指向的地址总是栈顶。</p>
<p>​    因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令movq 8(%rsp),%rdx会将第二个四字从栈中复制到寄存器%rdx.</p>
<h2 id="第八章：异常控制流"><a href="#第八章：异常控制流" class="headerlink" title="第八章：异常控制流"></a>第八章：异常控制流</h2><p>从处理器通电开始，知道断电，程序计数器假设了一个值的序列</p>
<p>​        a0,a1,a2……,an-1</p>
<p>每个ak是某个相应的指令Ik的地址。每次从ak到ak+1的过渡叫  <code>控制转移</code>(control transfer)。这样的控制转义序列叫做处理器的 <code>控制流</code>(flow of control 或control flow)。</p>
<p>最简单的控制流是一个“平滑的”序列，每个Ik和Ik+1在内存中都是相邻的。不相邻的就是平滑流的突变，通常是由诸如跳转、调用和返回这样的程序指令造成的。这样使得程序能够对程序变量表示的内部程序状态中的变化做出反应。</p>
<p>系统也应该要对系统状态的变化做出反应，例如网络信号的到达，必须放到内存中，需要处理器进行反应。现代的操作系统通过 <code>是控制流发生突变来对这些情况做出反应</code>。一般而言，我们称这些突变为 <strong>异常控制流(Exceptional Control Flow ,ECF)</strong></p>
<p>应用和操作系统的交互都是围绕着ECF开始的。一个计算机操作系统中所有层次上有各种各样的ECF，从异常开始，异常位于硬件和操作系统交界的部分。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现;是控制流中的一种突变，用来响应处理器状态中的某些变化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
